

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="jlk-lebron">
  <meta name="keywords" content="">
  
    <meta name="description" content="Vue3.0 为什么要用 proxy？在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶  不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 全方位的数组变化检测，消除了Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue面试题">
<meta property="og:url" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/index.html">
<meta property="og:site_name" content="小王的博客">
<meta property="og:description" content="Vue3.0 为什么要用 proxy？在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶  不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 全方位的数组变化检测，消除了Vue">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/6db40e34e3ca442d9a5dd0917b0e61c3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f2f36643d8b84b97a25fcf49ec42956btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1787bafd86d24586bc05a2607bd7cd8ftplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/136cfa792cd64daebc60b7586dd2c815tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1336625195f1472ca7360f6f54a82c28tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/d80e4cd2bad14af2801713ddb9e98094tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1c1b78ece7b64c44812d7e0362389928tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/b882b3d85eb24d85b7570faa587373d3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f7987b4d0f7a47d5b46ac3ba59160a79tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="article:published_time" content="2022-11-02T06:33:38.000Z">
<meta property="article:modified_time" content="2023-05-26T08:27:11.200Z">
<meta property="article:author" content="jlk-lebron">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jlk-lebron.github.io/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/6db40e34e3ca442d9a5dd0917b0e61c3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
  
  
  
  <title>Vue面试题 - 小王的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jlk-lebron.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小王的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/067.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Vue面试题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-02 14:33" pubdate>
          2022年11月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          31k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          256 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue面试题</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="Vue3-0-为什么要用-proxy？"><a href="#Vue3-0-为什么要用-proxy？" class="headerlink" title="Vue3.0 为什么要用 proxy？"></a>Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p>
<ul>
<li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li>
<li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li>
<li>支持 Map，Set，WeakMap 和 WeakSet。</li>
</ul>
<p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p>
<ul>
<li>get 收集依赖</li>
<li>Set、delete 等触发依赖</li>
<li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li>
</ul>
<h3 id="说说你对slot的理解？slot使用场景有哪些"><a href="#说说你对slot的理解？slot使用场景有哪些" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些"></a>说说你对slot的理解？slot使用场景有哪些</h3><h4 id="一、slot是什么"><a href="#一、slot是什么" class="headerlink" title="一、slot是什么"></a>一、slot是什么</h4><p>在HTML中 <code>slot</code> 元素 ，作为 <code>Web Components</code> 技术套件的一部分，是Web组件内的一个占位符</p>
<p>该占位符可以在后期使用自己的标记语言填充</p>
<p>举个栗子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;element-details-template&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>Slot template<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">element-details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">element-details</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">element-details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">element-details</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>template</code>不会展示到页面中，需要用先获取它的引用，然后添加到<code>DOM</code>中，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;element-details&#x27;</span>,<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">HTMLElement</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">super</span>();<br>      <span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span><br>        .<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;element-details-template&#x27;</span>)<br>        .<span class="hljs-property">content</span>;<br>      <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123;<span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span>&#125;)<br>        .<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>在<code>Vue</code>中的概念也是如此</p>
<p><code>Slot</code> 艺名插槽，花名“占坑”，我们可以理解为<code>solt</code>在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中<code>slot</code>位置），作为承载分发内容的出口</p>
<h4 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h4><p>通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p>
<p>如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情</p>
<p>通过<code>slot</code>插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用</p>
<p>比如布局组件、表格列、下拉选、弹框显示内容等</p>
<h3 id="使用vue渲染大量数据时应该怎么优化？说下你的思路！"><a href="#使用vue渲染大量数据时应该怎么优化？说下你的思路！" class="headerlink" title="使用vue渲染大量数据时应该怎么优化？说下你的思路！"></a>使用vue渲染大量数据时应该怎么优化？说下你的思路！</h3><p><strong>分析</strong></p>
<p>企业级项目中渲染大量数据的情况比较常见，因此这是一道非常好的综合实践题目。</p>
<p><strong>回答</strong></p>
<ol>
<li>在大型企业级项目中经常需要渲染大量数据，此时很容易出现卡顿的情况。比如大数据量的表格、树</li>
<li>处理时要根据情况做不同处理：</li>
</ol>
<ul>
<li>可以采取分页的方式获取，避免渲染大量数据</li>
<li><a href="https://link.juejin.cn/?target=https://github.com/Akryum/vue-virtual-scroller">vue-virtual-scroller <strong>(opens new window)</strong></a>等虚拟滚动方案，只渲染视口范围内的数据</li>
<li>如果不需要更新，可以使用v-once方式只渲染一次</li>
<li>通过<a href="https://link.juejin.cn/?target=https://vuejs.org/api/built-in-directives.html%23v-memo">v-memo <strong>(opens new window)</strong></a>可以缓存结果，结合<code>v-for</code>使用，避免数据变化时不必要的<code>VNode</code>创建</li>
<li>可以采用懒加载方式，在用户需要的时候再加载数据，比如<code>tree</code>组件子树的懒加载</li>
</ul>
<ol>
<li>还是要看具体需求，首先从设计上避免大数据获取和渲染；实在需要这样做可以采用虚表的方式优化渲染；最后优化更新，如果不需要更新可以<code>v-once</code>处理，需要更新可以<code>v-memo</code>进一步优化大数据更新性能。其他可以采用的是交互方式优化，无线滚动、懒加载等方案</li>
</ol>
<h3 id="scoped样式穿透"><a href="#scoped样式穿透" class="headerlink" title="scoped样式穿透"></a>scoped样式穿透</h3><blockquote>
<p><code>scoped</code>虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除<code>scoped</code>属性</p>
</blockquote>
<ol>
<li>使用<code>/deep/</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-comment">&lt;!-- Parent --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.wrap</span> /deep/ <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Child --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>使用两个<code>style</code>标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-comment">&lt;!-- Parent --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 其他样式 */</span></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Child --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Vue中v-html会导致哪些问题"><a href="#Vue中v-html会导致哪些问题" class="headerlink" title="Vue中v-html会导致哪些问题"></a>Vue中v-html会导致哪些问题</h3><ul>
<li>可能会导致 <code>xss</code> 攻击</li>
<li><code>v-html</code> 会替换掉标签内部的子元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-template-compiler&#x27;</span>); <br><span class="hljs-keyword">let</span> r = template.<span class="hljs-title function_">compile</span>(<span class="hljs-string">`&lt;div v-html=&quot;&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;&quot;&gt;&lt;/div&gt;`</span>) <br><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,&#123;domProps: &#123;&quot;innerHTML&quot;:_s(&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;)&#125;&#125;)&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r.<span class="hljs-property">render</span>);<br><br><span class="hljs-comment">// _c 定义在core/instance/render.js </span><br><span class="hljs-comment">// _s 定义在core/instance/render-helpers/index,js</span><br><span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;textContent&#x27;</span> || key === <span class="hljs-string">&#x27;innerHTML&#x27;</span>) &#123; <br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">if</span> (cur === oldProps[key]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// #6601 work around Chrome version &lt;= 55 bug where single textNode // replaced by innerHTML/textContent retains its parentNode property </span><br>    <span class="hljs-keyword">if</span> (elm.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123; <br>        elm.<span class="hljs-title function_">removeChild</span>(elm.<span class="hljs-property">childNodes</span>[<span class="hljs-number">0</span>]) <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如果让你从零开始写一个vuex，说说你的思路"><a href="#如果让你从零开始写一个vuex，说说你的思路" class="headerlink" title="如果让你从零开始写一个vuex，说说你的思路"></a>如果让你从零开始写一个vuex，说说你的思路</h3><p><strong>思路分析</strong></p>
<p>这个题目很有难度，首先思考<code>vuex</code>解决的问题：存储用户全局状态并提供管理状态API。</p>
<ul>
<li><code>vuex</code>需求分析</li>
<li>如何实现这些需求</li>
</ul>
<p><strong>回答范例</strong></p>
<ol>
<li>官方说<code>vuex</code>是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个<code>vuex</code></li>
</ol>
<ul>
<li>要实现一个<code>Store</code>存储全局状态</li>
<li>要提供修改状态所需API：<code>commit(type, payload), dispatch(type, payload)</code></li>
</ul>
<ol>
<li>实现<code>Store</code>时，可以定义<code>Store</code>类，构造函数接收选项<code>options</code>，设置属性<code>state</code>对外暴露状态，提供<code>commit</code>和<code>dispatch</code>修改属性<code>state</code>。这里需要设置<code>state</code>为响应式对象，同时将<code>Store</code>定义为一个<code>Vue</code>插件</li>
<li><code>commit(type, payload)</code>方法中可以获取用户传入<code>mutations</code>并执行它，这样可以按用户提供的方法修改状态。 <code>dispatch(type, payload)</code>类似，但需要注意它可能是异步的，需要返回一个<code>Promise</code>给用户以处理异步结果</li>
</ol>
<p><strong>实践</strong></p>
<p><code>Store</code>的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title function_">reactive</span>(options.<span class="hljs-property">state</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options<br>    &#125;<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-params">type, payload</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">mutations</span>[type].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, payload)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>vuex简易版</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1 实现插件，挂载$store</span><br><span class="hljs-comment"> * 2 实现store</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Vue</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// state响应式处理</span><br>    <span class="hljs-comment">// 外部访问： this.$store.state.***</span><br>    <span class="hljs-comment">// 第一种写法</span><br>    <span class="hljs-comment">// this.state = new Vue(&#123;</span><br>    <span class="hljs-comment">//   data: options.state</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// 第二种写法：防止外界直接接触内部vue实例，防止外部强行变更</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>      <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">$$state</span>: options.<span class="hljs-property">state</span><br>      &#125;<br>    &#125;)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span> = options.<span class="hljs-property">mutations</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span> = options.<span class="hljs-property">actions</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getters</span> = &#123;&#125;<br>    options.<span class="hljs-property">getters</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleGetters</span>(options.<span class="hljs-property">getters</span>)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br><br>  get state () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span>.<span class="hljs-property">_data</span>.<span class="hljs-property">$$state</span><br>  &#125;<br><br>  set state (val) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Please use replaceState to reset state&#x27;</span>)<br>  &#125;<br><br>  handleGetters (getters) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(getters).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getters</span>, key, &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> getters[key](<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  commit (type, payload) &#123;<br>    <span class="hljs-keyword">let</span> entry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span>[type]<br>    <span class="hljs-keyword">if</span> (!entry) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span> is not defined`</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">entry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, payload)<br>  &#125;<br><br>  dispatch (type, payload) &#123;<br>    <span class="hljs-keyword">let</span> entry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span>[type]<br>    <span class="hljs-keyword">if</span> (!entry) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span> is not defined`</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">entry</span>(<span class="hljs-variable language_">this</span>, payload)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">install</span> = (<span class="hljs-params">_Vue</span>) =&gt; &#123;<br>  <span class="hljs-title class_">Vue</span> = _Vue<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    beforeCreate () &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">store</span>) &#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$store</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">store</span><br>      &#125;<br>    &#125;,<br>  &#125;)<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-title class_">Store</span>, install &#125;<br></code></pre></td></tr></table></figure>

<p>验证方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vuex&#x27;</span><br><span class="hljs-comment">// this.$store</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// state从哪里来的</span><br>    add (state) &#123;<br>      state.<span class="hljs-property">counter</span>++<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    doubleCounter (state) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    add (&#123; commit &#125;) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;add&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">modules</span>: &#123;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>参考 <a href="https://link.juejin.cn/?target=https://thoughts.teambition.com/share/638dd9f64d2d2a0042e50fb4">前端进阶面试题详细解答</a></p>
<h3 id="Vue与Angular以及React的区别？"><a href="#Vue与Angular以及React的区别？" class="headerlink" title="Vue与Angular以及React的区别？"></a>Vue与Angular以及React的区别？</h3><h4 id="Vue与AngularJS的区别"><a href="#Vue与AngularJS的区别" class="headerlink" title="Vue与AngularJS的区别"></a>Vue与AngularJS的区别</h4><ul>
<li><code>Angular</code>采用<code>TypeScript</code>开发, 而<code>Vue</code>可以使用<code>javascript</code>也可以使用<code>TypeScript</code></li>
<li><code>AngularJS</code>依赖对数据做脏检查，所以<code>Watcher</code>越多越慢；<code>Vue.js</code>使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li>
<li><code>AngularJS</code>社区完善, <code>Vue</code>的学习成本较小</li>
</ul>
<h4 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h4><p><strong>相同点：</strong></p>
<ol>
<li><code>Virtual DOM</code>。其中最大的一个相似之处就是都使用了<code>Virtual DOM</code>。(当然<code>Vue</code>是在<code>Vue2.x</code>才引用的)也就是能让我们通过操作数据的方式来改变真实的<code>DOM</code>状态。因为其实<code>Virtual DOM</code>的本质就是一个<code>JS</code>对象，它保存了对真实<code>DOM</code>的所有描述，是真实<code>DOM</code>的一个映射，所以当我们在进行频繁更新元素的时候，改变这个<code>JS</code>对象的开销远比直接改变真实<code>DOM</code>要小得多。</li>
<li>组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。</li>
<li><code>Props</code>。<code>Vue</code>和<code>React</code>中都有<code>props</code>的概念，允许父组件向子组件传递数据。</li>
<li>构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，<code>React</code>中可以使用<code>CRA</code>，<code>Vue</code>中可以使用对应的脚手架<code>vue-cli</code>。对于配套框架<code>Vue</code>中有<code>vuex、vue-router</code>，<code>React</code>中有<code>react-router、redux</code>。</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li>模版的编写。最大的不同就是模版的编写，<code>Vue</code>鼓励你去写近似常规<code>HTML</code>的模板，<code>React</code>推荐你使用<code>JSX</code>去书写。</li>
<li>状态管理与对象属性。在<code>React</code>中，应用的状态是比较关键的概念，也就是<code>state</code>对象，它允许你使用<code>setState</code>去更新状态。但是在<code>Vue</code>中，<code>state</code>对象并不是必须的，数据是由<code>data</code>属性在<code>Vue</code>对象中进行管理。</li>
<li>虚拟<code>DOM</code>的处理方式不同。<code>Vue</code>中的虚拟<code>DOM</code>控制了颗粒度，组件层面走<code>watcher</code>通知，而组件内部走<code>vdom</code>做<code>diff</code>，这样，既不会有太多<code>watcher</code>，也不会让<code>vdom</code>的规模过大。而<code>React</code>走了类似于<code>CPU</code>调度的逻辑，把<code>vdom</code>这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做<code>diff</code></li>
</ol>
<h3 id="Vue项目中你是如何解决跨域的呢"><a href="#Vue项目中你是如何解决跨域的呢" class="headerlink" title="Vue项目中你是如何解决跨域的呢"></a>Vue项目中你是如何解决跨域的呢</h3><h4 id="一、跨域是什么"><a href="#一、跨域是什么" class="headerlink" title="一、跨域是什么"></a>一、跨域是什么</h4><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>
<p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>协议相同（protocol）</li>
<li>主机相同（host）</li>
<li>端口相同（port）</li>
</ul>
<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p>
<blockquote>
<p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p>
</blockquote>
<h3 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h3><p><code>Class</code> 可以通过对象语法和数组语法进行动态绑定</p>
<p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&#x27;active&#x27;</span>,<br>  <span class="hljs-attr">errorClass</span>: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Style</code> 也可以通过对象语法和数组语法进行动态绑定</p>
<p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:style=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">activeColor</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-number">30</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:style=<span class="hljs-string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">styleColor</span>: &#123;<br>     <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>   &#125;,<br>  <span class="hljs-attr">styleSize</span>:&#123;<br>     <span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;23px&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="了解history有哪些方法吗？说下它们的区别"><a href="#了解history有哪些方法吗？说下它们的区别" class="headerlink" title="了解history有哪些方法吗？说下它们的区别"></a>了解history有哪些方法吗？说下它们的区别</h3><blockquote>
<p><code>history</code> 这个对象在<code>html5</code>的时候新加入两个<code>api</code> <code>history.pushState()</code> 和 <code>history.repalceState()</code> 这两个<code>API</code>可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。</p>
</blockquote>
<p>从参数上来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pushState</span>(state,title,url)<br><span class="hljs-comment">//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取</span><br><span class="hljs-comment">//title：标题，基本没用，一般传null</span><br><span class="hljs-comment">//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。</span><br><span class="hljs-comment">//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, &#x27;./qq/&#x27;)，则变成 https://www.baidu.com/a/qq/，</span><br><span class="hljs-comment">//执行history.pushState(null, null, &#x27;/qq/&#x27;)，则变成 https://www.baidu.com/qq/</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(state,title,url)<br><span class="hljs-comment">//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录</span><br></code></pre></td></tr></table></figure>

<p>另外还有：</p>
<ul>
<li><code>window.history.back()</code> 后退</li>
<li><code>window.history.forward()</code>前进</li>
<li><code>window.history.go(1)</code> 前进或者后退几步</li>
</ul>
<p>从触发事件的监听上来说：</p>
<ul>
<li><code>pushState()</code>和<code>replaceState()</code>不能被<code>popstate</code>事件所监听</li>
<li>而后面三者可以，且用户点击浏览器前进后退键时也可以</li>
</ul>
<h3 id="在Vue中使用插件的步骤"><a href="#在Vue中使用插件的步骤" class="headerlink" title="在Vue中使用插件的步骤"></a>在Vue中使用插件的步骤</h3><ul>
<li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li>
<li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, &#123; someOption: true &#125;)</code></li>
</ul>
<h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a><code>$route</code>和<code>$router</code>的区别</h3><ul>
<li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li>
<li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>
</ul>
<h3 id="为什么要使用异步组件"><a href="#为什么要使用异步组件" class="headerlink" title="为什么要使用异步组件"></a>为什么要使用异步组件</h3><ol>
<li>节省打包出的结果，异步组件分开打包，采用<code>jsonp</code>的方式进行加载，有效解决文件过大的问题。</li>
<li>核心就是包组件定义变成一个函数，依赖<code>import()</code> 语法，可以实现文件的分割加载。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-attr">components</span>:&#123; <br>  <span class="hljs-title class_">AddCustomerSchedule</span>:<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../components/AddCustomer&quot;</span>) <span class="hljs-comment">// require([]) </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>原理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"> Ctor: Class&lt;Component&gt; | <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span> | <span class="hljs-keyword">void</span>, data: ?VNodeData, context: Component, children: ?<span class="hljs-built_in">Array</span>&lt;VNode&gt;, tag?: string </span>): <span class="hljs-title class_">VNode</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span>&gt; | <span class="hljs-keyword">void</span> &#123; <br>    <span class="hljs-comment">// async component </span><br>    <span class="hljs-keyword">let</span> asyncFactory <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property">cid</span>)) &#123; <br>        asyncFactory = <span class="hljs-title class_">Ctor</span> <br>        <span class="hljs-title class_">Ctor</span> = <span class="hljs-title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor) <span class="hljs-comment">// 默认调用此函数时返回 undefiend </span><br>        <span class="hljs-comment">// 第二次渲染时Ctor不为undefined </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Ctor</span> === <span class="hljs-literal">undefined</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createAsyncPlaceholder</span>( <span class="hljs-comment">// 渲染占位符 空虚拟节点 </span><br>                asyncFactory, <br>                data, <br>                context, <br>                children, <br>                tag <br>            ) <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveAsyncComponent</span> ( <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">baseCtor</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt; ): <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt; | <span class="hljs-keyword">void</span> &#123; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(factory.<span class="hljs-property">resolved</span>)) &#123; <br>        <span class="hljs-comment">// 3.在次渲染时可以拿到获取的最新组件 </span><br>        <span class="hljs-keyword">return</span> factory.<span class="hljs-property">resolved</span> <br>    &#125;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-title function_">once</span>(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123; <br>        factory.<span class="hljs-property">resolved</span> = <span class="hljs-title function_">ensureCtor</span>(res, baseCtor) <br>        <span class="hljs-keyword">if</span> (!sync) &#123; <br>            <span class="hljs-title function_">forceRender</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">//2. 强制更新视图重新渲染 </span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            owners.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <br>        &#125; <br>    &#125;)<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-title function_">once</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(factory.<span class="hljs-property">errorComp</span>)) &#123; <br>            factory.<span class="hljs-property">error</span> = <span class="hljs-literal">true</span> <span class="hljs-title function_">forceRender</span>(<span class="hljs-literal">true</span>) <br>        &#125; <br>    &#125;)<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">factory</span>(resolve, reject)<span class="hljs-comment">// 1.将resolve方法和reject方法传入，用户调用 resolve方法后 </span><br>    sync = <span class="hljs-literal">false</span> <br>    <span class="hljs-keyword">return</span> factory.<span class="hljs-property">resolved</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数式组件优势和原理"><a href="#函数式组件优势和原理" class="headerlink" title="函数式组件优势和原理"></a>函数式组件优势和原理</h3><p><strong>函数组件的特点</strong></p>
<ol>
<li>函数式组件需要在声明组件是指定 <code>functional:true</code></li>
<li>不需要实例化，所以没有<code>this</code>,<code>this</code>通过<code>render</code>函数的第二个参数<code>context</code>来代替</li>
<li>没有生命周期钩子函数，不能使用计算属性，<code>watch</code></li>
<li>不能通过<code>$emit</code> 对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件</li>
<li>因为函数式组件是没有实例化的，所以在外部通过<code>ref</code>去引用组件时，实际引用的是<code>HTMLElement</code></li>
<li>函数式组件的<code>props</code>可以不用显示声明，所以没有在<code>props</code>里面声明的属性都会被自动隐式解析为<code>prop</code>,而普通组件所有未声明的属性都解析到<code>$attrs</code>里面，并自动挂载到组件根元素上面(可以通过<code>inheritAttrs</code>属性禁止)</li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li>
<li>函数式组件结构比较简单，代码结构更清晰</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个简单的展示组件，作为容器组件使用 比如 <code>router-view</code> 就是一个函数式组件</li>
<li>“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</li>
</ul>
<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;functional&#x27;</span>,&#123; <span class="hljs-comment">// 构造函数产生虚拟节点的</span><br>    <span class="hljs-attr">functional</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 函数式组件 // data=&#123;attrs:&#123;&#125;&#125;</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>源码相关</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// functional component</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property">options</span>.<span class="hljs-property">functional</span>)) &#123; <span class="hljs-comment">// 带有functional的属性的就是函数式组件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFunctionalComponent</span>(<span class="hljs-title class_">Ctor</span>, propsData, data, context, children)<br>&#125;<br><br><span class="hljs-comment">// extract listeners, since these needs to be treated as</span><br><span class="hljs-comment">// child component listeners instead of DOM listeners</span><br><span class="hljs-keyword">const</span> listeners = data.<span class="hljs-property">on</span> <span class="hljs-comment">// 处理事件</span><br><span class="hljs-comment">// replace with listeners with .native modifier</span><br><span class="hljs-comment">// so it gets processed during parent component patch.</span><br>data.<span class="hljs-property">on</span> = data.<span class="hljs-property">nativeOn</span> <span class="hljs-comment">// 处理原生事件</span><br><br><span class="hljs-comment">// install component management hooks onto the placeholder node</span><br><span class="hljs-title function_">installComponentHooks</span>(data) <span class="hljs-comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span><br></code></pre></td></tr></table></figure>

<h2 id="Vue-set的实现原理"><a href="#Vue-set的实现原理" class="headerlink" title="Vue.set的实现原理"></a>Vue.set的实现原理</h2><ul>
<li>给对应和数组本身都增加了<code>dep</code>属性</li>
<li>当给对象新增不存在的属性则触发对象依赖的<code>watcher</code>去更新</li>
<li>当修改数组索引时，我们调用数组本身的<code>splice</code>去更新数组（数组的响应式原理就是重新了<code>splice</code>等方法，调用<code>splice</code>就会触发视图更新）</li>
</ul>
<p><strong>基本使用</strong></p>
<blockquote>
<p>以下方法调用会改变原始数组：<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code>, <code>reverse()</code>,<code>Vue.set( target, key, value )</code></p>
</blockquote>
<ul>
<li><p>调用方法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">Vue.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">target</span>, key, value )<br></code></pre></td></tr></table></figure>

<ul>
<li><code>target</code>：要更改的数据源(可以是对象或者数组)</li>
<li><code>key</code>：要更改的具体数据</li>
<li><code>value</code> ：重新赋的值</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>&#123;&#123;user.name&#125;&#125; &#123;&#123;user.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 依赖收集的特点：给每个属性都增加一个dep属性，dep属性会进行收集，收集的是watcher</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 2. vue会给每个对象也增加一个dep属性</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123; <span class="hljs-comment">// vm._data  </span></span><br><span class="language-javascript">            <span class="hljs-attr">user</span>: &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;poetry&#x27;</span>&#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-comment">// 对象的话：调用defineReactive在user对象上定义一个age属性，增加到响应式数据中，触发对象本身的watcher，ob.dep.notify()更新 </span></span><br><span class="language-javascript">    <span class="hljs-comment">// 如果是数组 通过调用 splice方法，触发视图更新</span></span><br><span class="language-javascript">    vm.$set(vm.<span class="hljs-property">user</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 不能给根属性添加，因为给根添加属性 性能消耗太大，需要做很多处理</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 修改肯定是同步的 -&gt; 更新都是一步的  queuewatcher</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>相关源码</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// src/core/observer/index.js 44</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123; <span class="hljs-comment">// new Observer(value)</span><br>  <span class="hljs-attr">value</span>: any;<br>  <span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>;<br>  <span class="hljs-attr">vmCount</span>: number; <span class="hljs-comment">// number of vms that have this object as root $data</span><br><br>  <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">value</span>: any) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>() <span class="hljs-comment">// 给所有对象类型增加dep属性</span><br>  &#125;<br>&#125;<br>javascript复制代码<span class="hljs-comment">// src/core/observer/index.js 201</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span> (<span class="hljs-attr">target</span>: <span class="hljs-title class_">Array</span>&lt;any&gt; | <span class="hljs-title class_">Object</span>, <span class="hljs-attr">key</span>: any, <span class="hljs-attr">val</span>: any): any &#123;<br>  <span class="hljs-comment">// 1.是开发环境 target 没定义或者是基础类型则报错</span><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    (<span class="hljs-title function_">isUndef</span>(target) || <span class="hljs-title function_">isPrimitive</span>(target))<br>  ) &#123;<br>    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Cannot set reactive property on undefined, null, or primitive value: <span class="hljs-subst">$&#123;(target: any)&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 2.如果是数组 Vue.set(array,1,100); 调用我们重写的splice方法 (这样可以更新视图)</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isValidArrayIndex</span>(key)) &#123;<br>    target.<span class="hljs-property">length</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(target.<span class="hljs-property">length</span>, key)<br>    <span class="hljs-comment">// 利用数组的splice变异方法触发响应式  </span><br>    target.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>, val)<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 3.如果是对象本身的属性，则直接添加即可</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> target &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)) &#123;<br>    target[key] = val <span class="hljs-comment">// 直接修改属性值  </span><br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 4.如果是Vue实例 或 根数据data时 报错,（更新_data 无意义）</span><br>  <span class="hljs-keyword">const</span> ob = (<span class="hljs-attr">target</span>: any).<span class="hljs-property">__ob__</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">_isVue</span> || (ob &amp;&amp; ob.<span class="hljs-property">vmCount</span>)) &#123;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +<br>      <span class="hljs-string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span><br>    )<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 5.如果不是响应式的也不需要将其定义成响应式属性</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[key] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 6.将属性定义成响应式的</span><br>  <span class="hljs-title function_">defineReactive</span>(ob.<span class="hljs-property">value</span>, key, val)<br>  <span class="hljs-comment">// 通知视图更新</span><br>  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>我们阅读以上源码可知，vm.$set 的实现原理是：</strong></p>
<ul>
<li><strong>如果目标是数组</strong> ，直接使用数组的 <code>splice</code> 方法触发相应式；</li>
<li><strong>如果目标是对象</strong> ，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 <code>defineReactive</code> 方法进行响应式处理（ <code>defineReactive</code> 方法就是 <code>Vue</code> 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li>
</ul>
<h3 id="Vue为什么没有类似于React中shouldComponentUpdate的生命周期"><a href="#Vue为什么没有类似于React中shouldComponentUpdate的生命周期" class="headerlink" title="Vue为什么没有类似于React中shouldComponentUpdate的生命周期"></a>Vue为什么没有类似于React中shouldComponentUpdate的生命周期</h3><ul>
<li>考点: <code>Vue</code>的变化侦测原理</li>
<li>前置知识: 依赖收集、虚拟<code>DOM</code>、响应式系统</li>
</ul>
<blockquote>
<p>根本原因是<code>Vue</code>与<code>React</code>的变化侦测方式有所不同</p>
</blockquote>
<ul>
<li>当React知道发生变化后，会使用<code>Virtual Dom Diff</code>进行差异检测，但是很多组件实际上是肯定不会发生变化的，这个时候需要 <code>shouldComponentUpdate</code> 进行手动操作来减少<code>diff</code>，从而提高程序整体的性能</li>
<li><code>Vue</code>在一开始就知道那个组件发生了变化，不需要手动控制<code>diff</code>，而组件内部采用的<code>diff</code>方式实际上是可以引入类似于<code>shouldComponentUpdate</code>相关生命周期的，但是通常合理大小的组件不会有过量的diff，手动优化的价值有限，因此目前<code>Vue</code>并没有考虑引入<code>shouldComponentUpdate</code>这种手动优化的生命周期</li>
</ul>
<h3 id="vue-router中如何保护路由"><a href="#vue-router中如何保护路由" class="headerlink" title="vue-router中如何保护路由"></a>vue-router中如何保护路由</h3><p><strong>分析</strong></p>
<p>路由保护在应用开发过程中非常重要，几乎每个应用都要做各种路由权限管理，因此相当考察使用者基本功。</p>
<p><strong>体验</strong></p>
<p>全局守卫：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123; ... &#125;)<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 返回 false 以取消导航</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>路由独享守卫：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span>,<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// reject the navigation</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure>

<p>组件内的守卫：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserDetails</span> = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`...`</span>,<br>  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被验证前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在导航离开渲染该组件的对应路由时调用</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>回答</strong></p>
<ul>
<li><code>vue-router</code>中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。</li>
<li>路由守卫有三个级别：<code>全局</code>、<code>路由独享</code>、<code>组件级</code>。影响范围由大到小，例如全局的<code>router.beforeEach()</code>，可以注册一个全局前置守卫，每次路由导航都会经过这个守卫，因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由；在路由注册的时候可以加入单路由独享的守卫，例如<code>beforeEnter</code>，守卫只在进入路由时触发，因此只会影响这个路由，控制更精确；我们还可以为路由组件添加守卫配置，例如<code>beforeRouteEnter</code>，会在渲染该组件的对应路由被验证前调用，控制的范围更精确了。</li>
<li>用户的任何导航行为都会走<code>navigate</code>方法，内部有个<code>guards</code>队列按顺序执行用户注册的守卫钩子函数，如果没有通过验证逻辑则会取消原有的导航。</li>
</ul>
<p><strong>原理</strong></p>
<p><code>runGuardQueue(guards)</code>链式的执行用户在各级别注册的守卫钩子函数，通过则继续下一个级别的守卫，不通过进入<code>catch</code>流程取消原本导航</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 源码</span><br><span class="hljs-title function_">runGuardQueue</span>(guards)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check global guards beforeEach</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> beforeGuards.<span class="hljs-title function_">list</span>()) &#123;<br>      guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check in components beforeRouteUpdate</span><br>    guards = <span class="hljs-title function_">extractComponentsGuards</span>(<br>      updatingRecords,<br>      <span class="hljs-string">&#x27;beforeRouteUpdate&#x27;</span>,<br>      to,<br>      <span class="hljs-keyword">from</span><br>    )<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record <span class="hljs-keyword">of</span> updatingRecords) &#123;<br>      record.<span class="hljs-property">updateGuards</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">guard</span> =&gt;</span> &#123;<br>        guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>      &#125;)<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check the route beforeEnter</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record <span class="hljs-keyword">of</span> to.<span class="hljs-property">matched</span>) &#123;<br>      <span class="hljs-comment">// do not trigger beforeEnter on reused views</span><br>      <span class="hljs-keyword">if</span> (record.<span class="hljs-property">beforeEnter</span> &amp;&amp; !<span class="hljs-keyword">from</span>.<span class="hljs-property">matched</span>.<span class="hljs-title function_">includes</span>(record)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(record.<span class="hljs-property">beforeEnter</span>)) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> beforeEnter <span class="hljs-keyword">of</span> record.<span class="hljs-property">beforeEnter</span>)<br>            guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(beforeEnter, to, <span class="hljs-keyword">from</span>))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(record.<span class="hljs-property">beforeEnter</span>, to, <span class="hljs-keyword">from</span>))<br>        &#125;<br>      &#125;<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> at this point to.matched is normalized and does not contain any () =&gt; Promise&lt;Component&gt;</span><br><br>    <span class="hljs-comment">// clear existing enterCallbacks, these are added by extractComponentsGuards</span><br>    to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> (record.<span class="hljs-property">enterCallbacks</span> = &#123;&#125;))<br><br>    <span class="hljs-comment">// check in-component beforeRouteEnter</span><br>    guards = <span class="hljs-title function_">extractComponentsGuards</span>(<br>      enteringRecords,<br>      <span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>,<br>      to,<br>      <span class="hljs-keyword">from</span><br>    )<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check global guards beforeResolve</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> beforeResolveGuards.<span class="hljs-title function_">list</span>()) &#123;<br>      guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  <span class="hljs-comment">// catch any navigation canceled</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span><br>    <span class="hljs-title function_">isNavigationFailure</span>(err, <span class="hljs-title class_">ErrorTypes</span>.<span class="hljs-property">NAVIGATION_CANCELLED</span>)<br>      ? err<br>      : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>  )<br></code></pre></td></tr></table></figure>

<p><a href="https://link.juejin.cn/?target=https://github1s.com/vuejs/router/blob/HEAD/packages/router/src/router.ts%23L808-L809">源码位置(opens new window)</a></p>
<h3 id="Vue-router-路由钩子在生命周期的体现"><a href="#Vue-router-路由钩子在生命周期的体现" class="headerlink" title="Vue-router 路由钩子在生命周期的体现"></a>Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p>
<p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p>
<ol>
<li>全局路由钩子</li>
</ol>
<p>vue-router全局有三个路由钩子;</p>
<ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>具体使用∶</p>
<ul>
<li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">let</span> ifInfo = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$common</span>.<span class="hljs-title function_">getSession</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);  <span class="hljs-comment">// 判断是否登录的存储信息</span><br>    <span class="hljs-keyword">if</span> (!ifInfo) &#123; <br>        <span class="hljs-comment">// sessionStorage里没有储存user信息    </span><br>        <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <br>            <span class="hljs-comment">//如果是登录页面路径，就直接next()      </span><br>            <span class="hljs-title function_">next</span>();    <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">//不然就跳转到登录      </span><br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">warning</span>(<span class="hljs-string">&quot;请重新登录！&quot;</span>);     <br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$loginUrl</span>;    <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();  <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>afterEach （跳转之后滚动条回到顶部）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <br>    <span class="hljs-comment">// 跳转之后滚动条回到顶部  </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ol>
<li>单个路由独享钩子</li>
</ol>
<p><strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    <br>    &#123;        <br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,        <br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,        <br>        <span class="hljs-attr">component</span>: login,        <br>        <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;          <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;即将进入登录页面&#x27;</span>)          <br>            <span class="hljs-title function_">next</span>()        <br>        &#125;    <br>    &#125;<br>]<br></code></pre></td></tr></table></figure>

<ol>
<li>组件内钩子</li>
</ol>
<p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p>
<p>这三个钩子都有三个参数∶to、from、next</p>
<ul>
<li>beforeRouteEnter∶ 进入组件前触发</li>
<li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li>
<li>beforeRouteLeave∶ 离开组件被调用</li>
</ul>
<p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;      <br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> &#123;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/classProcess&#x27;</span>) &#123;          <br>            target.<span class="hljs-property">isFromProcess</span> = <span class="hljs-literal">true</span>        <br>        &#125;      <br>    &#125;)    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>二、Vue路由钩子在生命周期函数的体现</p>
<ol>
<li>完整的路由导航解析流程（不包括其他生命周期）</li>
</ol>
<ul>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫beforeRouteLeave</li>
<li>调用局前置守卫∶ beforeEach</li>
<li>在重用的组件里调用 beforeRouteUpdate</li>
<li>调用路由独享守卫 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在将要进入的路由组件中调用 beforeRouteEnter</li>
<li>调用全局解析守卫 beforeResolve</li>
<li>导航被确认。</li>
<li>调用全局后置钩子的 afterEach 钩子。</li>
<li>触发DOM更新（mounted）。</li>
<li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
<ol>
<li>触发钩子的完整顺序</li>
</ol>
<p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p>
<ul>
<li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>beforeEnter：路由独享守卫</li>
<li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li>
<li>beforeResolve：路由全局解析守卫</li>
<li>afterEach：路由全局后置钩子</li>
<li>beforeCreate：组件生命周期，不能访问tAis。</li>
<li>created;组件生命周期，可以访问tAis，不能访问dom。</li>
<li>beforeMount：组件生命周期</li>
<li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>mounted：访问&#x2F;操作dom。</li>
<li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ul>
<ol>
<li>导航行为被触发到导航完成的整个过程</li>
</ol>
<ul>
<li>导航行为被触发，此时导航未被确认。</li>
<li>在失活的组件里调用离开守卫 beforeRouteLeave。</li>
<li>调用全局的 beforeEach守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>在路由配置里调用 beforeEnteY。</li>
<li>解析异步路由组件（如果有）。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li>
<li>导航完成</li>
</ul>
<h3 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h3><ul>
<li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li>
<li>路由独享的守卫：beforeEnter</li>
<li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>
</ul>
<h3 id="Vue的diff算法详细分析"><a href="#Vue的diff算法详细分析" class="headerlink" title="Vue的diff算法详细分析"></a>Vue的diff算法详细分析</h3><p><strong>1. 是什么</strong></p>
<p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>
<p><strong>2. 比较方式</strong></p>
<p><code>diff</code>整体策略为：深度优先，同层比较</p>
<ol>
<li>比较只会在同层级进行, 不会跨层级比较</li>
</ol>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/6db40e34e3ca442d9a5dd0917b0e61c3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<ol>
<li>比较的过程中，循环从两边向中间收拢</li>
</ol>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f2f36643d8b84b97a25fcf49ec42956btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p>
<p>新旧<code>VNode</code>节点如下图所示：</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1787bafd86d24586bc05a2607bd7cd8ftplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/136cfa792cd64daebc60b7586dd2c815tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1336625195f1472ca7360f6f54a82c28tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/d80e4cd2bad14af2801713ddb9e98094tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code>startIndex</code> 移动到了 B</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1c1b78ece7b64c44812d7e0362389928tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的 startIndex 移动到了 F</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/b882b3d85eb24d85b7570faa587373d3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p>
<img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f7987b4d0f7a47d5b46ac3ba59160a79tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" srcset="/img/loading.gif" lazyload class title="img">

<p><strong>3. 原理分析</strong></p>
<p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p>
<p>源码位置：<code>src/core/vdom/patch.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode, hydrating, removeOnly</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode)) &#123; <span class="hljs-comment">// 没有新节点，直接执行destory钩子函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode)) <span class="hljs-title function_">invokeDestroyHook</span>(oldVnode)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> isInitialPatch = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> insertedVnodeQueue = []<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldVnode)) &#123;<br>        isInitialPatch = <span class="hljs-literal">true</span><br>        <span class="hljs-title function_">createElm</span>(vnode, insertedVnodeQueue) <span class="hljs-comment">// 没有旧节点，直接用新节点生成dom元素</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> isRealElement = <span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">nodeType</span>)<br>        <span class="hljs-keyword">if</span> (!isRealElement &amp;&amp; <span class="hljs-title function_">sameVnode</span>(oldVnode, vnode)) &#123;<br>            <span class="hljs-comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span><br>            <span class="hljs-title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, removeOnly)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span><br>            <span class="hljs-keyword">if</span> (isRealElement) &#123;<br><br>                <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span> &amp;&amp; oldVnode.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)) &#123;<br>                    oldVnode.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)<br>                    hydrating = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(hydrating)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;<br>                        <span class="hljs-title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="hljs-literal">true</span>)<br>                        <span class="hljs-keyword">return</span> oldVnode<br>                    &#125;<br>                &#125;<br>                oldVnode = <span class="hljs-title function_">emptyNodeAt</span>(oldVnode)<br>            &#125;<br>            <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">elm</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p>
<ul>
<li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li>
<li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li>
<li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li>
<li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li>
</ul>
<p>下面主要讲的是<code>patchVnode</code>部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;<br>    <span class="hljs-comment">// 如果新旧节点一致，什么都不做</span><br>    <span class="hljs-keyword">if</span> (oldVnode === vnode) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span><br>    <span class="hljs-keyword">const</span> elm = vnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span><br><br>    <span class="hljs-comment">// 异步占位符</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isAsyncPlaceholder</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">resolved</span>)) &#123;<br>        <span class="hljs-title function_">hydrate</span>(oldVnode.<span class="hljs-property">elm</span>, vnode, insertedVnodeQueue)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        vnode.<span class="hljs-property">isAsyncPlaceholder</span> = <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 如果新旧都是静态节点，并且具有相同的key</span><br>    <span class="hljs-comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span><br>    <span class="hljs-comment">// 也不用再有其他操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>      <span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>      vnode.<span class="hljs-property">key</span> === oldVnode.<span class="hljs-property">key</span> &amp;&amp;<br>      (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isCloned</span>) || <span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isOnce</span>))<br>    ) &#123;<br>      vnode.<span class="hljs-property">componentInstance</span> = oldVnode.<span class="hljs-property">componentInstance</span><br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> i<br>    <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">prepatch</span>)) &#123;<br>      <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">const</span> ch = vnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isPatchable</span>(vnode)) &#123;<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">update</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">update</span>[i](oldVnode, vnode)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">update</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br>    <span class="hljs-comment">// 如果vnode不是文本节点或者注释节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>      <span class="hljs-comment">// 并且都有子节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-comment">// 并且子节点不完全一致，则调用updateChildren</span><br>        <span class="hljs-keyword">if</span> (oldCh !== ch) <span class="hljs-title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)<br><br>        <span class="hljs-comment">// 如果只有新的vnode有子节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span><br>        <span class="hljs-title function_">addVnodes</span>(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, insertedVnodeQueue)<br><br>        <span class="hljs-comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 如果老节点是文本节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) &#123;<br>        nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>      &#125;<br><br>      <span class="hljs-comment">// 如果新vnode和老vnode是文本节点或注释节点</span><br>      <span class="hljs-comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== vnode.<span class="hljs-property">text</span>) &#123;<br>      nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, vnode.<span class="hljs-property">text</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">postpatch</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>patchVnode</code>主要做了几个判断：</strong></p>
<ul>
<li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li>
<li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li>
<li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li>
<li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li>
</ul>
<p>子节点不完全一致，则调用<code>updateChildren</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">// 旧头索引</span><br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">// 新头索引</span><br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// 旧尾索引</span><br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// 新尾索引</span><br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>] <span class="hljs-comment">// oldVnode的第一个child</span><br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="hljs-comment">// oldVnode的最后一个child</span><br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>] <span class="hljs-comment">// newVnode的第一个child</span><br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="hljs-comment">// newVnode的最后一个child</span><br>    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm<br><br>    <span class="hljs-comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><br>    <span class="hljs-comment">// to ensure removed elements stay in correct relative positions</span><br>    <span class="hljs-comment">// during leaving transitions</span><br>    <span class="hljs-keyword">const</span> canMove = !removeOnly<br><br>    <span class="hljs-comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-comment">// 如果oldVnode的第一个child不存在</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;<br>        <span class="hljs-comment">// oldStart索引右移</span><br>        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span><br><br>      <span class="hljs-comment">// 如果oldVnode的最后一个child不存在</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;<br>        <span class="hljs-comment">// oldEnd索引左移</span><br>        oldEndVnode = oldCh[--oldEndIdx]<br><br>      <span class="hljs-comment">// oldStartVnode和newStartVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>        <span class="hljs-comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newStartVnode = newCh[++newStartIdx]<br><br>      <span class="hljs-comment">// oldEndVnode和newEndVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>        <span class="hljs-comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newEndVnode = newCh[--newEndIdx]<br><br>      <span class="hljs-comment">// oldStartVnode和newEndVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span><br>        <span class="hljs-comment">// patch oldStartVnode和newEndVnode</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>        <span class="hljs-comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span><br>        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">elm</span>, nodeOps.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>))<br>        <span class="hljs-comment">// oldStart索引右移，newEnd索引左移</span><br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newEndVnode = newCh[--newEndIdx]<br><br>      <span class="hljs-comment">// 如果oldEndVnode和newStartVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>        <span class="hljs-comment">// patch oldEndVnode和newStartVnode</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>        <span class="hljs-comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span><br>        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>        <span class="hljs-comment">// oldEnd索引左移，newStart索引右移</span><br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newStartVnode = newCh[++newStartIdx]<br><br>      <span class="hljs-comment">// 如果都不匹配</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)<br><br>        <span class="hljs-comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span><br>        idxInOld = <span class="hljs-title function_">isDef</span>(newStartVnode.<span class="hljs-property">key</span>)<br>          ? oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]<br>          : <span class="hljs-title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)<br><br>        <span class="hljs-comment">// 如果未找到，说明newStartVnode是一个新的节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123; <span class="hljs-comment">// New element</span><br>          <span class="hljs-comment">// 创建一个新Vnode</span><br>          <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>)<br><br>        <span class="hljs-comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          vnodeToMove = oldCh[idxInOld]<br>          <span class="hljs-comment">/* istanbul ignore if */</span><br>          <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !vnodeToMove) &#123;<br>            <span class="hljs-title function_">warn</span>(<br>              <span class="hljs-string">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +<br>              <span class="hljs-string">&#x27;Make sure each v-for item has a unique key.&#x27;</span><br>            )<br>          &#125;<br><br>          <span class="hljs-comment">// 比较两个具有相同的key的新节点是否是同一个节点</span><br>          <span class="hljs-comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;<br>            <span class="hljs-comment">// patch vnodeToMove和newStartVnode</span><br>            <span class="hljs-title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>            <span class="hljs-comment">// 清除</span><br>            oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>            <span class="hljs-comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span><br>            <span class="hljs-comment">// 移动到oldStartVnode.elm之前</span><br>            canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br><br>          <span class="hljs-comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// same key but different element. treat as new element</span><br>            <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>)<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 右移</span><br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>while</code>循环主要处理了以下五种情景：</strong></p>
<ul>
<li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li>
<li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li>
<li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li>
<li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul>
<li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li>
<li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li>
</ul>
</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p>
</li>
<li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p>
</li>
<li><pre><code class="hljs">patchVnode
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  做了以下操作：<br><br>  - 找到对应的真实`dom`，称为`el`<br>  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点<br>  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点<br>  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`<br>  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点<br><br>- ```<br>  updateChildren<br></code></pre></td></tr></table></figure>

主要做了以下操作：

- 设置新旧`VNode`的头尾指针
- 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作
</code></pre>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Hexo/" class="category-chain-item">Hexo</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Vue/">#Vue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Vue面试题</div>
      <div>https://jlk-lebron.github.io/2022/11/02/掘金-Vue/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>jlk-lebron</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/23/%E6%8E%98%E9%87%91-React/" title="React面试题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">React面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
