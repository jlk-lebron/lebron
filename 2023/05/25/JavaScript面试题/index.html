<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript面试题 | 小王的博客</title><meta name="author" content="jlk-lebron"><meta name="copyright" content="jlk-lebron"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.什么是JavaScript？ JavaScript是一种动态、解释型编程语言，它是Web前端开发的基础之一。JavaScript主要用于Web浏览器中的客户端脚本编写，以增强Web页面的交互性和动态性。此外，它也可以用于服务端开发，开发桌面应用程序、游戏等。JavaScript具有简单易学、灵活多变、功能实用等优点，被广泛应用于Web开发、数据可视化、移动开发等领域。  2.如何声明变量？ 在">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript面试题">
<meta property="og:url" content="http://example.com/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="小王的博客">
<meta property="og:description" content="1.什么是JavaScript？ JavaScript是一种动态、解释型编程语言，它是Web前端开发的基础之一。JavaScript主要用于Web浏览器中的客户端脚本编写，以增强Web页面的交互性和动态性。此外，它也可以用于服务端开发，开发桌面应用程序、游戏等。JavaScript具有简单易学、灵活多变、功能实用等优点，被广泛应用于Web开发、数据可视化、移动开发等领域。  2.如何声明变量？ 在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-25T02:11:45.000Z">
<meta property="article:modified_time" content="2023-05-25T02:12:06.996Z">
<meta property="article:author" content="jlk-lebron">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-25 10:12:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="小王的博客"><span class="site-name">小王的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-25T02:11:45.000Z" title="发表于 2023-05-25 10:11:45">2023-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-25T02:12:06.996Z" title="更新于 2023-05-25 10:12:06">2023-05-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-什么是JavaScript？"><a href="#1-什么是JavaScript？" class="headerlink" title="1.什么是JavaScript？"></a>1.什么是JavaScript？</h3><blockquote>
<p>JavaScript是一种动态、解释型编程语言，它是Web前端开发的基础之一。JavaScript主要用于Web浏览器中的客户端脚本编写，以增强Web页面的交互性和动态性。此外，它也可以用于服务端开发，开发桌面应用程序、游戏等。JavaScript具有简单易学、灵活多变、功能实用等优点，被广泛应用于Web开发、数据可视化、移动开发等领域。</p>
</blockquote>
<h3 id="2-如何声明变量？"><a href="#2-如何声明变量？" class="headerlink" title="2.如何声明变量？"></a>2.如何声明变量？</h3><blockquote>
<p>在JavaScript中，可以使用三个关键字来声明变量，分别是 <code>var</code>、<code>let</code>和<code>const</code>。</p>
<p>使用<code>var</code>关键字声明的变量可以是全局变量或函数作用域中的局部变量。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Tom&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;My name is &quot;</span> + name; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>(); <span class="comment">// 输出&quot;My name is Tom&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>let</code> 和 <code>const</code> 声明的变量则是块级作用域中的局部变量。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>; <span class="comment">// 块级变量</span></span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> message = <span class="string">&quot;You are an adult.&quot;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> message = <span class="string">&quot;You are not an adult yet.&quot;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// 输出&quot;You are an adult.&quot;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>const</code> 声明的变量是常量，一旦赋值就不能再修改其值。而 <code>let</code> 声明的变量可以被重新赋值。</p>
</blockquote>
<h3 id="3-var、let和const关键字有什么区别？"><a href="#3-var、let和const关键字有什么区别？" class="headerlink" title="3.var、let和const关键字有什么区别？"></a>3.var、let和const关键字有什么区别？</h3><blockquote>
<p> <code>var</code>、<code>let</code> 和 <code>const</code> 是 JavaScript 中用来声明变量的关键字，它们有以下几点不同：</p>
<ol>
<li><p>var 声明的变量可以是全局变量或函数作用域中的局部变量, 而 let 和 const 声明的变量则是块级作用域中的局部变量。</p>
</li>
<li><p>var 声明的变量存在变量提升的特性，即可在声明之前使用，而 let 和 const 声明的变量不存在变量提升的特性，必须先声明才能使用。</p>
</li>
<li><p>let 和 const 声明的变量是有作用域的，仅在声明的块级作用域中有效。而 var 声明的变量不存在块级作用域，使用 var 声明的变量在函数作用域内有效，如果没有包含在任何函数中，则在全局作用域内有效。</p>
</li>
<li><p>let 和 const 声明的变量都是有定义则必须初始化，否则会报错，而 var 声明的变量不是必须初始化。</p>
</li>
<li><p><code>const</code> 声明的变量是一个常量，一旦赋值就不能修改，而 <code>let</code> 声明的变量可以被重新赋值。</p>
</li>
</ol>
<p> 综上所述，如果要声明的变量不需要重复赋值，建议使用 <code>const</code>，只有在需要重新赋值时才使用 <code>let</code>，如果需要编写具有较大复杂度的代码时建议避免使用 <code>var</code>。</p>
</blockquote>
<h3 id="4-如何将JavaScript代码嵌入到HTML页面中？"><a href="#4-如何将JavaScript代码嵌入到HTML页面中？" class="headerlink" title="4.如何将JavaScript代码嵌入到HTML页面中？"></a>4.如何将JavaScript代码嵌入到HTML页面中？</h3><blockquote>
<p>可以在 HTML 文件中通过<code>&lt;script&gt;</code>标签来嵌入 JavaScript 代码，格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to my page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 在这里编写 JavaScript 代码</span></span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 代码可以嵌入在 HTML 文档的 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 中。 通常，我们会将 JavaScript 代码单独写在一个 <code>.js</code> 文件中，并通过<code>&lt;script&gt;</code>标签的 <code>src</code> 属性引用它。例如，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to my page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>myScript.js</code> 是一个包含 JavaScript 代码的独立文件，该文件需要与 HTML 文件在同一目录下。使用这种方式，JavaScript 代码可以被多个页面共享，还可以避免 HTML 文件过大，使 HTML 文件与 JavaScript 代码分离出来，提高简洁性和可读性。</p>
</blockquote>
<h3 id="5-如何用JavaScript创建一个新的HTML元素？"><a href="#5-如何用JavaScript创建一个新的HTML元素？" class="headerlink" title="5.如何用JavaScript创建一个新的HTML元素？"></a>5.如何用JavaScript创建一个新的HTML元素？</h3><blockquote>
<p>在 JavaScript 中，可以使用 <code>createElement()</code> 方法创建一个新的 HTML 元素。该方法接受一个参数，表示要创建的元素的标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码会创建一个新的 <code>&lt;div&gt;</code> 元素，并将其保存在 <code>element</code> 变量中。可以使用以下方法来设置创建的元素的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">id</span> = <span class="string">&quot;myDiv&quot;</span>;</span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">element.<span class="property">textContent</span> = <span class="string">&quot;This is my new element!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码会给元素设置 <code>id</code> 和 <code>class</code> 属性，以及设置元素的文本内容。可以将元素插入到文档中的任何位置。例如，可以将新元素插入到 <code>&lt;body&gt;</code> 元素的最后一个子元素之前：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(element, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastElementChild</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码将新元素 <code>element</code> 插入到 <code>&lt;body&gt;</code> 的最后一个子元素之前。最终的 HTML 结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以将元素插入到任何已有元素的内部。例如，可以将新元素插入到具有 <code>id</code> 属性的元素内部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myParentElement&quot;</span>);</span><br><span class="line">parent.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure>

<p>以上代码将新元素 <code>element</code> 插入到元素 <code>myParentElement</code> 的内部。 最终的HTML结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myParentElement&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-如何从HTML元素中获取文本内容？"><a href="#6-如何从HTML元素中获取文本内容？" class="headerlink" title="6.如何从HTML元素中获取文本内容？"></a>6.如何从HTML元素中获取文本内容？</h3><blockquote>
<p>可以使用 JavaScript 中的 <code>textContent</code> 或者 <code>innerHTML</code> 属性从 HTML 元素中获取文本内容。</p>
<p><code>textContent</code> 属性返回元素及其后代元素的文本内容，但会忽略 HTML 标记。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;myElement&quot;</span>&gt;</span>This is some <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用以下 JavaScript 代码获取元素的文本内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> text = element.<span class="property">textContent</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text); <span class="comment">// 输出 &quot;This is some bold text.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要获取包括 HTML 标记在内的元素内容，可以使用 <code>innerHTML</code> 属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> html = element.<span class="property">innerHTML</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html); <span class="comment">// 输出 &quot;This is some &lt;strong&gt;bold&lt;/strong&gt; text.&quot;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>innerHTML</code> 属性也可以用于设置元素内容。如果设置的内容包含 HTML 标记，则会在元素内部插入对应的 DOM 树节点。因此，使用 <code>innerHTML</code> 属性时应确保内容是可信的，以避免安全漏洞。</p>
</blockquote>
<h3 id="7-如何在JavaScript中使用条件语句？"><a href="#7-如何在JavaScript中使用条件语句？" class="headerlink" title="7.如何在JavaScript中使用条件语句？"></a>7.如何在JavaScript中使用条件语句？</h3><blockquote>
<p>JavaScript 中的条件语句包括 <code>if</code> 语句、<code>else</code> 分支语句和 <code>else if</code> 语句。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">// 如果 condition 为 true，执行该代码块</span><br><span class="line">&#125; else if (condition2) &#123;</span><br><span class="line">// 如果 condition 为 false，但是 condition2 为 true，执行该代码块</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 如果 condition 和 condition2 都为 false，执行该代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>if</code> 后面的 <code>condition</code> 指定了一个条件表达式，如果该条件表达式返回 <code>true</code>，则执行 <code>if</code> 后面的代码块；否则，控制流会跳过该代码块，继续执行下一个语句。如果需要对多个不同的条件进行判断，可以使用 <code>else if</code> 语句。如果所有条件都不成立，则可以使用 <code>else</code> 语句执行备选代码块。</p>
<p>例如，以下代码检查给定的数字是否大于 10：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The number is greater than 10&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num === <span class="number">10</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The number is equal to 10&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The number is less than 10&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码会输出以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The number is greater than 10</span><br></pre></td></tr></table></figure>

<p>需要注意的是，条件表达式可以返回任何结果，不一定是 <code>true</code> 或 <code>false</code>。如果条件表达式返回一个“真值”（Truthy）的值，则该代码块将被执行；否则，该代码块将被跳过。条件表达式可以是任何可以强制转换为布尔值的表达式，例如数字、字符串和对象。</p>
</blockquote>
<h3 id="8-如何在JavaScript中使用循环语句？"><a href="#8-如何在JavaScript中使用循环语句？" class="headerlink" title="8.如何在JavaScript中使用循环语句？"></a>8.如何在JavaScript中使用循环语句？</h3><blockquote>
<p>在JavaScript中，有几种类型的循环语句可供使用，包括for、while和do-while循环。</p>
<p>以下是使用这些循环语句的示例：</p>
<ol>
<li>for循环<br>for循环可用于按照指定的次数执行代码块，可以用于遍历数组等数据结构。</li>
</ol>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment/decrement) &#123;</span><br><span class="line">  <span class="comment">// code block to be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: 0, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>while循环<br>while循环可用于在满足指定条件时重复执行代码块。</li>
</ol>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// code block to be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let i = 0;</span><br><span class="line">while (i &lt; 5) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">// Output: 0, 1, 2, 3, 4</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>do-while循环<br>do-while循环与while循环类似，但它先执行一次代码块，然后检查条件是否为真，如果为真则重复执行代码块。</li>
</ol>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// code block to be executed</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br><span class="line"><span class="comment">// Output: 0, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p>这些循环语句可以嵌套在彼此中，以实现更复杂的逻辑。在编写循环时，请确保使用正确的条件和计数器，以避免陷入无限循环。</p>
</blockquote>
<h3 id="9-如何在JavaScript中创建对象？"><a href="#9-如何在JavaScript中创建对象？" class="headerlink" title="9.如何在JavaScript中创建对象？"></a>9.如何在JavaScript中创建对象？</h3><blockquote>
<p>在 JavaScript 中，对象可以通过多种方式创建，包括使用字面量、构造函数、Object.create() 方法等。下面是一些常用的创建对象的方法：</p>
<ol>
<li>使用字面量<br>使用字面量是创建对象的最简单的方法。可以通过花括号包裹键值对来定义一个对象。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; </span><br><span class="line">  key1: value1, </span><br><span class="line">  key2: value2,</span><br><span class="line">  // more key-value pairs </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25,</span><br><span class="line">  address: &#123;</span><br><span class="line">    street: &#x27;123 Main St&#x27;,</span><br><span class="line">    city: &#x27;Anytown&#x27;,</span><br><span class="line">    state: &#x27;CA&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用构造函数<br>使用构造函数可以创建一个对象的多个实例。构造函数是一种特殊类型的函数，通过关键字 <code>new</code> 来创建对象。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  // more properties and methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let person1 = new Person(&#x27;Alice&#x27;, 25);</span><br><span class="line">let person2 = new Person(&#x27;Bob&#x27;, 30);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 Object.create() 方法<br>使用 Object.create() 方法可以创建一个新对象，并将其原型设置为另一个对象或 null。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = Object.create(proto[, propertiesObject]);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let personProto = &#123;</span><br><span class="line">  greet: function() &#123;</span><br><span class="line">    console.log(&#x27;Hello!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let person = Object.create(personProto);</span><br></pre></td></tr></table></figure>

<p>这些方法可以组合使用，例如，可以使用构造函数创建一个对象，然后将其原型设置为另一个对象。创建对象的方式取决于您的需求和代码的结构。</p>
</blockquote>
<h3 id="10-如何访问和修改对象的属性？"><a href="#10-如何访问和修改对象的属性？" class="headerlink" title="10.如何访问和修改对象的属性？"></a>10.如何访问和修改对象的属性？</h3><blockquote>
<p>在 JavaScript 中，可以使用点表示法或方括号表示法来访问和修改对象的属性。以下是访问和修改对象属性的示例：</p>
<ol>
<li>点表示法<br>使用点表示法可以访问和修改对象的属性，其中点后面是属性的名称。</li>
</ol>
<p>访问属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br><span class="line">console.log(person.name); // Output: &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure>

<p>修改属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br><span class="line">person.age = 30;</span><br><span class="line">console.log(person.age); // Output: 30</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方括号表示法<br>使用方括号表示法也可以访问和修改对象的属性，其中方括号内是属性的名称作为字符串。</li>
</ol>
<p>访问属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br><span class="line">console.log(person[&#x27;name&#x27;]); // Output: &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure>

<p>修改属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br><span class="line">person[&#x27;age&#x27;] = 30;</span><br><span class="line">console.log(person[&#x27;age&#x27;]); // Output: 30</span><br></pre></td></tr></table></figure>

<p>方括号表示法可以动态生成属性名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;;</span><br><span class="line">let propName = &#x27;name&#x27;;</span><br><span class="line">console.log(person[propName]); // Output: &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure>

<p>无论使用哪种方法，访问和修改属性都是很简单的。如果属性不存在，访问属性将返回 undefined。如果需要检查属性是否存在，可以使用 hasOwnProperty() 方法。</p>
</blockquote>
<h3 id="11-如何在JavaScript中使用函数？"><a href="#11-如何在JavaScript中使用函数？" class="headerlink" title="11.如何在JavaScript中使用函数？"></a>11.如何在JavaScript中使用函数？</h3><blockquote>
<p>在 JavaScript 中，函数是一种重要的语言构造，可以用于执行特定的任务或操作。以下是使用函数的一些常见方式：</p>
<ol>
<li>定义函数<br>定义函数是使用 function 关键字创建的，可以指定函数名称、参数和函数体。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName(parameter1, parameter2, ...) &#123;</span><br><span class="line">  // function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function greet(name) &#123;</span><br><span class="line">  console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用函数<br>调用函数可以使用函数名和括号运算符。如果函数有参数，则将参数传递给括号中。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(&#x27;Alice&#x27;); // Output: &#x27;Hello, Alice!&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>返回值<br>函数可以返回一个值，可以使用 return 语句来返回值。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">let sum = add(2, 3);</span><br><span class="line">console.log(sum); // Output: 5</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数表达式<br>函数表达式是将函数分配给变量的一种方式。可以在需要时定义并调用函数。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let functionName = function(parameter1, parameter2, ...) &#123;</span><br><span class="line">  // function body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let greet = function(name) &#123;</span><br><span class="line">  console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">greet(&#x27;Bob&#x27;); // Output: &#x27;Hello, Bob!&#x27;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>箭头函数<br>箭头函数是一种简化的函数表达式，它使用箭头符号（&#x3D;&gt;）来定义函数。</li>
</ol>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let functionName = (parameter1, parameter2, ...) =&gt; &#123;</span><br><span class="line">  // function body</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let add = (a, b) =&gt; &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">let sum = add(2, 3);</span><br><span class="line">console.log(sum); // Output: 5</span><br></pre></td></tr></table></figure>

<p>以上是一些基本的 JavaScript 函数使用方法。函数还有其他特性，例如函数作为参数、函数作为对象的方法等，可以根据需求进行学习和使用。</p>
</blockquote>
<h3 id="12-如何传递参数给函数？"><a href="#12-如何传递参数给函数？" class="headerlink" title="12.如何传递参数给函数？"></a>12.如何传递参数给函数？</h3><blockquote>
<p>在 JavaScript 中，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。以下是一些传递参数给函数的常见方式：</p>
<ol>
<li>位置参数<br>位置参数是在调用函数时传递的参数，它们按照在函数定义中声明的顺序进行传递。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">let sum = add(2, 3);</span><br><span class="line">console.log(sum); // Output: 5</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，调用 add() 函数时传递了两个位置参数，它们分别赋给 a 和 b。</p>
<ol start="2">
<li>默认参数<br>默认参数是在函数定义中声明的参数，如果在调用函数时未传递参数，则使用默认值。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function greet(name = &#x27;Guest&#x27;) &#123;</span><br><span class="line">  console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">greet(); // Output: &#x27;Hello, Guest!&#x27;</span><br><span class="line">greet(&#x27;Alice&#x27;); // Output: &#x27;Hello, Alice!&#x27;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了默认参数 name，并在函数体中使用它。如果在调用函数时未传递参数，则使用默认值 Guest。</p>
<ol start="3">
<li>剩余参数<br>剩余参数是在函数定义中声明的参数，它们捕获调用函数时未命名的额外参数，并将它们作为数组传递给函数。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function multiply(multiplier, ...nums) &#123;</span><br><span class="line">  let result = multiplier;</span><br><span class="line">  for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    result *= nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">let product = multiply(2, 3, 4);</span><br><span class="line">console.log(product); // Output: 24</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了 multiplier 和剩余参数 nums，并使用 for 循环将所有数字相乘。</p>
<p>通过以上这些常见方式，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。</p>
</blockquote>
<h3 id="13-如何在函数内部访问全局变量？"><a href="#13-如何在函数内部访问全局变量？" class="headerlink" title="13.如何在函数内部访问全局变量？"></a>13.如何在函数内部访问全局变量？</h3><blockquote>
<p>在 JavaScript 中，全局变量是定义在全局作用域中的变量，可以在程序的任何位置进行访问。可以在函数内部访问全局变量，以下是几种常见的方式：</p>
<ol>
<li>直接访问<br>可以在函数内部直接访问全局变量。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let globalVar = &#x27;Hello&#x27;;</span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(globalVar);</span><br><span class="line">&#125;</span><br><span class="line">sayHello(); // Output: &#x27;Hello&#x27;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 sayHello() 内部直接访问了全局变量 globalVar。</p>
<ol start="2">
<li>使用 window 对象<br>可以通过 window 对象在函数内部访问全局变量。在浏览器中，所有的全局变量都是 window 对象的属性。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let globalVar = &#x27;Hello&#x27;;</span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(window.globalVar);</span><br><span class="line">&#125;</span><br><span class="line">sayHello(); // Output: &#x27;Hello&#x27;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 sayHello() 内部使用 window 对象访问了全局变量 globalVar。</p>
<ol start="3">
<li>使用全局对象<br>在 Node.js 等非浏览器环境中，可以使用全局对象来访问全局变量。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let globalVar = &#x27;Hello&#x27;;</span><br><span class="line">function sayHello() &#123;</span><br><span class="line">  console.log(global.globalVar);</span><br><span class="line">&#125;</span><br><span class="line">sayHello(); // Output: &#x27;Hello&#x27;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 sayHello() 内部使用全局对象 global 访问了全局变量 globalVar。</p>
<p>以上是在函数内部访问全局变量的几种常见方式，可以根据需要选择适合的方法来访问全局变量。需要注意的是，全局变量可能会影响程序的可读性和可维护性，因此应该尽量避免过多使用全局变量。</p>
</blockquote>
<h3 id="14-如何从函数中返回值？"><a href="#14-如何从函数中返回值？" class="headerlink" title="14.如何从函数中返回值？"></a>14.如何从函数中返回值？</h3><blockquote>
<p>在 JavaScript 中，可以使用 return 语句从函数中返回一个值。当函数执行到 return 语句时，它将停止执行并返回指定的值。以下是一些使用 return 语句返回值的示例：</p>
<ol>
<li>返回一个值</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">let sum = add(2, 3);</span><br><span class="line">console.log(sum); // Output: 5</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 add() 使用 return 语句返回 a 和 b 的和。</p>
<ol start="2">
<li>返回一个对象</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createUser(name, age) &#123;</span><br><span class="line">  return &#123; name: name, age: age &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let user = createUser(&#x27;Alice&#x27;, 30);</span><br><span class="line">console.log(user.name); // Output: &#x27;Alice&#x27;</span><br><span class="line">console.log(user.age); // Output: 30</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 createUser() 使用 return 语句返回一个包含名称和年龄属性的对象。</p>
<ol start="3">
<li>返回一个函数</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createMultiplier(multiplier) &#123;</span><br><span class="line">  return function (num) &#123;</span><br><span class="line">    return num * multiplier;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let double = createMultiplier(2);</span><br><span class="line">console.log(double(5)); // Output: 10</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，函数 createMultiplier() 使用 return 语句返回一个函数，该函数使用 multiplier 值来创建一个新的函数，该函数可以将其参数乘以 multiplier。</p>
<p>通过使用 return 语句，可以从函数中返回各种类型的值，包括数字、字符串、对象和函数等。在编写函数时，应该考虑返回什么样的值以及如何处理返回的值。</p>
</blockquote>
<h3 id="15-如何在JavaScript中使用事件处理程序？"><a href="#15-如何在JavaScript中使用事件处理程序？" class="headerlink" title="15.如何在JavaScript中使用事件处理程序？"></a>15.如何在JavaScript中使用事件处理程序？</h3><blockquote>
<p>在 JavaScript 中，可以通过事件处理程序来响应浏览器的用户交互事件，如单击、双击、鼠标移动、键盘按键等。以下是一些常见的使用事件处理程序的方法：</p>
<ol>
<li>使用 HTML 属性<br>可以在 HTML 元素上使用事件处理程序属性来指定事件处理程序。例如，可以使用 onclick 属性来指定单击事件的处理程序。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&#x27;Hello&#x27;)&quot;&gt;Click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，单击按钮时将弹出一个包含 “Hello” 的警告框。</p>
<ol start="2">
<li>使用 DOM 事件处理程序<br>可以使用 DOM 方法来添加事件处理程序。例如，可以使用 addEventListener() 方法来添加事件处理程序。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  alert(&#x27;Hello&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用 querySelector() 方法获取一个按钮元素，并使用 addEventListener() 方法添加一个单击事件处理程序。当按钮被单击时，将弹出一个包含 “Hello” 的警告框。</p>
<ol start="3">
<li>使用对象属性<br>可以将事件处理程序指定为对象的属性。例如，可以创建一个包含单击事件处理程序的对象，并将其分配给按钮元素的 onclick 属性。</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let handler = &#123;</span><br><span class="line">  handleClick: function() &#123;</span><br><span class="line">    alert(&#x27;Hello&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">button.onclick = handler.handleClick;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，创建一个对象 handler，该对象包含一个 handleClick() 方法，该方法在单击事件发生时将弹出一个包含 “Hello” 的警告框。然后将 handleClick() 方法分配给按钮元素的 onclick 属性。</p>
<p>通过使用这些方法之一，可以在 JavaScript 中添加事件处理程序以响应浏览器的用户交互事件。需要注意的是，在编写事件处理程序时，应该确保它们能够正确处理各种情况，以确保程序的正确性和稳定性。</p>
</blockquote>
<h3 id="16-什么是匿名函数？"><a href="#16-什么是匿名函数？" class="headerlink" title="16.什么是匿名函数？"></a>16.什么是匿名函数？</h3><blockquote>
<p>在 JavaScript 中，匿名函数是一种没有指定名称的函数。匿名函数可以用作函数表达式，也可以用作立即调用的函数表达式 (IIFE)。</p>
<ol>
<li>函数表达式中的匿名函数</li>
</ol>
<p>函数表达式是将函数分配给变量或属性的一种方法。如果不需要多次引用该函数，则可以使用匿名函数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let add = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(add(2, 3)); // Output: 5</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，将匿名函数分配给变量 add，并使用它来执行两个数字的相加操作。</p>
<ol start="2">
<li>立即调用的函数表达式 (IIFE) 中的匿名函数</li>
</ol>
<p>IIFE 是一种立即调用的函数表达式，可以在定义后立即调用。匿名函数常常用于 IIFE 中，以便不会在全局作用域中引入不必要的函数名称。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  let message = &#x27;Hello&#x27;;</span><br><span class="line">  console.log(message);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，创建了一个匿名函数，并立即调用它。在匿名函数中，定义了一个名为 message 的变量，然后将字符串 ‘Hello’ 分配给它，并使用 console.log() 方法在控制台中输出消息。</p>
<p>由于匿名函数没有名称，因此不会在全局作用域中创建名称，从而避免了命名冲突和全局作用域污染的风险。</p>
<p>总之，匿名函数是一种灵活且常用的 JavaScript 函数类型，它可以在需要时使用，以避免在全局作用域中引入不必要的名称。</p>
</blockquote>
<h3 id="17-如何在JavaScript中处理异常？"><a href="#17-如何在JavaScript中处理异常？" class="headerlink" title="17.如何在JavaScript中处理异常？"></a>17.如何在JavaScript中处理异常？</h3><blockquote>
<p>在 JavaScript 中，异常处理是一种处理程序运行时出现的错误的机制。异常可以由各种因素引起，例如代码错误、网络问题、I&#x2F;O 错误等。</p>
<p>以下是在 JavaScript 中处理异常的方法：</p>
<ol>
<li>try-catch 语句</li>
</ol>
<p>try-catch 语句是一种处理异常的基本方法。它尝试执行可能会引发异常的代码，如果异常被抛出，则 catch 代码块将捕获异常并执行相应的处理。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 可能会引发异常的代码</span><br><span class="line">  let result = x / y;</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // 处理异常</span><br><span class="line">  console.log(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，try 代码块中的代码会尝试执行除法操作 x &#x2F; y。如果 y 为零，则会引发异常，并将其捕获到 catch 代码块中，然后输出错误消息。</p>
<ol start="2">
<li>throw 语句</li>
</ol>
<p>throw 语句是一种手动引发异常的方法。它允许开发人员在代码中显式地引发异常，以便在后续的 try-catch 语句中捕获并处理。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function divide(x, y) &#123;</span><br><span class="line">  if (y === 0) &#123;</span><br><span class="line">    throw new Error(&#x27;Cannot divide by zero&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  return x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  let result = divide(10, 0);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  console.log(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了一个 divide() 函数，该函数在 y 为零时显式地引发异常。然后，在 try-catch 语句中调用 divide() 函数并捕获异常。</p>
<ol start="3">
<li>finally 语句</li>
</ol>
<p>finally 语句是一种在 try-catch 语句执行后无论是否发生异常都要执行的代码块。它通常用于释放资源或执行清理操作。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 可能会引发异常的代码</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // 处理异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  // 执行清理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，无论 try-catch 语句中是否发生异常，finally 代码块中的代码都会执行。</p>
<p>总之，JavaScript 中的异常处理是一种处理程序运行时错误的机制。try-catch 语句、throw 语句和 finally 语句是处理异常的基本方法，它们可以帮助开发人员更好地管理和处理程序中的错误情况。</p>
</blockquote>
<h3 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18.什么是闭包？"></a>18.什么是闭包？</h3><blockquote>
<p>在 JavaScript 中，闭包（Closure）是指一个函数与其词法环境的组合。具体来说，闭包允许函数访问其定义时所处的词法作用域中的变量和参数，即使在函数被调用后，它仍然可以访问这些变量和参数。</p>
<p>在 JavaScript 中，当一个函数内部定义了另一个函数，并将其返回时，返回的函数就形成了一个闭包。闭包中的函数可以访问包含它的函数的变量和参数，即使包含它的函数已经返回并被销毁。</p>
<p>以下是一个使用闭包的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createCounter() &#123;</span><br><span class="line">let count = 0;</span><br><span class="line">return function() &#123;</span><br><span class="line"> count++;</span><br><span class="line"> console.log(count);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let counter = createCounter();</span><br><span class="line">counter(); // 输出 1</span><br><span class="line">counter(); // 输出 2</span><br><span class="line">counter(); // 输出 3</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，createCounter() 函数返回了一个函数，该函数形成了一个闭包，并可以访问 count 变量。每次调用 counter() 函数时，闭包中的 count 变量都会被递增，并输出当前的计数器值。</p>
<p>闭包在 JavaScript 中具有广泛的应用，例如：</p>
<ul>
<li>实现私有变量和方法</li>
<li>在循环中创建函数和事件处理程序</li>
<li>实现柯里化和偏函数等高级编程技巧</li>
<li>以及其他许多用途</li>
</ul>
<p>但是，由于闭包可能导致内存泄漏和性能问题，所以在使用闭包时应该格外小心，并确保及时释放不需要的变量和资源。</p>
</blockquote>
<h3 id="19-如何在JavaScript中使用原型？"><a href="#19-如何在JavaScript中使用原型？" class="headerlink" title="19.如何在JavaScript中使用原型？"></a>19.如何在JavaScript中使用原型？</h3><blockquote>
<p>在 JavaScript 中，每个对象都有一个原型（prototype）对象，该对象包含对象共享的属性和方法。当我们访问一个对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 就会沿着对象的原型链向上查找，直到找到该属性或方法为止。</p>
<p>在 JavaScript 中，可以使用构造函数（Constructor Function）来创建对象，每个构造函数都有一个原型对象，我们可以向该对象添加属性和方法。所有使用该构造函数创建的对象都会共享这些属性和方法。</p>
<p>以下是一个简单的示例，展示了如何使用原型对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = function() &#123;</span><br><span class="line">console.log(&quot;Hello, my name is &quot; + this.name + &quot; and I&#x27;m &quot; + this.age + &quot; years old.&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let person1 = new Person(&quot;John&quot;, 30);</span><br><span class="line">let person2 = new Person(&quot;Jane&quot;, 25);</span><br><span class="line"></span><br><span class="line">person1.greet(); // 输出 &quot;Hello, my name is John and I&#x27;m 30 years old.&quot;</span><br><span class="line">person2.greet(); // 输出 &quot;Hello, my name is Jane and I&#x27;m 25 years old.&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用构造函数 Person 创建了两个对象 person1 和 person2，并将它们的 name 和 age 属性设置为不同的值。我们还向 Person.prototype 对象添加了一个方法 greet，用于输出对象的信息。由于 person1 和 person2 都是使用 Person 构造函数创建的，它们都可以访问并使用该方法。</p>
<p>通过原型，我们可以使多个对象共享相同的属性和方法，这样可以提高程序的性能和代码的可维护性。但是，在修改原型时需要格外小心，因为这会影响到所有使用该构造函数创建的对象。</p>
</blockquote>
<h3 id="20-什么是原型链？"><a href="#20-什么是原型链？" class="headerlink" title="20.什么是原型链？"></a>20.什么是原型链？</h3><blockquote>
<p>在 JavaScript 中，每个对象都有一个原型对象（prototype），该对象包含该对象的共享属性和方法。每个原型对象又可以拥有自己的原型对象，这样就形成了一个原型链（prototype chain）。</p>
<p>当我们访问一个对象的属性或方法时，JavaScript 会首先查找该对象本身是否具有该属性或方法，如果没有，就会沿着该对象的原型链向上查找，直到找到该属性或方法为止。如果一直查找到最顶层的 Object.prototype 对象仍然没有找到，那么返回 undefined。</p>
<p>以下是一个简单的示例，展示了原型链的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = function() &#123;</span><br><span class="line">console.log(&quot;Hello, my name is &quot; + this.name + &quot; and I&#x27;m &quot; + this.age + &quot; years old.&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Student(name, age, major) &#123;</span><br><span class="line">Person.call(this, name, age);</span><br><span class="line">this.major = major;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.study = function() &#123;</span><br><span class="line">console.log(&quot;I&#x27;m studying &quot; + this.major);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let student = new Student(&quot;John&quot;, 20, &quot;Computer Science&quot;);</span><br><span class="line"></span><br><span class="line">student.greet(); // 输出 &quot;Hello, my name is John and I&#x27;m 20 years old.&quot;</span><br><span class="line">student.study(); // 输出 &quot;I&#x27;m studying Computer Science&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了两个构造函数 Person 和 Student，Student 构造函数继承自 Person 构造函数。通过 Student.prototype &#x3D; Object.create(Person.prototype) 这行代码，我们将 Student 的原型对象设置为 Person 的原型对象，这样 Student 对象就可以共享 Person 的属性和方法。当我们调用 student.greet() 方法时，JavaScript 会首先查找 student 对象本身是否有 greet 方法，没有则沿着其原型链向上查找，最终找到 Person.prototype.greet 方法并输出。同样，当我们调用 student.study() 方法时，JavaScript 也会先查找 student 对象是否具有该方法，没有则查找 Person.prototype，最终找到 Student.prototype.study 方法并输出。</p>
<p>通过原型链，JavaScript 实现了对象之间的继承和属性共享，使代码更加灵活和可维护。</p>
</blockquote>
<h3 id="21-如何在JavaScript中实现继承？"><a href="#21-如何在JavaScript中实现继承？" class="headerlink" title="21.如何在JavaScript中实现继承？"></a>21.如何在JavaScript中实现继承？</h3><blockquote>
<p>在JavaScript中，可以通过以下几种方式来实现继承：</p>
<ol>
<li>原型继承：可以通过将一个对象的原型设置为另一个对象来实现继承。这种方法利用JavaScript中的原型链实现了继承，子类可以访问父类的属性和方法，代码示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Animal() &#123;</span><br><span class="line">  this.type = &#x27;animal&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function() &#123;</span><br><span class="line">  console.log(&#x27;I am an &#x27; + this.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dog() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">var dog = new Dog();</span><br><span class="line">dog.say(); // 输出 &#x27;I am an animal&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造函数继承：可以通过在子类构造函数中调用父类构造函数并使用call或apply方法将this绑定到子类实例上来实现继承。这种方法只能继承父类的属性，而不能继承父类的原型上的方法，代码示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog(type) &#123;</span><br><span class="line">  Animal.call(this, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&#x27;animal&#x27;);</span><br><span class="line">console.log(dog.type); // 输出 &#x27;animal&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>组合继承：可以通过将原型继承和构造函数继承结合起来，既继承了父类的属性，也继承了父类原型上的方法。代码示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function() &#123;</span><br><span class="line">  console.log(&#x27;I am an &#x27; + this.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dog(type) &#123;</span><br><span class="line">  Animal.call(this, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&#x27;animal&#x27;);</span><br><span class="line">dog.say(); // 输出 &#x27;I am an animal&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>寄生组合继承：可以通过使用Object.create方法创建一个中间对象，然后将子类的原型设置为这个中间对象来实现继承。这种方法比组合继承更高效，因为不需要调用父类的构造函数两次。代码示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function() &#123;</span><br><span class="line">  console.log(&#x27;I am an &#x27; + this.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dog(type) &#123;</span><br><span class="line">  Animal.call(this, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = Object.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&#x27;animal&#x27;);</span><br><span class="line">dog.say(); // 输出 &#x27;I am an animal&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="22-如何在JavaScript中使用对象字面量？"><a href="#22-如何在JavaScript中使用对象字面量？" class="headerlink" title="22.如何在JavaScript中使用对象字面量？"></a>22.如何在JavaScript中使用对象字面量？</h3><blockquote>
<p>对象字面量是一种创建和初始化JavaScript对象的方式，它使用一组键值对表示对象的属性和值。下面是使用对象字面量创建和初始化对象的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个具有属性的对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123; </span><br><span class="line"><span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>, </span><br><span class="line"><span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>, </span><br><span class="line"><span class="attr">age</span>: <span class="number">25</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问对象属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>); <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">lastName</span>); <span class="comment">// 输出 &quot;Doe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 输出 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改对象属性</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 输出 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新属性</span></span><br><span class="line">person.<span class="property">city</span> = <span class="string">&quot;New York&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">city</span>); <span class="comment">// 输出 &quot;New York&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先创建了一个空对象 <code>person</code>，然后使用对象字面量创建了一个具有三个属性的对象，即 <code>firstName</code>、<code>lastName</code>和 <code>age</code>。我们可以使用点号 <code>.</code> 或方括号 <code>[]</code> 访问对象的属性，并且可以随时修改或添加新属性。对象字面量是JavaScript中创建和初始化对象的一种简单、快速且方便的方式。</p>
</blockquote>
<h3 id="23-什么是JSON？"><a href="#23-什么是JSON？" class="headerlink" title="23.什么是JSON？"></a>23.什么是JSON？</h3><blockquote>
<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，被广泛用于前后端数据交互和存储。它是一种文本格式，可读性高，易于理解和编写，并且可以被多种编程语言轻松解析和生成。</p>
<p>JSON由键值对组成，其中键必须是字符串类型，值可以是字符串、数字、布尔值、对象、数组或null。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;John Smith&quot;,</span><br><span class="line">&quot;age&quot;: 30,</span><br><span class="line">&quot;isMarried&quot;: false,</span><br><span class="line">&quot;address&quot;: &#123;</span><br><span class="line"> &quot;street&quot;: &quot;123 Main St&quot;,</span><br><span class="line"> &quot;city&quot;: &quot;Anytown&quot;,</span><br><span class="line"> &quot;state&quot;: &quot;CA&quot;,</span><br><span class="line"> &quot;zip&quot;: &quot;12345&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;phoneNumbers&quot;: [&quot;555-1234&quot;, &quot;555-5678&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，键值对表示一个人的信息，其中包括姓名、年龄、婚姻状况、地址和电话号码等。地址和电话号码是对象和数组类型的值。</p>
<p>JSON可以通过JavaScript中的<code>JSON.parse()</code>和<code>JSON.stringify()</code>方法进行解析和序列化。其他编程语言也提供了类似的解析和序列化方法。</p>
</blockquote>
<h3 id="24-如何将JSON转换为JavaScript对象？"><a href="#24-如何将JSON转换为JavaScript对象？" class="headerlink" title="24.如何将JSON转换为JavaScript对象？"></a>24.如何将JSON转换为JavaScript对象？</h3><blockquote>
<p>在JavaScript中，可以使用内置的<code>JSON.parse()</code>方法将JSON字符串转换为JavaScript对象。<code>JSON.parse()</code>方法需要一个JSON字符串作为参数，它会返回一个JavaScript对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const jsonString = &#x27;&#123;&quot;name&quot;: &quot;John Smith&quot;, &quot;age&quot;: 30&#125;&#x27;;</span><br><span class="line">const jsObject = JSON.parse(jsonString);</span><br><span class="line">console.log(jsObject.name); // 输出: John Smith</span><br><span class="line">console.log(jsObject.age); // 输出: 30</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，首先定义了一个JSON字符串，然后使用<code>JSON.parse()</code>方法将其转换为一个JavaScript对象。最后，通过访问对象的属性来获取其值。</p>
<p>需要注意的是，JSON字符串必须符合JSON规范，否则<code>JSON.parse()</code>方法可能会抛出异常。如果JSON字符串不正确，可以使用在线JSON验证工具（如<a target="_blank" rel="noopener" href="https://jsonlint.com/%EF%BC%89%E6%9D%A5%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8D%E5%AE%83%E3%80%82">https://jsonlint.com/）来检查并修复它。</a></p>
</blockquote>
<h3 id="25-如何将JavaScript对象转换为JSON？"><a href="#25-如何将JavaScript对象转换为JSON？" class="headerlink" title="25.如何将JavaScript对象转换为JSON？"></a>25.如何将JavaScript对象转换为JSON？</h3><blockquote>
<p>在JavaScript中，可以使用内置的<code>JSON.stringify()</code>方法将JavaScript对象转换为JSON字符串。<code>JSON.stringify()</code>方法需要一个JavaScript对象作为参数，它会返回一个表示该对象的JSON字符串。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const jsObject = &#123;</span><br><span class="line">name: &#x27;John Smith&#x27;,</span><br><span class="line">age: 30</span><br><span class="line">&#125;;</span><br><span class="line">const jsonString = JSON.stringify(jsObject);</span><br><span class="line">console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;age&quot;:30&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，首先定义了一个JavaScript对象，然后使用<code>JSON.stringify()</code>方法将其转换为一个JSON字符串。最后，通过打印字符串来查看结果。</p>
<p>需要注意的是，<code>JSON.stringify()</code>方法还可以接受一个可选的第二个参数，用于指定要包含在JSON字符串中的属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const jsObject = &#123;</span><br><span class="line">name: &#x27;John Smith&#x27;,</span><br><span class="line">age: 30,</span><br><span class="line">address: &#123;</span><br><span class="line"> street: &#x27;123 Main St&#x27;,</span><br><span class="line"> city: &#x27;Anytown&#x27;,</span><br><span class="line"> state: &#x27;CA&#x27;,</span><br><span class="line"> zip: &#x27;12345&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const jsonString = JSON.stringify(jsObject, [&#x27;name&#x27;, &#x27;address&#x27;]);</span><br><span class="line">console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;address&quot;:&#123;&quot;street&quot;:&quot;123 Main St&quot;,&quot;city&quot;:&quot;Anytown&quot;,&quot;state&quot;:&quot;CA&quot;,&quot;zip&quot;:&quot;12345&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，第二个参数是一个数组，包含要序列化为JSON字符串的属性名。在这个例子中，只有<code>name</code>和<code>address</code>属性被包含在了JSON字符串中，<code>age</code>属性被忽略了。</p>
</blockquote>
<h3 id="26-如何在JavaScript中使用模板字符串？"><a href="#26-如何在JavaScript中使用模板字符串？" class="headerlink" title="26.如何在JavaScript中使用模板字符串？"></a>26.如何在JavaScript中使用模板字符串？</h3><blockquote>
<p>在JavaScript中，可以使用模板字符串（template string）来动态生成字符串。模板字符串是由反引号 &#96;&#96; 包裹的字符串，其中可以包含占位符 <code>$&#123;expression&#125;</code>，expression 是一个 JavaScript 表达式，用于动态地插入值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const name = &#x27;John Smith&#x27;;</span><br><span class="line">const age = 30;</span><br><span class="line">const greeting = `Hello, my name is $&#123;name&#125; and I am $&#123;age&#125; years old.`;</span><br><span class="line">console.log(greeting); // 输出: Hello, my name is John Smith and I am 30 years old.</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个模板字符串 <code>Hello, my name is $&#123;name&#125; and I am $&#123;age&#125; years old.</code>，其中 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code> 是占位符，分别被变量 <code>name</code> 和 <code>age</code> 的值所替换。</p>
<p>模板字符串还支持多行字符串和嵌套占位符。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const message = `</span><br><span class="line">Hello,</span><br><span class="line">my name is $&#123;name&#125;,</span><br><span class="line">and I am $&#123;age&#125; years old.</span><br><span class="line">Here is a list of my hobbies:</span><br><span class="line">  - $&#123;hobbies.join(&#x27;\n- &#x27;)&#125;</span><br><span class="line">`;</span><br><span class="line">console.log(message);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个多行的模板字符串，其中包含嵌套的占位符 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code>，以及使用 <code>Array.join()</code> 方法将数组 <code>hobbies</code> 的每个元素连接成一个以 <code>- </code> 为分隔符的字符串。</p>
<p>需要注意的是，模板字符串在输出时会保留其原始格式，包括空格、缩进和换行符。如果想要去除多余的空格和换行符，可以使用模板标签（tagged template）或者在占位符中使用正则表达式等方式来处理。</p>
</blockquote>
<h3 id="27-什么是箭头函数？"><a href="#27-什么是箭头函数？" class="headerlink" title="27.什么是箭头函数？"></a>27.什么是箭头函数？</h3><blockquote>
<p>箭头函数（Arrow Function）是ES6新增的一种函数定义方式，它可以更简洁地定义一个函数，并且与普通函数有一些不同的语法特性。</p>
<p>箭头函数的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, ...) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>param1</code>、<code>param2</code> 等是函数的参数，<code>statements</code> 是函数体，可以是一条语句或者多条语句的块。如果函数只有一个参数，则可以省略括号；如果函数体只有一条语句，则可以省略大括号和 <code>return</code> 关键字。</p>
<p>例如，以下两个函数的定义是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用普通函数定义</span><br><span class="line">function square(x) &#123;</span><br><span class="line">return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用箭头函数定义</span><br><span class="line">const square = x =&gt; x * x;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个求平方的函数 <code>square</code>，第一个使用了普通函数的定义方式，第二个使用了箭头函数的定义方式。在箭头函数中，可以省略 <code>function</code> 关键字和大括号，从而让函数定义更加简洁。</p>
<p>除了语法上的简洁性，箭头函数还有一些其他的特性。例如，箭头函数的 <code>this</code> 值绑定到定义函数时的作用域，而不是调用函数时的作用域。这个特性可以避免在使用回调函数时出现 <code>this</code> 值丢失的问题。同时，箭头函数也不能使用 <code>arguments</code> 对象来访问参数，但可以通过使用剩余参数（rest parameter）或者默认参数（default parameter）来实现类似的功能。</p>
</blockquote>
<h3 id="28-如何在JavaScript中使用Promise？"><a href="#28-如何在JavaScript中使用Promise？" class="headerlink" title="28.如何在JavaScript中使用Promise？"></a>28.如何在JavaScript中使用Promise？</h3><blockquote>
<p>Promise是JavaScript异步编程的一种解决方案，它可以更好地处理异步操作的结果和错误，并且可以避免回调地狱（callback hell）的问题。在JavaScript中，Promise是一个对象，用于表示异步操作的最终完成或失败，并且可以链式调用多个操作。</p>
<p>使用Promise一般需要以下三个步骤：</p>
<ol>
<li><p>创建一个Promise对象，通常需要传入一个执行器函数（executor function），它会在Promise对象创建时立即执行，用于执行异步操作并决定Promise的状态。在执行器函数中，可以调用resolve方法来表示异步操作成功完成并返回结果，或者调用reject方法来表示异步操作失败并返回错误信息。</p>
</li>
<li><p>调用Promise对象的then方法来注册成功回调和catch方法来注册失败回调。在异步操作完成后，如果操作成功，则会调用成功回调，并且将异步操作的结果作为参数传递给回调函数；如果操作失败，则会调用失败回调，并且将错误信息作为参数传递给回调函数。</p>
</li>
<li><p>可以链式调用多个Promise对象，通过then方法返回一个新的Promise对象，并在其回调函数中执行下一个异步操作。如果在链式调用过程中遇到错误，则可以使用catch方法捕获错误并处理。</p>
</li>
</ol>
<p>例如，下面是一个使用Promise实现异步加载图片的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function loadImage(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const img = new Image();</span><br><span class="line">    img.onload = () =&gt; resolve(img);</span><br><span class="line">    img.onerror = () =&gt; reject(new Error(&#x27;Could not load image&#x27;));</span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadImage(&#x27;https://example.com/image.png&#x27;)</span><br><span class="line">  .then(img =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Image loaded:&#x27;, img);</span><br><span class="line">    // 执行下一个异步操作</span><br><span class="line">    return fetch(&#x27;https://example.com/data.json&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(response =&gt; response.json())</span><br><span class="line">  .then(data =&gt; console.log(&#x27;Data loaded:&#x27;, data))</span><br><span class="line">  .catch(error =&gt; console.error(&#x27;Error:&#x27;, error));</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它返回一个Promise对象，并且在执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后通过链式调用Promise对象的then方法和catch方法，依次执行多个异步操作，并在回调函数中处理结果或错误。</p>
</blockquote>
<h3 id="29-如何在JavaScript中使用异步函数？"><a href="#29-如何在JavaScript中使用异步函数？" class="headerlink" title="29.如何在JavaScript中使用异步函数？"></a>29.如何在JavaScript中使用异步函数？</h3><blockquote>
<p>异步函数（async function）是ES8（或称ES2017）中新增的语法，它是基于Promise的语法糖，可以更方便地编写异步代码。使用异步函数可以让代码更加简洁、易读和易维护，同时避免回调地狱和手动处理Promise对象的then和catch方法。</p>
<p>使用异步函数的步骤如下：</p>
<ol>
<li><p>在函数声明前面加上async关键字，表示这是一个异步函数。异步函数中可以使用await关键字来等待异步操作的结果，await关键字只能在异步函数中使用。</p>
</li>
<li><p>在异步函数中调用异步操作的函数，并使用await关键字等待操作结果。在等待异步操作结果的过程中，JavaScript会暂停当前异步函数的执行，并执行其他的JavaScript代码，直到异步操作完成并返回结果，然后继续执行异步函数。</p>
</li>
<li><p>如果异步操作成功完成，则await关键字返回操作结果；如果异步操作失败，则抛出一个错误，可以使用try-catch语句来捕获错误并处理。</p>
</li>
</ol>
<p>例如，下面是一个使用异步函数实现异步加载图片的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">async function loadImage(url) &#123;</span><br><span class="line">  const img = new Image();</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    img.onload = () =&gt; resolve(img);</span><br><span class="line">    img.onerror = () =&gt; reject(new Error(&#x27;Could not load image&#x27;));</span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const img = await loadImage(&#x27;https://example.com/image.png&#x27;);</span><br><span class="line">    console.log(&#x27;Image loaded:&#x27;, img);</span><br><span class="line">    const response = await fetch(&#x27;https://example.com/data.json&#x27;);</span><br><span class="line">    const data = await response.json();</span><br><span class="line">    console.log(&#x27;Data loaded:&#x27;, data);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个异步函数 <code>loadImage</code>，它返回一个Promise对象，并且在Promise对象的执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后定义了另一个异步函数 <code>main</code>，它通过使用await关键字等待异步操作的结果来处理异步加载图片和数据的过程。最后调用main函数来启动异步过程，并使用try-catch语句来捕获错误并处理。</p>
</blockquote>
<h3 id="30-如何在JavaScript中使用回调函数？"><a href="#30-如何在JavaScript中使用回调函数？" class="headerlink" title="30.如何在JavaScript中使用回调函数？"></a>30.如何在JavaScript中使用回调函数？</h3><blockquote>
<p>回调函数是一种在JavaScript中广泛使用的技术，它可以让异步代码更容易编写和维护。在JavaScript中，函数可以作为变量传递，因此可以将函数作为参数传递给其他函数，这种被传递的函数就是回调函数。</p>
<p>使用回调函数的步骤如下：</p>
<ol>
<li><p>定义一个异步操作函数，并在该函数中定义一个回调函数参数。异步操作函数可以是自己定义的函数，也可以是JavaScript内置的异步函数，如setTimeout、setInterval、XMLHttpRequest等。</p>
</li>
<li><p>在异步操作完成后，调用回调函数并将结果作为参数传递给它。在回调函数中，可以处理异步操作的结果，例如更新页面内容、显示错误信息等。</p>
</li>
</ol>
<p>例如，下面是一个使用回调函数实现异步加载图片的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function loadImage(url, callback) &#123;</span><br><span class="line">  const img = new Image();</span><br><span class="line">  img.onload = () =&gt; callback(null, img);</span><br><span class="line">  img.onerror = () =&gt; callback(new Error(&#x27;Could not load image&#x27;));</span><br><span class="line">  img.src = url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadImage(&#x27;https://example.com/image.png&#x27;, (error, img) =&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;Image loaded:&#x27;, img);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它接受一个图片URL和一个回调函数作为参数。在函数中，创建一个Image对象，并在Image对象的onload和onerror事件中分别调用回调函数并传递操作结果。然后调用 <code>loadImage</code> 函数来启动异步加载图片的过程，并在回调函数中处理加载结果。</p>
<p>需要注意的是，在使用回调函数时，要避免回调地狱（callback hell）的问题。如果嵌套过多的回调函数，会使代码难以阅读和维护。可以使用Promise、async&#x2F;await等其他技术来解决这个问题。</p>
</blockquote>
<h3 id="31-什么是事件委托？"><a href="#31-什么是事件委托？" class="headerlink" title="31.什么是事件委托？"></a>31.什么是事件委托？</h3><blockquote>
<p>事件委托（Event delegation）是一种优化JavaScript事件处理的技术。它利用事件冒泡的机制，在祖先元素上注册事件，然后通过事件的target属性来判断是哪个后代元素触发了事件。</p>
<p>使用事件委托的优点包括：</p>
<ol>
<li><p>减少事件处理程序的数量：通过将事件处理程序注册到祖先元素上，可以减少页面上的事件处理程序数量，从而提高性能和代码可维护性。</p>
</li>
<li><p>动态添加元素：在使用事件委托的情况下，如果动态添加了元素，它们会自动继承祖先元素上的事件处理程序，而不需要手动注册事件。</p>
</li>
</ol>
<p>下面是一个使用事件委托处理按钮点击事件的例子：</p>
<p>HTML代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;&lt;button&gt;Button 1&lt;/button&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;button&gt;Button 2&lt;/button&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;button&gt;Button 3&lt;/button&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const list = document.getElementById(&#x27;list&#x27;);</span><br><span class="line"></span><br><span class="line">list.addEventListener(&#x27;click&#x27;, event =&gt; &#123;</span><br><span class="line">  if (event.target.tagName === &#x27;BUTTON&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;Button clicked:&#x27;, event.target.innerText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，通过将click事件注册到祖先元素list上，可以处理按钮点击事件。在事件处理程序中，使用event.target属性来判断是哪个后代元素触发了事件，并处理点击事件。需要注意的是，只有当点击的元素是button元素时，才会触发事件处理程序。</p>
</blockquote>
<h3 id="32-什么是模块化？"><a href="#32-什么是模块化？" class="headerlink" title="32.什么是模块化？"></a>32.什么是模块化？</h3><blockquote>
<p>模块化是一种组织和管理JavaScript代码的方式，它将代码分解为独立的模块，每个模块都有自己的作用域，可以独立开发、测试、维护和重用。</p>
<p>在传统的JavaScript中，所有的代码都是在全局作用域下执行的，容易造成命名冲突、代码耦合度高等问题。而模块化则通过封装变量和函数，将代码组织成可复用的、低耦合的、可维护的模块。</p>
<p>常见的模块化规范有CommonJS、AMD和ES6模块化。</p>
<p>CommonJS是一种用于服务器端JavaScript的模块化规范，它使用require()函数来导入模块，使用module.exports对象来导出模块。</p>
<p>AMD（Asynchronous Module Definition）是一种用于浏览器端JavaScript的模块化规范，它使用define()函数来定义模块，使用require()函数来导入模块。</p>
<p>ES6模块化是JavaScript的官方模块化规范，它使用import语句来导入模块，使用export语句来导出模块。ES6模块化具有内置的异步加载和懒加载机制，可以在浏览器端和服务器端使用。</p>
<p>下面是一个使用ES6模块化导入和导出模块的例子：</p>
<p>模块A代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// moduleA.js</span><br><span class="line">export const greeting = &#x27;Hello&#x27;;</span><br><span class="line"></span><br><span class="line">export function sayHello(name) &#123;</span><br><span class="line">console.log(`$&#123;greeting&#125;, $&#123;name&#125;!`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块B代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// moduleB.js</span><br><span class="line">import &#123; greeting, sayHello &#125; from &#x27;./moduleA.js&#x27;;</span><br><span class="line"></span><br><span class="line">sayHello(&#x27;Alice&#x27;); // 输出: Hello, Alice!</span><br><span class="line">console.log(greeting); // 输出: Hello</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，模块A导出了两个变量：greeting和sayHello，模块B使用import语句来导入这两个变量，并使用它们输出信息。需要注意的是，模块A需要使用export语句来将变量导出，而模块B使用import语句来导入变量。</p>
</blockquote>
<h3 id="33-如何在JavaScript中使用模块化？"><a href="#33-如何在JavaScript中使用模块化？" class="headerlink" title="33.如何在JavaScript中使用模块化？"></a>33.如何在JavaScript中使用模块化？</h3><blockquote>
<p>在JavaScript中使用模块化，可以帮助我们更好地组织代码，并且可以避免全局作用域的污染。下面是几种常见的使用模块化的方法：</p>
<ol>
<li>CommonJS：<br>CommonJS是一种用于服务器端JavaScript的模块化系统，它使用require()和module.exports来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = add;</span><br></pre></td></tr></table></figure>

<p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">&#x27;./module.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ES6模块：<br>ES6模块是一种新的JavaScript模块化系统，它使用import和export语句来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在另一个文件中，我们可以使用import语句来导入模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>AMD：<br>AMD（Asynchronous Module Definition）是一种在浏览器端使用的模块化系统，它使用define()和require()函数来定义和导入模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">add</span>: add</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;./module.js&#x27;</span>], <span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出：5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上是几种常见的模块化方法，每种方法都有其自己的优缺点，可以根据具体的应用场景选择合适的方法。</p>
</blockquote>
<h3 id="34-什么是IIFE？"><a href="#34-什么是IIFE？" class="headerlink" title="34.什么是IIFE？"></a>34.什么是IIFE？</h3><blockquote>
<p>IIFE代表立即调用的函数表达式（Immediately Invoked Function Expression），它是一种用于在JavaScript中创建局部作用域的常见模式。IIFE是一种匿名函数表达式，可以在定义后立即调用它。</p>
<p>IIFE通常使用以下模式来定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 在这里定义变量和函数</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于函数被定义在一个函数作用域内，因此其中定义的变量和函数只在函数内部可见，不会影响全局作用域。这样可以有效地避免变量名和函数名冲突的问题。</p>
<p>IIFE的另一个常见的用途是将一段代码作为一个整体，并且可以在其中定义私有变量和函数。这样可以防止其他代码修改这些变量和函数，保护代码的安全性和稳定性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">add</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：30</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了一个IIFE来创建一个私有的作用域，并在其中定义了变量x和y，以及函数add。然后，我们通过return语句将add函数的返回值返回出来，并将其赋值给变量result。由于x、y和add都是在IIFE的作用域中定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p>
</blockquote>
<h3 id="35-如何在JavaScript中使用IIFE？"><a href="#35-如何在JavaScript中使用IIFE？" class="headerlink" title="35.如何在JavaScript中使用IIFE？"></a>35.如何在JavaScript中使用IIFE？</h3><blockquote>
<p>在JavaScript中使用IIFE非常简单，只需要按照以下模式编写代码即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 在这里编写代码</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于这个匿名函数是立即调用的，因此我们也称之为“立即调用的函数表达式”（IIFE）。</p>
<p>下面是一个使用IIFE的简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = x + y;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个IIFE，其中包含了一些变量和逻辑。由于IIFE是立即调用的，因此其中的代码会在JavaScript引擎执行到这个函数时立即执行。在这个例子中，我们在IIFE中定义了变量x和y，并将它们相加赋值给变量result，然后将result打印到控制台上。由于变量x、y和result都是在IIFE的作用域内定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p>
</blockquote>
<h3 id="36-如何设置、获取和删除cookie？"><a href="#36-如何设置、获取和删除cookie？" class="headerlink" title="36.如何设置、获取和删除cookie？"></a>36.如何设置、获取和删除cookie？</h3><blockquote>
<p>在JavaScript中，可以使用document对象的cookie属性来设置、获取和删除cookie。cookie是一种用于在客户端保存数据的机制，它允许Web应用程序在不同的请求之间共享数据。</p>
<p>以下是如何设置cookie的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=value; expires=Thu, 01 Jan 2026 00:00:00 UTC; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用document.cookie属性将一个名为name，值为value的cookie写入客户端。expires选项指定了cookie的过期时间，path选项指定了cookie的路径。</p>
<p>以下是如何获取cookie的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookieValue = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">replace</span>(<span class="regexp">/(?:(?:^|.*;\s*)name\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="string">&quot;$1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用document.cookie属性获取所有的cookie，然后使用正则表达式来提取名为name的cookie的值。这里使用了一个正则表达式来匹配和提取cookie值。</p>
<p>以下是如何删除cookie的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将名为name的cookie的值设置为空字符串，并将过期时间设置为一个过去的时间，以便将其删除。path选项也需要与之前设置cookie时的path选项相同，否则可能会出现删除不完全的情况。</p>
<p>需要注意的是，由于cookie是保存在客户端上的，因此它们可能会被篡改或删除。因此，在处理敏感数据时，应该谨慎使用cookie，并使用其他更安全的机制来保存数据。</p>
</blockquote>
<h3 id="37-如何使用localStorage和sessionStorage？"><a href="#37-如何使用localStorage和sessionStorage？" class="headerlink" title="37.如何使用localStorage和sessionStorage？"></a>37.如何使用localStorage和sessionStorage？</h3><blockquote>
<p>localStorage和sessionStorage都是HTML5中提供的Web存储机制，它们可以用来在客户端上保存数据，并且比cookie更方便、更安全。</p>
<p>localStorage和sessionStorage的主要区别在于它们的生命周期和作用域：</p>
<ul>
<li>localStorage中保存的数据没有过期时间，除非被清除，否则一直存在于客户端上。</li>
<li>sessionStorage中保存的数据只在当前会话期间有效，当用户关闭浏览器窗口或标签页时会被清除。</li>
</ul>
<p>以下是如何使用localStorage和sessionStorage的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据保存到localStorage中</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从localStorage中获取数据</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> age = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从localStorage中删除数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据保存到sessionStorage中</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>);</span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从sessionStorage中获取数据</span></span><br><span class="line"><span class="keyword">var</span> city = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;city&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> country = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;country&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从sessionStorage中删除数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;city&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先使用setItem()方法将数据保存到localStorage和sessionStorage中，然后使用getItem()方法从中获取数据，使用removeItem()方法从中删除数据。</p>
<p>需要注意的是，localStorage和sessionStorage中只能保存字符串类型的数据。如果需要保存其他类型的数据，可以先将其序列化为字符串，然后再保存。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象序列化为字符串</span></span><br><span class="line"><span class="keyword">var</span> personStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串保存到localStorage中</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;person&#x27;</span>, personStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从localStorage中获取字符串并反序列化为对象</span></span><br><span class="line"><span class="keyword">var</span> personObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;person&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将一个JavaScript对象序列化为一个字符串，然后将这个字符串保存到localStorage中。当需要获取这个对象时，我们先从localStorage中获取这个字符串，然后使用JSON.parse()方法将其反序列化为一个对象。</p>
</blockquote>
<h3 id="38-如何使用XMLHttpRequest发送GET请求？"><a href="#38-如何使用XMLHttpRequest发送GET请求？" class="headerlink" title="38.如何使用XMLHttpRequest发送GET请求？"></a>38.如何使用XMLHttpRequest发送GET请求？</h3><blockquote>
<p>XMLHttpRequest对象是在JavaScript中发送HTTP请求的常用方式之一。使用XMLHttpRequest对象，我们可以向服务器发送GET、POST、PUT等类型的请求，并获取服务器返回的数据。</p>
<p>以下是使用XMLHttpRequest对象发送GET请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求的URL</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://example.com/api/data&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 如果请求成功</span></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="keyword">var</span> responseData = xhr.<span class="property">responseText</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(responseData);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 请求失败，处理错误</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: &#x27;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先创建了一个XMLHttpRequest对象，然后使用open()方法设置请求的URL和HTTP方法。第三个参数指示是否使用异步方式发送请求。然后我们监听XMLHttpRequest对象的onload事件，在请求完成时触发该事件，并在事件处理程序中处理服务器返回的数据。如果请求失败，我们会在事件处理程序中处理错误。</p>
<p>需要注意的是，XMLHttpRequest对象只能用于同源的请求。如果需要向不同源的服务器发送请求，可以使用JSONP或CORS等技术来解决跨域问题。</p>
</blockquote>
<h3 id="39-如何使用XMLHttpRequest发送POST请求？"><a href="#39-如何使用XMLHttpRequest发送POST请求？" class="headerlink" title="39.如何使用XMLHttpRequest发送POST请求？"></a>39.如何使用XMLHttpRequest发送POST请求？</h3><blockquote>
<p>使用XMLHttpRequest对象发送POST请求与发送GET请求的过程类似，但是我们需要设置请求的Content-Type头部，并将请求体作为send()方法的参数。</p>
<p>以下是使用XMLHttpRequest对象发送POST请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求的URL和HTTP方法</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;https://example.com/api/data&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Content-Type头部</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 如果请求成功</span></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="keyword">var</span> responseData = xhr.<span class="property">responseText</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(responseData);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 请求失败，处理错误</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: &#x27;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求体并发送请求</span></span><br><span class="line"><span class="keyword">var</span> requestData = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(requestData));</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们设置了POST请求的Content-Type头部为application&#x2F;json，并将请求体序列化为一个JSON字符串，并作为send()方法的参数。在监听XMLHttpRequest对象的onload事件时，我们将服务器返回的数据作为响应的主体，可以使用responseText属性获取。</p>
<p>需要注意的是，如果发送的请求体是FormData对象，我们不需要手动设置Content-Type头部，因为XMLHttpRequest对象会自动设置为multipart&#x2F;form-data。</p>
</blockquote>
<h3 id="40-如何使用fetch发送请求？"><a href="#40-如何使用fetch发送请求？" class="headerlink" title="40.如何使用fetch发送请求？"></a>40.如何使用fetch发送请求？</h3><blockquote>
<p>Fetch API是现代浏览器中用于发送HTTP请求的一种标准方式。它使用Promise对象处理异步请求，提供了比传统XMLHttpRequest更简单的API。</p>
<p>以下是使用fetch发送GET请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送GET请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用fetch()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在第一个then()方法中，我们将响应体解析为一个JSON对象。在第二个then()方法中，我们可以对解析后的数据进行处理。如果出现错误，我们可以在catch()方法中处理错误。</p>
<p>以下是使用fetch发送POST请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送POST请求</span></span><br><span class="line"><span class="keyword">var</span> requestData = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(requestData)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们在fetch()方法的第二个参数中指定了HTTP方法、头部和请求体。与XMLHttpRequest对象类似，我们需要设置Content-Type头部，并将请求体序列化为一个JSON字符串。</p>
<p>需要注意的是，fetch()方法默认不会发送cookie和身份验证信息。如果需要发送cookie或身份验证信息，需要在fetch()方法的第二个参数中设置credentials属性为’include’。</p>
</blockquote>
<h3 id="41-如何使用axios发送请求？"><a href="#41-如何使用axios发送请求？" class="headerlink" title="41.如何使用axios发送请求？"></a>41.如何使用axios发送请求？</h3><blockquote>
<p>Axios是一种流行的JavaScript库，用于在浏览器和Node.js中发送HTTP请求。它提供了一种简单的API，用于发送GET、POST、PUT、DELETE等类型的请求，并提供了一些可配置的选项，如请求头、超时、取消请求等。</p>
<p>以下是使用Axios发送GET请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送GET请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用axios.get()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p>
<p>以下是使用Axios发送POST请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送POST请求</span></span><br><span class="line"><span class="keyword">var</span> requestData = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>, requestData, &#123;</span><br><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用axios.post()方法发送了一个POST请求，并将请求体作为第二个参数传递。我们还通过第三个参数指定了请求头。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p>
<p>需要注意的是，Axios默认情况下会将响应的主体解析为JSON格式，但是如果响应的Content-Type头部不是application&#x2F;json，Axios将不会自动解析JSON数据。如果需要解析其他格式的数据，需要使用其他解析库或手动解析数据。</p>
</blockquote>
<h3 id="42-什么是跨域？"><a href="#42-什么是跨域？" class="headerlink" title="42.什么是跨域？"></a>42.什么是跨域？</h3><blockquote>
<p>跨域（Cross-Origin）是指在浏览器中，一个网页的脚本试图访问不同源（协议、域名或端口）的资源时，就会发生跨域问题。这是由浏览器的同源策略（Same-Origin Policy）导致的，同源策略是一种安全机制，用于防止恶意网站窃取用户数据。</p>
<p>同源策略要求一个网页的脚本只能与同一源（协议、域名和端口）的资源进行交互。如果脚本试图与不同源的资源进行交互，浏览器就会拒绝请求。例如，一个网页的脚本在example.com域名下运行，试图向api.example.net域名下的API发送请求，这就是跨域请求，浏览器将不会允许这个请求。</p>
<p>需要注意的是，跨域问题只存在于浏览器环境中，如果是在服务器端发送请求，则不存在跨域问题。因为服务器端不存在同源策略的限制，可以访问任何资源。</p>
</blockquote>
<h3 id="43-如何解决跨域问题？"><a href="#43-如何解决跨域问题？" class="headerlink" title="43.如何解决跨域问题？"></a>43.如何解决跨域问题？</h3><blockquote>
<p>以下是一些解决跨域问题的常用方法：</p>
<ol>
<li><p>CORS（Cross-Origin Resource Sharing）：使用CORS，服务器可以发送一个响应头，允许浏览器从不同的源请求资源。CORS需要在服务器端进行配置，通常是在响应头中添加Access-Control-Allow-Origin、Access-Control-Allow-Methods等相关的头信息。</p>
</li>
<li><p>JSONP（JSON with Padding）：JSONP是一种使用script元素发送GET请求的技术，由于脚本元素不受同源策略的限制，可以加载任何域名下的JavaScript脚本。使用JSONP，可以将回调函数名作为参数传递给服务器，服务器在返回数据时将数据作为参数传递给回调函数。</p>
</li>
<li><p>代理服务器：可以设置一个代理服务器，将客户端请求发送到代理服务器，由代理服务器转发请求到目标服务器，再将目标服务器返回的数据转发给客户端。由于代理服务器是在同一域名下运行的，因此不存在跨域问题。</p>
</li>
<li><p>WebSocket：WebSocket是一种全双工通信协议，它可以在不同源之间建立持久连接，可以用于客户端与服务器之间的实时通信，避免了跨域问题。</p>
</li>
<li><p>postMessage API：postMessage API可以在不同源之间进行通信，通过在不同窗口之间传递消息，可以实现跨域通信。这种方法需要目标窗口同意，才能进行通信。</p>
</li>
</ol>
<p>需要根据实际情况选择合适的解决方案，其中CORS和代理服务器是最常用的解决方案。</p>
</blockquote>
<h3 id="44-什么是事件循环？"><a href="#44-什么是事件循环？" class="headerlink" title="44.什么是事件循环？"></a>44.什么是事件循环？</h3><blockquote>
<p>事件循环（Event Loop）是JavaScript的一种机制，用于处理异步事件。JavaScript是单线程的，所有任务都在一个线程中执行，包括用户界面操作、计时器事件和网络请求等操作。如果所有任务都是同步的，那么它们将按照代码的书写顺序执行。但是，当涉及到异步任务时，任务的执行顺序就不是确定的，这时就需要事件循环机制来协调任务的执行。</p>
<p>事件循环通过维护一个事件队列（Event Queue）来管理任务的执行顺序。当任务执行时，如果任务是同步的，则会立即执行并将结果返回，如果任务是异步的，则会将任务加入事件队列中，并继续执行下一个任务。当任务队列为空时，事件循环会等待新的任务加入队列，直到有新的任务加入。</p>
<p>事件循环机制中的事件队列包括宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）两种。宏任务队列包括定时器事件、I&#x2F;O事件和事件回调等异步任务，而微任务队列则包括Promise和process.nextTick等异步任务。事件循环会先执行微任务队列中的所有任务，然后再执行宏任务队列中的任务。</p>
<p>事件循环的机制非常重要，因为它决定了异步任务的执行顺序和优先级，理解事件循环机制对于开发高效的JavaScript应用程序非常重要。</p>
</blockquote>
<h3 id="45-什么是同步代码？"><a href="#45-什么是同步代码？" class="headerlink" title="45.什么是同步代码？"></a>45.什么是同步代码？</h3><blockquote>
<p>同步代码是指按照代码的书写顺序依次执行的代码，每个任务必须等待前一个任务完成才能执行。在JavaScript中，通常情况下代码都是同步执行的，例如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;A&#x27;);</span><br><span class="line">console.log(&#x27;B&#x27;);</span><br><span class="line">console.log(&#x27;C&#x27;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，console.log()函数会按照代码的书写顺序依次执行，并输出A、B和C。</p>
<p>同步代码执行时会阻塞程序的执行，直到当前任务完成，才会执行下一个任务。这意味着如果某个任务执行时间很长，那么整个程序的执行将会被阻塞，用户界面也会变得不响应。</p>
<p>为了避免长时间的阻塞，可以使用异步代码，将一些耗时的任务放入事件队列中，等待异步处理。当异步任务完成后，事件循环会将其加入执行队列中，优先级高的任务先执行，从而保证程序的响应性和效率。</p>
</blockquote>
<h3 id="46-什么是异步代码？"><a href="#46-什么是异步代码？" class="headerlink" title="46.什么是异步代码？"></a>46.什么是异步代码？</h3><blockquote>
<p>异步代码是指不按照代码书写顺序执行的代码，它们的执行顺序是由事件循环机制控制的。异步代码在执行时不会阻塞程序的执行，因此可以提高程序的效率和响应性。</p>
<p>在JavaScript中，异步代码通常使用回调函数、Promise、async&#x2F;await等方式来实现。例如，以下代码展示了一个使用回调函数的异步代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;A&#x27;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">console.log(&#x27;B&#x27;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(&#x27;C&#x27;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，setTimeout函数用于延迟执行，当计时器到期时，事件循环会将回调函数加入执行队列中，从而实现异步执行。由于回调函数是异步执行的，因此会在后台执行，不会阻塞程序的执行。</p>
<p>异步代码的特点是代码执行不会阻塞程序的执行，可以提高程序的效率和响应性。但是，异步代码的执行顺序是不确定的，需要使用事件循环机制来协调任务的执行。因此，在编写异步代码时需要注意回调函数的使用，避免回调地狱等问题。</p>
</blockquote>
<h3 id="47-如何在JavaScript中处理异步代码？"><a href="#47-如何在JavaScript中处理异步代码？" class="headerlink" title="47.如何在JavaScript中处理异步代码？"></a>47.如何在JavaScript中处理异步代码？</h3><blockquote>
<p>在JavaScript中，处理异步代码通常使用以下三种方式：</p>
<ol>
<li>回调函数：回调函数是一种异步编程的基础方式，它是一个作为参数传递给另一个函数的函数，用于在异步任务完成后执行。回调函数的实现通常使用匿名函数或命名函数，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunction(callback) &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    callback(&#x27;done&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunction(function(result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，asyncFunction函数是一个异步函数，它接受一个回调函数作为参数，在异步操作完成后执行回调函数。当异步操作完成后，回调函数会被调用，并传递结果参数result。</p>
<ol start="2">
<li>Promise：Promise是一种更加现代化的异步处理方式，它用于处理复杂的异步操作，可以使用链式调用的方式处理多个异步操作。Promise的使用通常分为三个状态：pending、fulfilled和rejected，分别表示异步操作正在进行、异步操作已成功完成和异步操作已失败。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunction() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 异步操作</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(&#x27;done&#x27;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunction().then(function(result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，asyncFunction函数返回一个Promise对象，异步操作完成后使用resolve方法将结果传递给then方法的回调函数。</p>
<ol start="3">
<li>async&#x2F;await：async&#x2F;await是一种更加简洁和直观的异步处理方式，它基于Promise实现，可以使用同步的方式编写异步代码。async函数用于定义异步函数，await用于暂停代码的执行，等待Promise对象的状态改变。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFunction() &#123;</span><br><span class="line">  // 异步操作</span><br><span class="line">  const result = await new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(&#x27;done&#x27;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunction();</span><br></pre></td></tr></table></figure>

<p>在这个例子中，asyncFunction函数使用async关键字定义异步函数，await暂停代码的执行，等待Promise对象的状态改变。当Promise对象的状态为fulfilled时，结果会被赋值给result变量，并输出到控制台。</p>
<p>以上三种方式都可以用于处理异步代码，在实际应用中可以根据具体的场景和需求选择合适的方式。</p>
</blockquote>
<h3 id="48-什么是防抖？"><a href="#48-什么是防抖？" class="headerlink" title="48.什么是防抖？"></a>48.什么是防抖？</h3><blockquote>
<p>在前端开发中，防抖（Debouncing）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p>
<p>防抖的实现方式是设置一个定时器，当函数被调用时，如果定时器已经存在，则清除定时器并重新设置一个新的定时器，等待一定时间后再执行函数。如果在定时器等待的时间内再次调用了该函数，则会重新设置定时器，并等待一定时间后再次执行函数。如果在定时器等待的时间内没有再次调用该函数，则定时器会到期并执行函数。</p>
<p>防抖的应用场景包括：</p>
<ol>
<li><p>搜索框输入联想功能：在用户输入关键字时，如果每输入一个字符就向服务器发送请求，则会导致频繁的网络请求，影响性能和用户体验。使用防抖可以限制请求的频率，只在用户停止输入一段时间后再向服务器发送请求。</p>
</li>
<li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用防抖可以限制计算的频率，只在窗口停止调整一段时间后再重新计算。</p>
</li>
</ol>
<p>防抖的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, delay) &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(this, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用debounce函数</span><br><span class="line">const debouncedFunc = debounce(function() &#123;</span><br><span class="line">  // 执行的函数</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，debounce函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间之后执行func函数。如果在延迟时间内再次调用该函数，则清除定时器并重新设置一个新的定时器，等待延迟时间后再次执行函数。调用debounce函数后返回一个新的函数debouncedFunc，该函数可以在需要防抖的地方使用。</p>
</blockquote>
<h3 id="49-什么是节流？"><a href="#49-什么是节流？" class="headerlink" title="49.什么是节流？"></a>49.什么是节流？</h3><blockquote>
<p>在前端开发中，节流（Throttling）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p>
<p>节流的实现方式是设置一个定时器，在定时器等待的时间内只允许函数执行一次，等待时间结束后再次允许函数执行。如果在等待时间内再次调用该函数，则该调用会被忽略。这样可以有效减少函数被调用的次数，提高应用程序的性能和响应速度。</p>
<p>节流的应用场景包括：</p>
<ol>
<li><p>滚动事件：在处理滚动事件时，如果每次滚动都处理一次事件，则会导致频繁的计算和渲染，影响性能和用户体验。使用节流可以限制事件的处理频率，只在一段时间内处理一次事件。</p>
</li>
<li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用节流可以限制计算的频率，只在一段时间内重新计算一次。</p>
</li>
</ol>
<p>节流的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        func.apply(this, args);</span><br><span class="line">        timer = null;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用throttle函数</span><br><span class="line">const throttledFunc = throttle(function() &#123;</span><br><span class="line">  // 执行的函数</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，throttle函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。调用throttle函数后返回一个新的函数throttledFunc，该函数可以在需要节流的地方使用。</p>
</blockquote>
<h3 id="50-如何实现防抖和节流？"><a href="#50-如何实现防抖和节流？" class="headerlink" title="50.如何实现防抖和节流？"></a>50.如何实现防抖和节流？</h3><blockquote>
<p>防抖和节流是优化前端性能的两种常用方法，它们都通过限制函数的执行次数来减少计算和渲染次数，提高页面性能和响应速度。</p>
<p>以下是防抖和节流的实现方法：</p>
<p>防抖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line"> &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debouncedFunc = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 执行的函数</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，debounce函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数会使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则会清除之前的计时器并重新设置计时器，等待一定时间后执行函数。</p>
<p>节流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">   timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">     timer = <span class="literal">null</span>;</span><br><span class="line">   &#125;, delay);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttledFunc = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 执行的函数</span></span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，throttle函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。</p>
<p>使用防抖和节流可以有效地减少函数的执行次数，提高页面性能和响应速度。需要根据具体场景选择合适的优化方法，并根据实际情况调整延迟时间来达到最优化的效果。</p>
</blockquote>
<h3 id="51-什么是深拷贝和浅拷贝？"><a href="#51-什么是深拷贝和浅拷贝？" class="headerlink" title="51.什么是深拷贝和浅拷贝？"></a>51.什么是深拷贝和浅拷贝？</h3><blockquote>
<p>深拷贝和浅拷贝是JavaScript中常用的两种复制对象的方式，它们之间的区别在于拷贝出的对象是否是对原始对象的完全独立拷贝。</p>
<p>浅拷贝指的是只复制原始对象的引用，而不是复制对象本身。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象会共享同一份数据，对拷贝出的新对象的修改会影响到原始对象，反之亦然。</p>
<p>以下是一个浅拷贝的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">c</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用Object.assign方法将原始对象obj的属性复制到一个新的对象中，并将这个新对象赋值给变量copy。由于浅拷贝的特性，copy.b和obj.b指向同一个对象，因此当我们修改copy.b.c时，obj.b.c的值也会相应地改变。</p>
<p>深拷贝指的是复制对象本身，而不是复制对象的引用。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象是完全独立的，对拷贝出的新对象的修改不会影响到原始对象，反之亦然。</p>
<p>以下是一个深拷贝的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"> <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">   copy[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">c</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">deepCopy</span>(obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用递归方式实现了一个深拷贝的函数deepCopy，该函数会遍历原始对象的每一个属性，当遇到一个对象类型的属性时，会递归地调用自身来复制这个对象。由于深拷贝的特性，copy.b和obj.b指向两个不同的对象，因此当我们修改copy.b.c时，obj.b.c的值不会改变。</p>
</blockquote>
<h3 id="52-如何实现深拷贝和浅拷贝？"><a href="#52-如何实现深拷贝和浅拷贝？" class="headerlink" title="52.如何实现深拷贝和浅拷贝？"></a>52.如何实现深拷贝和浅拷贝？</h3><blockquote>
<p>JavaScript 中的深拷贝和浅拷贝可以使用以下方式实现：</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝只复制对象的一层属性，而不复制对象的子对象。</p>
<ol>
<li>使用 ES6 中的 Object.assign() 方法进行浅拷贝：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用展开运算符（spread operator）进行浅拷贝：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝复制整个对象及其子对象，不会对原对象造成影响。</p>
<ol>
<li>使用 JSON.parse() 和 JSON.stringify() 方法进行深拷贝（需要注意的是，该方法无法处理函数等特殊类型的数据）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: &#123; b: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用递归方式进行深拷贝：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      result[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: &#123; b: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="53-什么是Event-Loop？"><a href="#53-什么是Event-Loop？" class="headerlink" title="53.什么是Event Loop？"></a>53.什么是Event Loop？</h3><blockquote>
<p>Event Loop（事件循环）是 JavaScript 中的一个机制，它负责协调调度所有的任务（包括异步任务和同步任务），确保它们按照正确的顺序执行。Event Loop 是 JavaScript 运行时环境的一部分，不同的运行时环境（如浏览器和 Node.js）可能有不同的实现方式，但基本原理是相同的。</p>
<p>在 JavaScript 中，任务分为同步任务和异步任务，同步任务会在调用栈中按顺序执行，而异步任务则会被放到消息队列中，等待 Event Loop 将其取出执行。</p>
<p>当调用栈中的所有同步任务执行完毕后，Event Loop 会检查消息队列中是否有待执行的异步任务，如果有，就将其从队列中取出放到调用栈中执行。在执行完异步任务后，又会检查消息队列中是否有待执行的任务，依次重复上述步骤。</p>
<p>由于 JavaScript 是单线程的语言，只有一个调用栈，所以 Event Loop 的机制使得 JavaScript 能够处理异步任务而不会阻塞调用栈的执行。这也是 JavaScript 能够处理大量 I&#x2F;O 操作的关键之一，例如 Ajax 请求、定时器等异步任务。</p>
</blockquote>
<h3 id="54-什么是JavaScript的执行上下文？"><a href="#54-什么是JavaScript的执行上下文？" class="headerlink" title="54.什么是JavaScript的执行上下文？"></a>54.什么是JavaScript的执行上下文？</h3><blockquote>
<p>在 JavaScript 中，执行上下文是指当前代码执行的环境，包括变量、函数、参数等。每当 JavaScript 引擎执行一段代码时，都会创建一个新的执行上下文，用来存储代码执行过程中的各种信息。</p>
<p>JavaScript 的执行上下文可以分为三种类型：</p>
<ol>
<li><p>全局执行上下文：当 JavaScript 代码第一次被解析和执行时，就会创建一个全局执行上下文，该执行上下文的作用域链包含全局变量对象和全局对象。</p>
</li>
<li><p>函数执行上下文：当 JavaScript 解析器进入函数时，就会创建一个新的函数执行上下文，该执行上下文的作用域链包含函数的活动对象、函数对象本身以及全局对象。</p>
</li>
<li><p>eval 执行上下文：当 JavaScript 解析器遇到 eval 函数时，会创建一个新的执行上下文，该执行上下文的作用域链包含 eval 函数的活动对象、全局对象以及外部函数的活动对象。</p>
</li>
</ol>
<p>执行上下文有三个重要的属性：</p>
<ol>
<li><p>变量对象（VO）：变量对象是执行上下文中的一个重要概念，用来存储函数中定义的变量和函数声明。函数执行上下文的变量对象包括函数的所有参数、函数声明和变量声明。</p>
</li>
<li><p>作用域链（Scope Chain）：作用域链是一个由当前执行上下文的变量对象和所有外层执行上下文的变量对象组成的列表，用于解析变量和函数的引用。</p>
</li>
<li><p>this 值：this 值是指当前执行上下文的 this 指向的对象，它的值取决于函数的调用方式。</p>
</li>
</ol>
<p>理解执行上下文的概念和属性对于理解 JavaScript 的作用域和执行顺序非常重要。</p>
</blockquote>
<h3 id="55-什么是作用域？"><a href="#55-什么是作用域？" class="headerlink" title="55.什么是作用域？"></a>55.什么是作用域？</h3><blockquote>
<p>在 JavaScript 中，作用域是指变量、函数等命名实体的可访问范围。JavaScript 采用的是词法作用域，也就是静态作用域，即作用域在代码编写时就已经确定，而不是在运行时动态确定。</p>
<p>JavaScript 中有两种作用域：全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p>
<p>在 JavaScript 中，作用域的创建是通过函数和块级作用域（ES6 中引入）来实现的。当函数被调用时，会创建一个新的作用域，该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。而块级作用域是指在一对花括号 <code>&#123;&#125;</code> 中定义的变量或函数，只能在该块级作用域内部访问。</p>
<p>作用域的作用是防止命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，它是指由内向外依次连接起来的作用域列表。当访问一个变量或函数时，JavaScript 引擎会先在当前作用域中查找，如果找不到就会向上一级作用域中查找，直到找到该变量或函数为止。</p>
</blockquote>
<h3 id="56-JavaScript的作用域是如何工作的？"><a href="#56-JavaScript的作用域是如何工作的？" class="headerlink" title="56.JavaScript的作用域是如何工作的？"></a>56.JavaScript的作用域是如何工作的？</h3><blockquote>
<p>JavaScript 的作用域是通过词法作用域来实现的，也就是在代码编写时就已经确定了变量的作用域，而不是在运行时动态确定。</p>
<p>在 JavaScript 中，作用域分为全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p>
<p>当 JavaScript 解析器遇到一个函数时，会创建一个新的作用域，称为函数作用域。该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。如果在函数内部定义了一个变量，它就会覆盖同名的外部变量，而在函数外部则无法访问到该变量。</p>
<p>在函数作用域中，变量的查找是通过作用域链来实现的。作用域链是一个由内向外连接起来的作用域列表，它的顶端是当前函数的作用域，底部是全局作用域。当访问一个变量时，JavaScript 引擎会首先在当前作用域中查找，如果没有找到，则会向上一级作用域中查找，直到找到该变量或者抵达全局作用域。如果还没有找到该变量，则会抛出一个“变量未定义”的错误。</p>
<p>除了函数作用域外，ES6 中还引入了块级作用域，通过 <code>let</code> 和 <code>const</code> 关键字定义的变量就是块级作用域。块级作用域的变量只在块级作用域内部可见，超出该范围则无法访问。</p>
<p>总的来说，JavaScript 的作用域机制是为了避免命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，通过它可以实现变量的查找和访问。</p>
</blockquote>
<h3 id="57-什么是变量提升？"><a href="#57-什么是变量提升？" class="headerlink" title="57.什么是变量提升？"></a>57.什么是变量提升？</h3><blockquote>
<p>变量提升是 JavaScript 中的一种行为，指在代码执行之前，JavaScript 引擎会默认将所有变量的声明提升到它们所在的作用域的顶部。换句话说，变量声明会被提升到执行上下文的顶部，但是变量的赋值并不会被提升，赋值操作会按照代码的顺序执行。</p>
<p>例如，以下代码会输出 <code>undefined</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>

<p>这是因为 JavaScript 引擎在执行代码之前会将变量 <code>a</code> 的声明提升到代码的顶部，因此在执行 <code>console.log(a)</code> 时，变量 <code>a</code> 已经被声明，但是并未被赋值，因此输出 <code>undefined</code>。</p>
<p>需要注意的是，只有变量声明会被提升，而变量赋值不会被提升。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // ReferenceError: a is not defined</span><br><span class="line">let a = 1;</span><br></pre></td></tr></table></figure>

<p>由于 <code>let</code> 声明的变量不会被提升，因此在执行 <code>console.log(a)</code> 时会抛出一个 <code>ReferenceError</code> 异常。</p>
<p>变量提升的机制虽然可以在一定程度上简化代码的书写，但是也容易引起混淆和错误，因此建议在代码中避免过度依赖变量提升，尽可能在变量使用之前进行声明和初始化。</p>
</blockquote>
<h3 id="58-如何避免变量提升？"><a href="#58-如何避免变量提升？" class="headerlink" title="58.如何避免变量提升？"></a>58.如何避免变量提升？</h3><blockquote>
<p>虽然变量提升是 JavaScript 的一种特性，但是可以通过以下几种方式来避免它带来的潜在问题：</p>
<ol>
<li><p>使用 <code>let</code> 或 <code>const</code> 关键字声明变量：<code>let</code> 和 <code>const</code> 声明的变量不会被提升，因此可以避免变量提升带来的问题。同时，使用 <code>let</code> 和 <code>const</code> 还可以避免变量重复声明和污染全局作用域的问题。</p>
</li>
<li><p>将变量声明和赋值分开：为了避免变量提升导致的混淆和错误，可以将变量声明和赋值分开，确保变量在使用前已经被正确地初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a;</span><br><span class="line">a = 1;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模块化编程：使用模块化编程可以将代码分割成多个独立的模块，每个模块都有自己的作用域，变量不会污染全局作用域，也不会被其他模块访问到，从而避免了变量提升带来的问题。</p>
</li>
</ol>
<p>虽然变量提升可以带来一定的方便，但是建议在编写 JavaScript 代码时尽量避免过度依赖变量提升，以提高代码的可读性和可维护性。</p>
</blockquote>
<h3 id="59-什么是模板标签函数？"><a href="#59-什么是模板标签函数？" class="headerlink" title="59.什么是模板标签函数？"></a>59.什么是模板标签函数？</h3><blockquote>
<p>模板标签函数是一种 JavaScript 函数，可以用于自定义模板字符串的解析方式。模板标签函数的作用是将模板字符串解析成一个 JavaScript 对象，可以对模板字符串中的变量进行处理和格式化。</p>
<p>模板标签函数的定义方式是在模板字符串前面添加一个标识符，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myTag(strings, ...values) &#123;</span><br><span class="line">// 处理模板字符串中的字符串和变量</span><br><span class="line">// 返回一个处理后的结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = myTag`Hello, $&#123;name&#125;!`;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>myTag</code> 就是一个模板标签函数，它接收两个参数：<code>strings</code> 和 <code>values</code>。其中，<code>strings</code> 是一个数组，包含了模板字符串中的所有字符串；<code>values</code> 是一个数组，包含了模板字符串中所有的变量。可以根据需要对这些字符串和变量进行处理，最后返回一个处理后的结果。</p>
<p>使用模板标签函数可以实现一些特定的功能，例如格式化日期、国际化等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function formatTime(strings, ...values) &#123;</span><br><span class="line">let date = new Date(values[0]);</span><br><span class="line">let year = date.getFullYear();</span><br><span class="line">let month = date.getMonth() + 1;</span><br><span class="line">let day = date.getDate();</span><br><span class="line">return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str = formatTime`The date is $&#123;Date.now()&#125;`;</span><br><span class="line">console.log(str); // 输出：The date is 2023-5-10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>formatTime</code> 是一个模板标签函数，它接收一个时间戳作为参数，将其转换成指定格式的日期字符串。使用模板标签函数可以实现一些常规的字符串处理操作，同时也可以扩展 JavaScript 的语法和功能。</p>
</blockquote>
<h3 id="60-如何使用标签模板？"><a href="#60-如何使用标签模板？" class="headerlink" title="60.如何使用标签模板？"></a>60.如何使用标签模板？</h3><h3 id="61-什么是迭代器？"><a href="#61-什么是迭代器？" class="headerlink" title="61.什么是迭代器？"></a>61.什么是迭代器？</h3><h3 id="62-如何使用迭代器？"><a href="#62-如何使用迭代器？" class="headerlink" title="62.如何使用迭代器？"></a>62.如何使用迭代器？</h3><h3 id="63-什么是生成器？"><a href="#63-什么是生成器？" class="headerlink" title="63.什么是生成器？"></a>63.什么是生成器？</h3><h3 id="64-如何使用生成器？"><a href="#64-如何使用生成器？" class="headerlink" title="64.如何使用生成器？"></a>64.如何使用生成器？</h3><h3 id="65-什么是可迭代对象？"><a href="#65-什么是可迭代对象？" class="headerlink" title="65.什么是可迭代对象？"></a>65.什么是可迭代对象？</h3><h3 id="66-如何创建可迭代对象？"><a href="#66-如何创建可迭代对象？" class="headerlink" title="66.如何创建可迭代对象？"></a>66.如何创建可迭代对象？</h3><h3 id="67-如何使用可迭代对象？"><a href="#67-如何使用可迭代对象？" class="headerlink" title="67.如何使用可迭代对象？"></a>67.如何使用可迭代对象？</h3><h3 id="68-什么是Promise-all？"><a href="#68-什么是Promise-all？" class="headerlink" title="68.什么是Promise.all？"></a>68.什么是Promise.all？</h3><h3 id="69-如何使用Promise-all？"><a href="#69-如何使用Promise-all？" class="headerlink" title="69.如何使用Promise.all？"></a>69.如何使用Promise.all？</h3><h3 id="70-什么是Promise-race？"><a href="#70-什么是Promise-race？" class="headerlink" title="70.什么是Promise.race？"></a>70.什么是Promise.race？</h3><h3 id="71-如何使用Promise-race？"><a href="#71-如何使用Promise-race？" class="headerlink" title="71.如何使用Promise.race？"></a>71.如何使用Promise.race？</h3><h3 id="72-什么是Symbol？"><a href="#72-什么是Symbol？" class="headerlink" title="72.什么是Symbol？"></a>72.什么是Symbol？</h3><h3 id="73-如何使用Symbol？"><a href="#73-如何使用Symbol？" class="headerlink" title="73.如何使用Symbol？"></a>73.如何使用Symbol？</h3><h3 id="74-什么是Proxy？"><a href="#74-什么是Proxy？" class="headerlink" title="74.什么是Proxy？"></a>74.什么是Proxy？</h3><h3 id="75-如何使用Proxy？"><a href="#75-如何使用Proxy？" class="headerlink" title="75.如何使用Proxy？"></a>75.如何使用Proxy？</h3><h3 id="76-什么是Reflect？"><a href="#76-什么是Reflect？" class="headerlink" title="76.什么是Reflect？"></a>76.什么是Reflect？</h3><h3 id="77-如何使用Reflect？"><a href="#77-如何使用Reflect？" class="headerlink" title="77.如何使用Reflect？"></a>77.如何使用Reflect？</h3><h3 id="78-什么是尾调用优化？"><a href="#78-什么是尾调用优化？" class="headerlink" title="78.什么是尾调用优化？"></a>78.什么是尾调用优化？</h3><h3 id="79-如何实现尾调用优化？"><a href="#79-如何实现尾调用优化？" class="headerlink" title="79.如何实现尾调用优化？"></a>79.如何实现尾调用优化？</h3><h3 id="80-如何禁用尾调用优化？"><a href="#80-如何禁用尾调用优化？" class="headerlink" title="80.如何禁用尾调用优化？"></a>80.如何禁用尾调用优化？</h3><h3 id="81-什么是柯里化？"><a href="#81-什么是柯里化？" class="headerlink" title="81.什么是柯里化？"></a>81.什么是柯里化？</h3><h3 id="82-如何实现柯里化？"><a href="#82-如何实现柯里化？" class="headerlink" title="82.如何实现柯里化？"></a>82.如何实现柯里化？</h3><h3 id="83-什么是函数组合？"><a href="#83-什么是函数组合？" class="headerlink" title="83.什么是函数组合？"></a>83.什么是函数组合？</h3><h3 id="84-如何实现函数组合？"><a href="#84-如何实现函数组合？" class="headerlink" title="84.如何实现函数组合？"></a>84.如何实现函数组合？</h3><h3 id="85-什么是函数式编程？"><a href="#85-什么是函数式编程？" class="headerlink" title="85.什么是函数式编程？"></a>85.什么是函数式编程？</h3><h3 id="86-如何在JavaScript中使用函数式编程？"><a href="#86-如何在JavaScript中使用函数式编程？" class="headerlink" title="86.如何在JavaScript中使用函数式编程？"></a>86.如何在JavaScript中使用函数式编程？</h3><h3 id="87-什么是纯函数？"><a href="#87-什么是纯函数？" class="headerlink" title="87.什么是纯函数？"></a>87.什么是纯函数？</h3><h3 id><a href="#" class="headerlink" title></a></h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">jlk-lebron</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小王的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/05/25/interview-winter/" title="interview-winter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">interview-winter</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jlk-lebron</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJavaScript%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.什么是JavaScript？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.如何声明变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-var%E3%80%81let%E5%92%8Cconst%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3.var、let和const关键字有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%B0%86JavaScript%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%E5%88%B0HTML%E9%A1%B5%E9%9D%A2%E4%B8%AD%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.如何将JavaScript代码嵌入到HTML页面中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%94%A8JavaScript%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84HTML%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.如何用JavaScript创建一个新的HTML元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BB%8EHTML%E5%85%83%E7%B4%A0%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6.如何从HTML元素中获取文本内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">7.如何在JavaScript中使用条件语句？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8.如何在JavaScript中使用循环语句？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">9.如何在JavaScript中创建对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">10.如何访问和修改对象的属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">11.如何在JavaScript中使用函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">12.如何传递参数给函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">13.如何在函数内部访问全局变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A6%82%E4%BD%95%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">14.如何从函数中返回值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15.如何在JavaScript中使用事件处理程序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">16.什么是匿名函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">17.如何在JavaScript中处理异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">18.什么是闭包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">19.如何在JavaScript中使用原型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">20.什么是原型链？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">21.如何在JavaScript中实现继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">22.如何在JavaScript中使用对象字面量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AFJSON%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">23.什么是JSON？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%A6%82%E4%BD%95%E5%B0%86JSON%E8%BD%AC%E6%8D%A2%E4%B8%BAJavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">24.如何将JSON转换为JavaScript对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%A6%82%E4%BD%95%E5%B0%86JavaScript%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BAJSON%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">25.如何将JavaScript对象转换为JSON？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">26.如何在JavaScript中使用模板字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">27.什么是箭头函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8Promise%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">28.如何在JavaScript中使用Promise？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">29.如何在JavaScript中使用异步函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">30.如何在JavaScript中使用回调函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">31.什么是事件委托？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">32.什么是模块化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">33.如何在JavaScript中使用模块化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E4%BB%80%E4%B9%88%E6%98%AFIIFE%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">34.什么是IIFE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8IIFE%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">35.如何在JavaScript中使用IIFE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E3%80%81%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A0%E9%99%A4cookie%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">36.如何设置、获取和删除cookie？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8localStorage%E5%92%8CsessionStorage%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">37.如何使用localStorage和sessionStorage？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8XMLHttpRequest%E5%8F%91%E9%80%81GET%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">38.如何使用XMLHttpRequest发送GET请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8XMLHttpRequest%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">39.如何使用XMLHttpRequest发送POST请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8fetch%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">40.如何使用fetch发送请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">41.如何使用axios发送请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">42.什么是跨域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">43.如何解决跨域问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">44.什么是事件循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">45.什么是同步代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">46.什么是异步代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">47.如何在JavaScript中处理异步代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">48.什么是防抖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E4%BB%80%E4%B9%88%E6%98%AF%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">49.什么是节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">50.如何实现防抖和节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">51.什么是深拷贝和浅拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">52.如何实现深拷贝和浅拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">53.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">54.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BB%80%E4%B9%88%E6%98%AFEvent-Loop%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">53.什么是Event Loop？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E4%BB%80%E4%B9%88%E6%98%AFJavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">54.什么是JavaScript的执行上下文？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">55.什么是作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-JavaScript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">56.JavaScript的作用域是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">57.什么是变量提升？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">58.如何避免变量提升？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">59.什么是模板标签函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">60.如何使用标签模板？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">61.什么是迭代器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">62.如何使用迭代器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">63.什么是生成器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">64.如何使用生成器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">65.什么是可迭代对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">66.如何创建可迭代对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">67.如何使用可迭代对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E4%BB%80%E4%B9%88%E6%98%AFPromise-all%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">68.什么是Promise.all？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Promise-all%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">69.如何使用Promise.all？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E4%BB%80%E4%B9%88%E6%98%AFPromise-race%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">70.什么是Promise.race？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Promise-race%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">71.如何使用Promise.race？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E4%BB%80%E4%B9%88%E6%98%AFSymbol%EF%BC%9F"><span class="toc-number">74.</span> <span class="toc-text">72.什么是Symbol？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Symbol%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">73.如何使用Symbol？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E4%BB%80%E4%B9%88%E6%98%AFProxy%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">74.什么是Proxy？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Proxy%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">75.如何使用Proxy？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E4%BB%80%E4%B9%88%E6%98%AFReflect%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">76.什么是Reflect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Reflect%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">77.如何使用Reflect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">80.</span> <span class="toc-text">78.什么是尾调用优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">81.</span> <span class="toc-text">79.如何实现尾调用优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">82.</span> <span class="toc-text">80.如何禁用尾调用优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">81.什么是柯里化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%9F"><span class="toc-number">84.</span> <span class="toc-text">82.如何实现柯里化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">83.什么是函数组合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%EF%BC%9F"><span class="toc-number">86.</span> <span class="toc-text">84.如何实现函数组合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">85.什么是函数式编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">88.</span> <span class="toc-text">86.如何在JavaScript中使用函数式编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">89.</span> <span class="toc-text">87.什么是纯函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">90.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JavaScript面试题">JavaScript面试题</a><time datetime="2023-05-25T02:11:45.000Z" title="发表于 2023-05-25 10:11:45">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/interview-winter/" title="interview-winter">interview-winter</a><time datetime="2023-05-25T02:09:31.000Z" title="发表于 2023-05-25 10:09:31">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/interview/" title="interview">interview</a><time datetime="2023-05-25T01:33:21.000Z" title="发表于 2023-05-25 09:33:21">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/20/react-router-dom/" title="react-router-dom">react-router-dom</a><time datetime="2023-05-20T12:32:39.000Z" title="发表于 2023-05-20 20:32:39">2023-05-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By jlk-lebron</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>