<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>写真集</title>
    <link href="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/"/>
    <url>/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/007.jpg"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/011.jpg" alt="011"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/025.jpg" alt="025"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/037.jpg" alt="037"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/039.jpg" alt="039"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/041.jpg" alt="041"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/043.jpg" alt="043"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/045.jpg" alt="045"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/047.jpg" alt="047"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/053.jpg" alt="053"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/056.jpg" alt="056"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/057%20%E6%8B%B7%E8%B4%9D.jpg" alt="057 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/057.jpg" alt="057"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/061%20%E6%8B%B7%E8%B4%9D.jpg" alt="061 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/061.jpg" alt="061"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/062%20%E6%8B%B7%E8%B4%9D.jpg" alt="062 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/062.jpg" alt="062"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/067%20%E6%8B%B7%E8%B4%9D.jpg" alt="067 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/067.jpg" alt="067"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/072%20%E6%8B%B7%E8%B4%9D.jpg" alt="072 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/072.jpg" alt="072"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/086%20%E6%8B%B7%E8%B4%9D.jpg" alt="086 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/086.jpg" alt="086"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/089.jpg" alt="089"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/092.jpg" alt="092"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/094.jpg" alt="094"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是JavaScript？"><a href="#1-什么是JavaScript？" class="headerlink" title="1.什么是JavaScript？"></a>1.什么是JavaScript？</h3><blockquote><p>JavaScript是一种动态、解释型编程语言，它是Web前端开发的基础之一。JavaScript主要用于Web浏览器中的客户端脚本编写，以增强Web页面的交互性和动态性。此外，它也可以用于服务端开发，开发桌面应用程序、游戏等。JavaScript具有简单易学、灵活多变、功能实用等优点，被广泛应用于Web开发、数据可视化、移动开发等领域。</p></blockquote><h3 id="2-如何声明变量？"><a href="#2-如何声明变量？" class="headerlink" title="2.如何声明变量？"></a>2.如何声明变量？</h3><blockquote><p>在JavaScript中，可以使用三个关键字来声明变量，分别是 <code>var</code>、<code>let</code>和<code>const</code>。</p><p>使用<code>var</code>关键字声明的变量可以是全局变量或函数作用域中的局部变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Tom&quot;</span>; <span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;My name is &quot;</span> + name; <span class="hljs-comment">// 局部变量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125;<br><span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出&quot;My name is Tom&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>let</code> 和 <code>const</code> 声明的变量则是块级作用域中的局部变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayAge</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">30</span>; <span class="hljs-comment">// 块级变量</span><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br> <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;You are an adult.&quot;</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;You are not an adult yet.&quot;</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125;<br>&#125;<br><span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">// 输出&quot;You are an adult.&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>const</code> 声明的变量是常量，一旦赋值就不能再修改其值。而 <code>let</code> 声明的变量可以被重新赋值。</p></blockquote><h3 id="3-var、let和const关键字有什么区别？"><a href="#3-var、let和const关键字有什么区别？" class="headerlink" title="3.var、let和const关键字有什么区别？"></a>3.var、let和const关键字有什么区别？</h3><blockquote><p> <code>var</code>、<code>let</code> 和 <code>const</code> 是 JavaScript 中用来声明变量的关键字，它们有以下几点不同：</p><ol><li><p>var 声明的变量可以是全局变量或函数作用域中的局部变量, 而 let 和 const 声明的变量则是块级作用域中的局部变量。</p></li><li><p>var 声明的变量存在变量提升的特性，即可在声明之前使用，而 let 和 const 声明的变量不存在变量提升的特性，必须先声明才能使用。</p></li><li><p>let 和 const 声明的变量是有作用域的，仅在声明的块级作用域中有效。而 var 声明的变量不存在块级作用域，使用 var 声明的变量在函数作用域内有效，如果没有包含在任何函数中，则在全局作用域内有效。</p></li><li><p>let 和 const 声明的变量都是有定义则必须初始化，否则会报错，而 var 声明的变量不是必须初始化。</p></li><li><p><code>const</code> 声明的变量是一个常量，一旦赋值就不能修改，而 <code>let</code> 声明的变量可以被重新赋值。</p></li></ol><p> 综上所述，如果要声明的变量不需要重复赋值，建议使用 <code>const</code>，只有在需要重新赋值时才使用 <code>let</code>，如果需要编写具有较大复杂度的代码时建议避免使用 <code>var</code>。</p></blockquote><h3 id="4-如何将JavaScript代码嵌入到HTML页面中？"><a href="#4-如何将JavaScript代码嵌入到HTML页面中？" class="headerlink" title="4.如何将JavaScript代码嵌入到HTML页面中？"></a>4.如何将JavaScript代码嵌入到HTML页面中？</h3><blockquote><p>可以在 HTML 文件中通过<code>&lt;script&gt;</code>标签来嵌入 JavaScript 代码，格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">// 在这里编写 JavaScript 代码</span></span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript 代码可以嵌入在 HTML 文档的 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 中。 通常，我们会将 JavaScript 代码单独写在一个 <code>.js</code> 文件中，并通过<code>&lt;script&gt;</code>标签的 <code>src</code> 属性引用它。例如，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;myScript.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>myScript.js</code> 是一个包含 JavaScript 代码的独立文件，该文件需要与 HTML 文件在同一目录下。使用这种方式，JavaScript 代码可以被多个页面共享，还可以避免 HTML 文件过大，使 HTML 文件与 JavaScript 代码分离出来，提高简洁性和可读性。</p></blockquote><h3 id="5-如何用JavaScript创建一个新的HTML元素？"><a href="#5-如何用JavaScript创建一个新的HTML元素？" class="headerlink" title="5.如何用JavaScript创建一个新的HTML元素？"></a>5.如何用JavaScript创建一个新的HTML元素？</h3><blockquote><p>在 JavaScript 中，可以使用 <code>createElement()</code> 方法创建一个新的 HTML 元素。该方法接受一个参数，表示要创建的元素的标签：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码会创建一个新的 <code>&lt;div&gt;</code> 元素，并将其保存在 <code>element</code> 变量中。可以使用以下方法来设置创建的元素的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;myDiv&quot;</span>;<br>element.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;important&quot;</span>;<br>element.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;This is my new element!&quot;</span>;<br></code></pre></td></tr></table></figure><p>以上代码会给元素设置 <code>id</code> 和 <code>class</code> 属性，以及设置元素的文本内容。可以将元素插入到文档中的任何位置。例如，可以将新元素插入到 <code>&lt;body&gt;</code> 元素的最后一个子元素之前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">insertBefore</span>(element, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">lastElementChild</span>);<br></code></pre></td></tr></table></figure><p>以上代码将新元素 <code>element</code> 插入到 <code>&lt;body&gt;</code> 的最后一个子元素之前。最终的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以将元素插入到任何已有元素的内部。例如，可以将新元素插入到具有 <code>id</code> 属性的元素内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myParentElement&quot;</span>);<br>parent.<span class="hljs-title function_">appendChild</span>(element);<br></code></pre></td></tr></table></figure><p>以上代码将新元素 <code>element</code> 插入到元素 <code>myParentElement</code> 的内部。 最终的HTML结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myParentElement&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6-如何从HTML元素中获取文本内容？"><a href="#6-如何从HTML元素中获取文本内容？" class="headerlink" title="6.如何从HTML元素中获取文本内容？"></a>6.如何从HTML元素中获取文本内容？</h3><blockquote><p>可以使用 JavaScript 中的 <code>textContent</code> 或者 <code>innerHTML</code> 属性从 HTML 元素中获取文本内容。</p><p><code>textContent</code> 属性返回元素及其后代元素的文本内容，但会忽略 HTML 标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myElement&quot;</span>&gt;</span>This is some <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以使用以下 JavaScript 代码获取元素的文本内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><span class="hljs-keyword">var</span> text = element.<span class="hljs-property">textContent</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text); <span class="hljs-comment">// 输出 &quot;This is some bold text.&quot;</span><br></code></pre></td></tr></table></figure><p>如果要获取包括 HTML 标记在内的元素内容，可以使用 <code>innerHTML</code> 属性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><span class="hljs-keyword">var</span> html = element.<span class="hljs-property">innerHTML</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html); <span class="hljs-comment">// 输出 &quot;This is some &lt;strong&gt;bold&lt;/strong&gt; text.&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>innerHTML</code> 属性也可以用于设置元素内容。如果设置的内容包含 HTML 标记，则会在元素内部插入对应的 DOM 树节点。因此，使用 <code>innerHTML</code> 属性时应确保内容是可信的，以避免安全漏洞。</p></blockquote><h3 id="7-如何在JavaScript中使用条件语句？"><a href="#7-如何在JavaScript中使用条件语句？" class="headerlink" title="7.如何在JavaScript中使用条件语句？"></a>7.如何在JavaScript中使用条件语句？</h3><blockquote><p>JavaScript 中的条件语句包括 <code>if</code> 语句、<code>else</code> 分支语句和 <code>else if</code> 语句。其语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (condition) &#123;<br><span class="hljs-regexp">//</span> 如果 condition 为 <span class="hljs-literal">true</span>，执行该代码块<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2) &#123;<br><span class="hljs-regexp">//</span> 如果 condition 为 <span class="hljs-literal">false</span>，但是 condition2 为 <span class="hljs-literal">true</span>，执行该代码块<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span> 如果 condition 和 condition2 都为 <span class="hljs-literal">false</span>，执行该代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>if</code> 后面的 <code>condition</code> 指定了一个条件表达式，如果该条件表达式返回 <code>true</code>，则执行 <code>if</code> 后面的代码块；否则，控制流会跳过该代码块，继续执行下一个语句。如果需要对多个不同的条件进行判断，可以使用 <code>else if</code> 语句。如果所有条件都不成立，则可以使用 <code>else</code> 语句执行备选代码块。</p><p>例如，以下代码检查给定的数字是否大于 10：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;<br><br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is greater than 10&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num === <span class="hljs-number">10</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is equal to 10&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is less than 10&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码会输出以下结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">The <span class="hljs-built_in">number</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">greater than</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>需要注意的是，条件表达式可以返回任何结果，不一定是 <code>true</code> 或 <code>false</code>。如果条件表达式返回一个“真值”（Truthy）的值，则该代码块将被执行；否则，该代码块将被跳过。条件表达式可以是任何可以强制转换为布尔值的表达式，例如数字、字符串和对象。</p></blockquote><h3 id="8-如何在JavaScript中使用循环语句？"><a href="#8-如何在JavaScript中使用循环语句？" class="headerlink" title="8.如何在JavaScript中使用循环语句？"></a>8.如何在JavaScript中使用循环语句？</h3><blockquote><p>在JavaScript中，有几种类型的循环语句可供使用，包括for、while和do-while循环。</p><p>以下是使用这些循环语句的示例：</p><ol><li>for循环<br>for循环可用于按照指定的次数执行代码块，可以用于遍历数组等数据结构。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (initialization; condition; increment/decrement) &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><ol start="2"><li>while循环<br>while循环可用于在满足指定条件时重复执行代码块。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (condition) &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i);<br>  i++;<br>&#125;<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><ol start="3"><li>do-while循环<br>do-while循环与while循环类似，但它先执行一次代码块，然后检查条件是否为真，如果为真则重复执行代码块。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125; <span class="hljs-keyword">while</span> (condition);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>);<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><p>这些循环语句可以嵌套在彼此中，以实现更复杂的逻辑。在编写循环时，请确保使用正确的条件和计数器，以避免陷入无限循环。</p></blockquote><h3 id="9-如何在JavaScript中创建对象？"><a href="#9-如何在JavaScript中创建对象？" class="headerlink" title="9.如何在JavaScript中创建对象？"></a>9.如何在JavaScript中创建对象？</h3><blockquote><p>在 JavaScript 中，对象可以通过多种方式创建，包括使用字面量、构造函数、Object.create() 方法等。下面是一些常用的创建对象的方法：</p><ol><li>使用字面量<br>使用字面量是创建对象的最简单的方法。可以通过花括号包裹键值对来定义一个对象。</li></ol><p>语法：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts">let <span class="hljs-attr">obj</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span> <br><span class="hljs-symbol">  key1:</span> value1, <br><span class="hljs-symbol">  key2:</span> value2,<br>  <span class="hljs-comment">// more key-value pairs </span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let person</span> = &#123;<br>  name: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: 25,<br>  address: &#123;<br>    street: <span class="hljs-string">&#x27;123 Main St&#x27;</span>,<br>    city: <span class="hljs-string">&#x27;Anytown&#x27;</span>,<br>    state: <span class="hljs-string">&#x27;CA&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用构造函数<br>使用构造函数可以创建一个对象的多个实例。构造函数是一种特殊类型的函数，通过关键字 <code>new</code> 来创建对象。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  <span class="hljs-keyword">this</span>.age = age;<br>  <span class="hljs-comment">// more properties and methods</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> person<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">let</span> person<span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 Object.create() 方法<br>使用 Object.create() 方法可以创建一个新对象，并将其原型设置为另一个对象或 null。</li></ol><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto[, propertiesObject]);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personProto = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(personProto);<br></code></pre></td></tr></table></figure><p>这些方法可以组合使用，例如，可以使用构造函数创建一个对象，然后将其原型设置为另一个对象。创建对象的方式取决于您的需求和代码的结构。</p></blockquote><h3 id="10-如何访问和修改对象的属性？"><a href="#10-如何访问和修改对象的属性？" class="headerlink" title="10.如何访问和修改对象的属性？"></a>10.如何访问和修改对象的属性？</h3><blockquote><p>在 JavaScript 中，可以使用点表示法或方括号表示法来访问和修改对象的属性。以下是访问和修改对象属性的示例：</p><ol><li>点表示法<br>使用点表示法可以访问和修改对象的属性，其中点后面是属性的名称。</li></ol><p>访问属性：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let person = &#123;<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: <span class="hljs-number">25</span><br>&#125;;<br>console.log(person.name); // Output: <span class="hljs-string">&#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>修改属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person.age = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.age); <span class="hljs-comment">// Output: 30</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方括号表示法<br>使用方括号表示法也可以访问和修改对象的属性，其中方括号内是属性的名称作为字符串。</li></ol><p>访问属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person[<span class="hljs-string">&#x27;name&#x27;</span>]); <span class="hljs-comment">// Output: &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>修改属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person[<span class="hljs-string">&#x27;age&#x27;</span>] = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person[<span class="hljs-string">&#x27;age&#x27;</span>]); <span class="hljs-comment">// Output: 30</span><br></code></pre></td></tr></table></figure><p>方括号表示法可以动态生成属性名称，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><span class="hljs-keyword">let</span> propName = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[propName]); <span class="hljs-comment">// Output: &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>无论使用哪种方法，访问和修改属性都是很简单的。如果属性不存在，访问属性将返回 undefined。如果需要检查属性是否存在，可以使用 hasOwnProperty() 方法。</p></blockquote><h3 id="11-如何在JavaScript中使用函数？"><a href="#11-如何在JavaScript中使用函数？" class="headerlink" title="11.如何在JavaScript中使用函数？"></a>11.如何在JavaScript中使用函数？</h3><blockquote><p>在 JavaScript 中，函数是一种重要的语言构造，可以用于执行特定的任务或操作。以下是使用函数的一些常见方式：</p><ol><li>定义函数<br>定义函数是使用 function 关键字创建的，可以指定函数名称、参数和函数体。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span><span class="hljs-params">(parameter1, parameter2, <span class="hljs-rest_arg">...) &#123;</span></span><br><span class="hljs-rest_arg"><span class="hljs-params">  // function</span> body</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>调用函数<br>调用函数可以使用函数名和括号运算符。如果函数有参数，则将参数传递给括号中。</li></ol><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">greet(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>返回值<br>函数可以返回一个值，可以使用 return 语句来返回值。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><ol start="4"><li>函数表达式<br>函数表达式是将函数分配给变量的一种方式。可以在需要时定义并调用函数。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">let functionName = <span class="hljs-keyword">function</span><span class="hljs-params">(parameter1, parameter2, <span class="hljs-rest_arg">...) &#123;</span></span><br><span class="hljs-rest_arg"><span class="hljs-params">  // function</span> body</span><br><span class="hljs-params">&#125;;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let greet = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br>greet(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// Output: &#x27;Hello, Bob!&#x27;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>箭头函数<br>箭头函数是一种简化的函数表达式，它使用箭头符号（&#x3D;&gt;）来定义函数。</li></ol><p>语法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> functionName =<span class="hljs-function"> (<span class="hljs-params">parameter1</span>, <span class="hljs-params">parameter2</span>, ...) =&gt;</span> &#123;<br>  <span class="hljs-comment">// function body</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>以上是一些基本的 JavaScript 函数使用方法。函数还有其他特性，例如函数作为参数、函数作为对象的方法等，可以根据需求进行学习和使用。</p></blockquote><h3 id="12-如何传递参数给函数？"><a href="#12-如何传递参数给函数？" class="headerlink" title="12.如何传递参数给函数？"></a>12.如何传递参数给函数？</h3><blockquote><p>在 JavaScript 中，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。以下是一些传递参数给函数的常见方式：</p><ol><li>位置参数<br>位置参数是在调用函数时传递的参数，它们按照在函数定义中声明的顺序进行传递。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，调用 add() 函数时传递了两个位置参数，它们分别赋给 a 和 b。</p><ol start="2"><li>默认参数<br>默认参数是在函数定义中声明的参数，如果在调用函数时未传递参数，则使用默认值。</li></ol><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> greet(name = <span class="hljs-string">&#x27;Guest&#x27;</span>) &#123;<br>  console.log(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br>greet(); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Guest!&#x27;</span><br>greet(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了默认参数 name，并在函数体中使用它。如果在调用函数时未传递参数，则使用默认值 Guest。</p><ol start="3"><li>剩余参数<br>剩余参数是在函数定义中声明的参数，它们捕获调用函数时未命名的额外参数，并将它们作为数组传递给函数。</li></ol><p>示例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(multiplier, <span class="hljs-rest_arg">...nums</span>)</span> &#123;<br>  let result = multiplier;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    result *= nums[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br>let product = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>console.log(product); <span class="hljs-comment">// Output: 24</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了 multiplier 和剩余参数 nums，并使用 for 循环将所有数字相乘。</p><p>通过以上这些常见方式，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。</p></blockquote><h3 id="13-如何在函数内部访问全局变量？"><a href="#13-如何在函数内部访问全局变量？" class="headerlink" title="13.如何在函数内部访问全局变量？"></a>13.如何在函数内部访问全局变量？</h3><blockquote><p>在 JavaScript 中，全局变量是定义在全局作用域中的变量，可以在程序的任何位置进行访问。可以在函数内部访问全局变量，以下是几种常见的方式：</p><ol><li>直接访问<br>可以在函数内部直接访问全局变量。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar);<br>&#125;<br>sayHello(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部直接访问了全局变量 globalVar。</p><ol start="2"><li>使用 window 对象<br>可以通过 window 对象在函数内部访问全局变量。在浏览器中，所有的全局变量都是 window 对象的属性。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">globalVar</span>);<br>&#125;<br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部使用 window 对象访问了全局变量 globalVar。</p><ol start="3"><li>使用全局对象<br>在 Node.js 等非浏览器环境中，可以使用全局对象来访问全局变量。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>);<br>&#125;<br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部使用全局对象 global 访问了全局变量 globalVar。</p><p>以上是在函数内部访问全局变量的几种常见方式，可以根据需要选择适合的方法来访问全局变量。需要注意的是，全局变量可能会影响程序的可读性和可维护性，因此应该尽量避免过多使用全局变量。</p></blockquote><h3 id="14-如何从函数中返回值？"><a href="#14-如何从函数中返回值？" class="headerlink" title="14.如何从函数中返回值？"></a>14.如何从函数中返回值？</h3><blockquote><p>在 JavaScript 中，可以使用 return 语句从函数中返回一个值。当函数执行到 return 语句时，它将停止执行并返回指定的值。以下是一些使用 return 语句返回值的示例：</p><ol><li>返回一个值</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 add() 使用 return 语句返回 a 和 b 的和。</p><ol start="2"><li>返回一个对象</li></ol><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> createUser(<span class="hljs-type">name</span>, age) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-type">name</span>: <span class="hljs-type">name</span>, age: age &#125;;<br>&#125;<br>let <span class="hljs-keyword">user</span> = createUser(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);<br>console.log(<span class="hljs-keyword">user</span>.name); // Output: <span class="hljs-string">&#x27;Alice&#x27;</span><br>console.log(<span class="hljs-keyword">user</span>.age); // Output: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 createUser() 使用 return 语句返回一个包含名称和年龄属性的对象。</p><ol start="3"><li>返回一个函数</li></ol><p>示例：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMultiplier</span>(<span class="hljs-params">multiplier</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num * multiplier;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-built_in">double</span> = createMultiplier(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Output: 10</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 createMultiplier() 使用 return 语句返回一个函数，该函数使用 multiplier 值来创建一个新的函数，该函数可以将其参数乘以 multiplier。</p><p>通过使用 return 语句，可以从函数中返回各种类型的值，包括数字、字符串、对象和函数等。在编写函数时，应该考虑返回什么样的值以及如何处理返回的值。</p></blockquote><h3 id="15-如何在JavaScript中使用事件处理程序？"><a href="#15-如何在JavaScript中使用事件处理程序？" class="headerlink" title="15.如何在JavaScript中使用事件处理程序？"></a>15.如何在JavaScript中使用事件处理程序？</h3><blockquote><p>在 JavaScript 中，可以通过事件处理程序来响应浏览器的用户交互事件，如单击、双击、鼠标移动、键盘按键等。以下是一些常见的使用事件处理程序的方法：</p><ol><li>使用 HTML 属性<br>可以在 HTML 元素上使用事件处理程序属性来指定事件处理程序。例如，可以使用 onclick 属性来指定单击事件的处理程序。</li></ol><p>示例：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>&gt;Click me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>在上面的示例中，单击按钮时将弹出一个包含 “Hello” 的警告框。</p><ol start="2"><li>使用 DOM 事件处理程序<br>可以使用 DOM 方法来添加事件处理程序。例如，可以使用 addEventListener() 方法来添加事件处理程序。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，使用 querySelector() 方法获取一个按钮元素，并使用 addEventListener() 方法添加一个单击事件处理程序。当按钮被单击时，将弹出一个包含 “Hello” 的警告框。</p><ol start="3"><li>使用对象属性<br>可以将事件处理程序指定为对象的属性。例如，可以创建一个包含单击事件处理程序的对象，并将其分配给按钮元素的 onclick 属性。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> handler = &#123;<br>  <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-property">onclick</span> = handler.<span class="hljs-property">handleClick</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，创建一个对象 handler，该对象包含一个 handleClick() 方法，该方法在单击事件发生时将弹出一个包含 “Hello” 的警告框。然后将 handleClick() 方法分配给按钮元素的 onclick 属性。</p><p>通过使用这些方法之一，可以在 JavaScript 中添加事件处理程序以响应浏览器的用户交互事件。需要注意的是，在编写事件处理程序时，应该确保它们能够正确处理各种情况，以确保程序的正确性和稳定性。</p></blockquote><h3 id="16-什么是匿名函数？"><a href="#16-什么是匿名函数？" class="headerlink" title="16.什么是匿名函数？"></a>16.什么是匿名函数？</h3><blockquote><p>在 JavaScript 中，匿名函数是一种没有指定名称的函数。匿名函数可以用作函数表达式，也可以用作立即调用的函数表达式 (IIFE)。</p><ol><li>函数表达式中的匿名函数</li></ol><p>函数表达式是将函数分配给变量或属性的一种方法。如果不需要多次引用该函数，则可以使用匿名函数。</p><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，将匿名函数分配给变量 add，并使用它来执行两个数字的相加操作。</p><ol start="2"><li>立即调用的函数表达式 (IIFE) 中的匿名函数</li></ol><p>IIFE 是一种立即调用的函数表达式，可以在定义后立即调用。匿名函数常常用于 IIFE 中，以便不会在全局作用域中引入不必要的函数名称。</p><p>示例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">function</span> () &#123;<br>  let message = <span class="hljs-symbol">&#x27;Hello</span>&#x27;<span class="hljs-comment">;</span><br>  console.log(<span class="hljs-name">message</span>)<span class="hljs-comment">;</span><br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，创建了一个匿名函数，并立即调用它。在匿名函数中，定义了一个名为 message 的变量，然后将字符串 ‘Hello’ 分配给它，并使用 console.log() 方法在控制台中输出消息。</p><p>由于匿名函数没有名称，因此不会在全局作用域中创建名称，从而避免了命名冲突和全局作用域污染的风险。</p><p>总之，匿名函数是一种灵活且常用的 JavaScript 函数类型，它可以在需要时使用，以避免在全局作用域中引入不必要的名称。</p></blockquote><h3 id="17-如何在JavaScript中处理异常？"><a href="#17-如何在JavaScript中处理异常？" class="headerlink" title="17.如何在JavaScript中处理异常？"></a>17.如何在JavaScript中处理异常？</h3><blockquote><p>在 JavaScript 中，异常处理是一种处理程序运行时出现的错误的机制。异常可以由各种因素引起，例如代码错误、网络问题、I&#x2F;O 错误等。</p><p>以下是在 JavaScript 中处理异常的方法：</p><ol><li>try-catch 语句</li></ol><p>try-catch 语句是一种处理异常的基本方法。它尝试执行可能会引发异常的代码，如果异常被抛出，则 catch 代码块将捕获异常并执行相应的处理。</p><p>示例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 可能会引发异常的代码</span><br>  let result = x / y;<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) &#123;<br>  <span class="hljs-comment">// 处理异常</span><br>  console.log(<span class="hljs-keyword">error</span>.message);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，try 代码块中的代码会尝试执行除法操作 x &#x2F; y。如果 y 为零，则会引发异常，并将其捕获到 catch 代码块中，然后输出错误消息。</p><ol start="2"><li>throw 语句</li></ol><p>throw 语句是一种手动引发异常的方法。它允许开发人员在代码中显式地引发异常，以便在后续的 try-catch 语句中捕获并处理。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">if</span> (y === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Cannot divide by zero&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x / y;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了一个 divide() 函数，该函数在 y 为零时显式地引发异常。然后，在 try-catch 语句中调用 divide() 函数并捕获异常。</p><ol start="3"><li>finally 语句</li></ol><p>finally 语句是一种在 try-catch 语句执行后无论是否发生异常都要执行的代码块。它通常用于释放资源或执行清理操作。</p><p>示例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 可能会引发异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) &#123;<br>  <span class="hljs-comment">// 处理异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-comment">// 执行清理操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，无论 try-catch 语句中是否发生异常，finally 代码块中的代码都会执行。</p><p>总之，JavaScript 中的异常处理是一种处理程序运行时错误的机制。try-catch 语句、throw 语句和 finally 语句是处理异常的基本方法，它们可以帮助开发人员更好地管理和处理程序中的错误情况。</p></blockquote><h3 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18.什么是闭包？"></a>18.什么是闭包？</h3><blockquote><p>在 JavaScript 中，闭包（Closure）是指一个函数与其词法环境的组合。具体来说，闭包允许函数访问其定义时所处的词法作用域中的变量和参数，即使在函数被调用后，它仍然可以访问这些变量和参数。</p><p>在 JavaScript 中，当一个函数内部定义了另一个函数，并将其返回时，返回的函数就形成了一个闭包。闭包中的函数可以访问包含它的函数的变量和参数，即使包含它的函数已经返回并被销毁。</p><p>以下是一个使用闭包的简单示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">count</span>++;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);<br>&#125;;<br>&#125;<br><br>let counter = createCounter();<br>counter(); <span class="hljs-comment">// 输出 1</span><br>counter(); <span class="hljs-comment">// 输出 2</span><br>counter(); <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，createCounter() 函数返回了一个函数，该函数形成了一个闭包，并可以访问 count 变量。每次调用 counter() 函数时，闭包中的 count 变量都会被递增，并输出当前的计数器值。</p><p>闭包在 JavaScript 中具有广泛的应用，例如：</p><ul><li>实现私有变量和方法</li><li>在循环中创建函数和事件处理程序</li><li>实现柯里化和偏函数等高级编程技巧</li><li>以及其他许多用途</li></ul><p>但是，由于闭包可能导致内存泄漏和性能问题，所以在使用闭包时应该格外小心，并确保及时释放不需要的变量和资源。</p></blockquote><h3 id="19-如何在JavaScript中使用原型？"><a href="#19-如何在JavaScript中使用原型？" class="headerlink" title="19.如何在JavaScript中使用原型？"></a>19.如何在JavaScript中使用原型？</h3><blockquote><p>在 JavaScript 中，每个对象都有一个原型（prototype）对象，该对象包含对象共享的属性和方法。当我们访问一个对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 就会沿着对象的原型链向上查找，直到找到该属性或方法为止。</p><p>在 JavaScript 中，可以使用构造函数（Constructor Function）来创建对象，每个构造函数都有一个原型对象，我们可以向该对象添加属性和方法。所有使用该构造函数创建的对象都会共享这些属性和方法。</p><p>以下是一个简单的示例，展示了如何使用原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; years old.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-number">25</span>);<br><br>person1.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is John and I&#x27;m 30 years old.&quot;</span><br>person2.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is Jane and I&#x27;m 25 years old.&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用构造函数 Person 创建了两个对象 person1 和 person2，并将它们的 name 和 age 属性设置为不同的值。我们还向 Person.prototype 对象添加了一个方法 greet，用于输出对象的信息。由于 person1 和 person2 都是使用 Person 构造函数创建的，它们都可以访问并使用该方法。</p><p>通过原型，我们可以使多个对象共享相同的属性和方法，这样可以提高程序的性能和代码的可维护性。但是，在修改原型时需要格外小心，因为这会影响到所有使用该构造函数创建的对象。</p></blockquote><h3 id="20-什么是原型链？"><a href="#20-什么是原型链？" class="headerlink" title="20.什么是原型链？"></a>20.什么是原型链？</h3><blockquote><p>在 JavaScript 中，每个对象都有一个原型对象（prototype），该对象包含该对象的共享属性和方法。每个原型对象又可以拥有自己的原型对象，这样就形成了一个原型链（prototype chain）。</p><p>当我们访问一个对象的属性或方法时，JavaScript 会首先查找该对象本身是否具有该属性或方法，如果没有，就会沿着该对象的原型链向上查找，直到找到该属性或方法为止。如果一直查找到最顶层的 Object.prototype 对象仍然没有找到，那么返回 undefined。</p><p>以下是一个简单的示例，展示了原型链的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; years old.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, major</span>) &#123;<br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">major</span> = major;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m studying &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">major</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Computer Science&quot;</span>);<br><br>student.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is John and I&#x27;m 20 years old.&quot;</span><br>student.<span class="hljs-title function_">study</span>(); <span class="hljs-comment">// 输出 &quot;I&#x27;m studying Computer Science&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了两个构造函数 Person 和 Student，Student 构造函数继承自 Person 构造函数。通过 Student.prototype &#x3D; Object.create(Person.prototype) 这行代码，我们将 Student 的原型对象设置为 Person 的原型对象，这样 Student 对象就可以共享 Person 的属性和方法。当我们调用 student.greet() 方法时，JavaScript 会首先查找 student 对象本身是否有 greet 方法，没有则沿着其原型链向上查找，最终找到 Person.prototype.greet 方法并输出。同样，当我们调用 student.study() 方法时，JavaScript 也会先查找 student 对象是否具有该方法，没有则查找 Person.prototype，最终找到 Student.prototype.study 方法并输出。</p><p>通过原型链，JavaScript 实现了对象之间的继承和属性共享，使代码更加灵活和可维护。</p></blockquote><h3 id="21-如何在JavaScript中实现继承？"><a href="#21-如何在JavaScript中实现继承？" class="headerlink" title="21.如何在JavaScript中实现继承？"></a>21.如何在JavaScript中实现继承？</h3><blockquote><p>在JavaScript中，可以通过以下几种方式来实现继承：</p><ol><li>原型继承：可以通过将一个对象的原型设置为另一个对象来实现继承。这种方法利用JavaScript中的原型链实现了继承，子类可以访问父类的属性和方法，代码示例如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I am an &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><br><span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.<span class="hljs-title function_">say</span>(); <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造函数继承：可以通过在子类构造函数中调用父类构造函数并使用call或apply方法将this绑定到子类实例上来实现继承。这种方法只能继承父类的属性，而不能继承父类的原型上的方法，代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>console.log(dog.<span class="hljs-keyword">type</span>); <span class="hljs-comment">// 输出 &#x27;animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>组合继承：可以通过将原型继承和构造函数继承结合起来，既继承了父类的属性，也继承了父类原型上的方法。代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype.say = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  console.log(&#x27;I am an &#x27; + this.<span class="hljs-keyword">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Animal()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype.constructor = Dog;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>dog.say<span class="hljs-literal">()</span>; <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>寄生组合继承：可以通过使用Object.create方法创建一个中间对象，然后将子类的原型设置为这个中间对象来实现继承。这种方法比组合继承更高效，因为不需要调用父类的构造函数两次。代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype.say = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  console.log(&#x27;I am an &#x27; + this.<span class="hljs-keyword">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype.constructor = Dog;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>dog.say<span class="hljs-literal">()</span>; <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="22-如何在JavaScript中使用对象字面量？"><a href="#22-如何在JavaScript中使用对象字面量？" class="headerlink" title="22.如何在JavaScript中使用对象字面量？"></a>22.如何在JavaScript中使用对象字面量？</h3><blockquote><p>对象字面量是一种创建和初始化JavaScript对象的方式，它使用一组键值对表示对象的属性和值。下面是使用对象字面量创建和初始化对象的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-comment">// 创建一个具有属性的对象</span><br><span class="hljs-keyword">var</span> person = &#123; <br><span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>, <br><span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>, <br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span> <br>&#125;;<br><br><span class="hljs-comment">// 访问对象属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">lastName</span>); <span class="hljs-comment">// 输出 &quot;Doe&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 25</span><br><br><span class="hljs-comment">// 修改对象属性</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 30</span><br><br><span class="hljs-comment">// 添加新属性</span><br>person.<span class="hljs-property">city</span> = <span class="hljs-string">&quot;New York&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">city</span>); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先创建了一个空对象 <code>person</code>，然后使用对象字面量创建了一个具有三个属性的对象，即 <code>firstName</code>、<code>lastName</code>和 <code>age</code>。我们可以使用点号 <code>.</code> 或方括号 <code>[]</code> 访问对象的属性，并且可以随时修改或添加新属性。对象字面量是JavaScript中创建和初始化对象的一种简单、快速且方便的方式。</p></blockquote><h3 id="23-什么是JSON？"><a href="#23-什么是JSON？" class="headerlink" title="23.什么是JSON？"></a>23.什么是JSON？</h3><blockquote><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，被广泛用于前后端数据交互和存储。它是一种文本格式，可读性高，易于理解和编写，并且可以被多种编程语言轻松解析和生成。</p><p>JSON由键值对组成，其中键必须是字符串类型，值可以是字符串、数字、布尔值、对象、数组或null。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Smith&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isMarried&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;street&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123 Main St&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Anytown&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CA&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;zip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12345&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;phoneNumbers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;555-1234&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;555-5678&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，键值对表示一个人的信息，其中包括姓名、年龄、婚姻状况、地址和电话号码等。地址和电话号码是对象和数组类型的值。</p><p>JSON可以通过JavaScript中的<code>JSON.parse()</code>和<code>JSON.stringify()</code>方法进行解析和序列化。其他编程语言也提供了类似的解析和序列化方法。</p></blockquote><h3 id="24-如何将JSON转换为JavaScript对象？"><a href="#24-如何将JSON转换为JavaScript对象？" class="headerlink" title="24.如何将JSON转换为JavaScript对象？"></a>24.如何将JSON转换为JavaScript对象？</h3><blockquote><p>在JavaScript中，可以使用内置的<code>JSON.parse()</code>方法将JSON字符串转换为JavaScript对象。<code>JSON.parse()</code>方法需要一个JSON字符串作为参数，它会返回一个JavaScript对象。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> jsonString = &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Smith&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: 30&#125;&#x27;;<br><span class="hljs-keyword">const</span> jsObject = JSON.<span class="hljs-keyword">parse</span>(jsonString);<br>console.<span class="hljs-built_in">log</span>(jsObject.name); <span class="hljs-comment">// 输出: John Smith</span><br>console.<span class="hljs-built_in">log</span>(jsObject.age); <span class="hljs-comment">// 输出: 30</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，首先定义了一个JSON字符串，然后使用<code>JSON.parse()</code>方法将其转换为一个JavaScript对象。最后，通过访问对象的属性来获取其值。</p><p>需要注意的是，JSON字符串必须符合JSON规范，否则<code>JSON.parse()</code>方法可能会抛出异常。如果JSON字符串不正确，可以使用在线JSON验证工具（如<a href="https://jsonlint.com/%EF%BC%89%E6%9D%A5%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8D%E5%AE%83%E3%80%82">https://jsonlint.com/）来检查并修复它。</a></p></blockquote><h3 id="25-如何将JavaScript对象转换为JSON？"><a href="#25-如何将JavaScript对象转换为JSON？" class="headerlink" title="25.如何将JavaScript对象转换为JSON？"></a>25.如何将JavaScript对象转换为JSON？</h3><blockquote><p>在JavaScript中，可以使用内置的<code>JSON.stringify()</code>方法将JavaScript对象转换为JSON字符串。<code>JSON.stringify()</code>方法需要一个JavaScript对象作为参数，它会返回一个表示该对象的JSON字符串。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const jsObject = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;John Smith&#x27;</span>,<br>age: <span class="hljs-number">30</span><br>&#125;;<br>const jsonString = <span class="hljs-type">JSON</span>.stringify(jsObject);<br>console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;age&quot;:<span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，首先定义了一个JavaScript对象，然后使用<code>JSON.stringify()</code>方法将其转换为一个JSON字符串。最后，通过打印字符串来查看结果。</p><p>需要注意的是，<code>JSON.stringify()</code>方法还可以接受一个可选的第二个参数，用于指定要包含在JSON字符串中的属性。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const jsObject = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;John Smith&#x27;</span>,<br>age: <span class="hljs-number">30</span>,<br>address: &#123;<br> street: <span class="hljs-string">&#x27;123 Main St&#x27;</span>,<br> city: <span class="hljs-string">&#x27;Anytown&#x27;</span>,<br> state: <span class="hljs-string">&#x27;CA&#x27;</span>,<br> zip: <span class="hljs-string">&#x27;12345&#x27;</span><br>&#125;<br>&#125;;<br>const jsonString = <span class="hljs-type">JSON</span>.stringify(jsObject, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>]);<br>console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;address&quot;:&#123;&quot;street&quot;:&quot;123 Main St&quot;,&quot;city&quot;:&quot;Anytown&quot;,&quot;state&quot;:&quot;CA&quot;,&quot;zip&quot;:&quot;12345&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，第二个参数是一个数组，包含要序列化为JSON字符串的属性名。在这个例子中，只有<code>name</code>和<code>address</code>属性被包含在了JSON字符串中，<code>age</code>属性被忽略了。</p></blockquote><h3 id="26-如何在JavaScript中使用模板字符串？"><a href="#26-如何在JavaScript中使用模板字符串？" class="headerlink" title="26.如何在JavaScript中使用模板字符串？"></a>26.如何在JavaScript中使用模板字符串？</h3><blockquote><p>在JavaScript中，可以使用模板字符串（template string）来动态生成字符串。模板字符串是由反引号 &#96;&#96; 包裹的字符串，其中可以包含占位符 <code>$&#123;expression&#125;</code>，expression 是一个 JavaScript 表达式，用于动态地插入值。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;John Smith&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// 输出: Hello, my name is John Smith and I am 30 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个模板字符串 <code>Hello, my name is $&#123;name&#125; and I am $&#123;age&#125; years old.</code>，其中 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code> 是占位符，分别被变量 <code>name</code> 和 <code>age</code> 的值所替换。</p><p>模板字符串还支持多行字符串和嵌套占位符。例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const message = <span class="hljs-string">`</span><br><span class="hljs-string">Hello,</span><br><span class="hljs-string">my name is <span class="hljs-subst">$&#123;name&#125;</span>,</span><br><span class="hljs-string">and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.</span><br><span class="hljs-string">Here is a list of my hobbies:</span><br><span class="hljs-string">  - <span class="hljs-subst">$&#123;hobbies.join(<span class="hljs-string">&#x27;\n- &#x27;</span>)&#125;</span></span><br><span class="hljs-string">`</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(message);<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个多行的模板字符串，其中包含嵌套的占位符 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code>，以及使用 <code>Array.join()</code> 方法将数组 <code>hobbies</code> 的每个元素连接成一个以 <code>- </code> 为分隔符的字符串。</p><p>需要注意的是，模板字符串在输出时会保留其原始格式，包括空格、缩进和换行符。如果想要去除多余的空格和换行符，可以使用模板标签（tagged template）或者在占位符中使用正则表达式等方式来处理。</p></blockquote><h3 id="27-什么是箭头函数？"><a href="#27-什么是箭头函数？" class="headerlink" title="27.什么是箭头函数？"></a>27.什么是箭头函数？</h3><blockquote><p>箭头函数（Arrow Function）是ES6新增的一种函数定义方式，它可以更简洁地定义一个函数，并且与普通函数有一些不同的语法特性。</p><p>箭头函数的语法格式如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">(param1, param2, ...) =&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>param1</code>、<code>param2</code> 等是函数的参数，<code>statements</code> 是函数体，可以是一条语句或者多条语句的块。如果函数只有一个参数，则可以省略括号；如果函数体只有一条语句，则可以省略大括号和 <code>return</code> 关键字。</p><p>例如，以下两个函数的定义是等价的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 使用普通函数定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-comment">// 使用箭头函数定义</span><br>const square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x;<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个求平方的函数 <code>square</code>，第一个使用了普通函数的定义方式，第二个使用了箭头函数的定义方式。在箭头函数中，可以省略 <code>function</code> 关键字和大括号，从而让函数定义更加简洁。</p><p>除了语法上的简洁性，箭头函数还有一些其他的特性。例如，箭头函数的 <code>this</code> 值绑定到定义函数时的作用域，而不是调用函数时的作用域。这个特性可以避免在使用回调函数时出现 <code>this</code> 值丢失的问题。同时，箭头函数也不能使用 <code>arguments</code> 对象来访问参数，但可以通过使用剩余参数（rest parameter）或者默认参数（default parameter）来实现类似的功能。</p></blockquote><h3 id="28-如何在JavaScript中使用Promise？"><a href="#28-如何在JavaScript中使用Promise？" class="headerlink" title="28.如何在JavaScript中使用Promise？"></a>28.如何在JavaScript中使用Promise？</h3><blockquote><p>Promise是JavaScript异步编程的一种解决方案，它可以更好地处理异步操作的结果和错误，并且可以避免回调地狱（callback hell）的问题。在JavaScript中，Promise是一个对象，用于表示异步操作的最终完成或失败，并且可以链式调用多个操作。</p><p>使用Promise一般需要以下三个步骤：</p><ol><li><p>创建一个Promise对象，通常需要传入一个执行器函数（executor function），它会在Promise对象创建时立即执行，用于执行异步操作并决定Promise的状态。在执行器函数中，可以调用resolve方法来表示异步操作成功完成并返回结果，或者调用reject方法来表示异步操作失败并返回错误信息。</p></li><li><p>调用Promise对象的then方法来注册成功回调和catch方法来注册失败回调。在异步操作完成后，如果操作成功，则会调用成功回调，并且将异步操作的结果作为参数传递给回调函数；如果操作失败，则会调用失败回调，并且将错误信息作为参数传递给回调函数。</p></li><li><p>可以链式调用多个Promise对象，通过then方法返回一个新的Promise对象，并在其回调函数中执行下一个异步操作。如果在链式调用过程中遇到错误，则可以使用catch方法捕获错误并处理。</p></li></ol><p>例如，下面是一个使用Promise实现异步加载图片的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    const img = <span class="hljs-keyword">new</span> Image();<br>    img.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(img);<br>    img.onerror = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;Could not load image&#x27;</span>));<br>    img.src = url;<br>  &#125;);<br>&#125;<br><br>loadImage(<span class="hljs-string">&#x27;https://example.com/image.png&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Image loaded:&#x27;</span>, img);<br>    <span class="hljs-comment">// 执行下一个异步操作</span><br>    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;https://example.com/data.json&#x27;</span>);<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Data loaded:&#x27;</span>, data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它返回一个Promise对象，并且在执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后通过链式调用Promise对象的then方法和catch方法，依次执行多个异步操作，并在回调函数中处理结果或错误。</p></blockquote><h3 id="29-如何在JavaScript中使用异步函数？"><a href="#29-如何在JavaScript中使用异步函数？" class="headerlink" title="29.如何在JavaScript中使用异步函数？"></a>29.如何在JavaScript中使用异步函数？</h3><blockquote><p>异步函数（async function）是ES8（或称ES2017）中新增的语法，它是基于Promise的语法糖，可以更方便地编写异步代码。使用异步函数可以让代码更加简洁、易读和易维护，同时避免回调地狱和手动处理Promise对象的then和catch方法。</p><p>使用异步函数的步骤如下：</p><ol><li><p>在函数声明前面加上async关键字，表示这是一个异步函数。异步函数中可以使用await关键字来等待异步操作的结果，await关键字只能在异步函数中使用。</p></li><li><p>在异步函数中调用异步操作的函数，并使用await关键字等待操作结果。在等待异步操作结果的过程中，JavaScript会暂停当前异步函数的执行，并执行其他的JavaScript代码，直到异步操作完成并返回结果，然后继续执行异步函数。</p></li><li><p>如果异步操作成功完成，则await关键字返回操作结果；如果异步操作失败，则抛出一个错误，可以使用try-catch语句来捕获错误并处理。</p></li></ol><p>例如，下面是一个使用异步函数实现异步加载图片的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(img);<br>    img.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Could not load image&#x27;</span>));<br>    img.<span class="hljs-property">src</span> = url;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-string">&#x27;https://example.com/image.png&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Image loaded:&#x27;</span>, img);<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/data.json&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data loaded:&#x27;</span>, data);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个异步函数 <code>loadImage</code>，它返回一个Promise对象，并且在Promise对象的执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后定义了另一个异步函数 <code>main</code>，它通过使用await关键字等待异步操作的结果来处理异步加载图片和数据的过程。最后调用main函数来启动异步过程，并使用try-catch语句来捕获错误并处理。</p></blockquote><h3 id="30-如何在JavaScript中使用回调函数？"><a href="#30-如何在JavaScript中使用回调函数？" class="headerlink" title="30.如何在JavaScript中使用回调函数？"></a>30.如何在JavaScript中使用回调函数？</h3><blockquote><p>回调函数是一种在JavaScript中广泛使用的技术，它可以让异步代码更容易编写和维护。在JavaScript中，函数可以作为变量传递，因此可以将函数作为参数传递给其他函数，这种被传递的函数就是回调函数。</p><p>使用回调函数的步骤如下：</p><ol><li><p>定义一个异步操作函数，并在该函数中定义一个回调函数参数。异步操作函数可以是自己定义的函数，也可以是JavaScript内置的异步函数，如setTimeout、setInterval、XMLHttpRequest等。</p></li><li><p>在异步操作完成后，调用回调函数并将结果作为参数传递给它。在回调函数中，可以处理异步操作的结果，例如更新页面内容、显示错误信息等。</p></li></ol><p>例如，下面是一个使用回调函数实现异步加载图片的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> load<span class="hljs-constructor">Image(<span class="hljs-params">url</span>, <span class="hljs-params">callback</span>)</span> &#123;<br>  const img = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Image()</span>;<br>  img.onload =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> callback(null, img);<br>  img.onerror =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(&#x27;Could <span class="hljs-params">not</span> <span class="hljs-params">load</span> <span class="hljs-params">image</span>&#x27;)</span>);<br>  img.src = url;<br>&#125;<br><br>load<span class="hljs-constructor">Image(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">example</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">image</span>.<span class="hljs-params">png</span>&#x27;, (<span class="hljs-params">error</span>, <span class="hljs-params">img</span>)</span> =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    console.error(&#x27;Error:&#x27;, error);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    console.log(&#x27;Image loaded:&#x27;, img);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它接受一个图片URL和一个回调函数作为参数。在函数中，创建一个Image对象，并在Image对象的onload和onerror事件中分别调用回调函数并传递操作结果。然后调用 <code>loadImage</code> 函数来启动异步加载图片的过程，并在回调函数中处理加载结果。</p><p>需要注意的是，在使用回调函数时，要避免回调地狱（callback hell）的问题。如果嵌套过多的回调函数，会使代码难以阅读和维护。可以使用Promise、async&#x2F;await等其他技术来解决这个问题。</p></blockquote><h3 id="31-什么是事件委托？"><a href="#31-什么是事件委托？" class="headerlink" title="31.什么是事件委托？"></a>31.什么是事件委托？</h3><blockquote><p>事件委托（Event delegation）是一种优化JavaScript事件处理的技术。它利用事件冒泡的机制，在祖先元素上注册事件，然后通过事件的target属性来判断是哪个后代元素触发了事件。</p><p>使用事件委托的优点包括：</p><ol><li><p>减少事件处理程序的数量：通过将事件处理程序注册到祖先元素上，可以减少页面上的事件处理程序数量，从而提高性能和代码可维护性。</p></li><li><p>动态添加元素：在使用事件委托的情况下，如果动态添加了元素，它们会自动继承祖先元素上的事件处理程序，而不需要手动注册事件。</p></li></ol><p>下面是一个使用事件委托处理按钮点击事件的例子：</p><p>HTML代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> list = document.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);<br><br>list.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">event</span> =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.target.tagName === <span class="hljs-string">&#x27;BUTTON&#x27;</span>) &#123;<br>    console.log(<span class="hljs-string">&#x27;Button clicked:&#x27;</span>, <span class="hljs-keyword">event</span>.target.innerText);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的例子中，通过将click事件注册到祖先元素list上，可以处理按钮点击事件。在事件处理程序中，使用event.target属性来判断是哪个后代元素触发了事件，并处理点击事件。需要注意的是，只有当点击的元素是button元素时，才会触发事件处理程序。</p></blockquote><h3 id="32-什么是模块化？"><a href="#32-什么是模块化？" class="headerlink" title="32.什么是模块化？"></a>32.什么是模块化？</h3><blockquote><p>模块化是一种组织和管理JavaScript代码的方式，它将代码分解为独立的模块，每个模块都有自己的作用域，可以独立开发、测试、维护和重用。</p><p>在传统的JavaScript中，所有的代码都是在全局作用域下执行的，容易造成命名冲突、代码耦合度高等问题。而模块化则通过封装变量和函数，将代码组织成可复用的、低耦合的、可维护的模块。</p><p>常见的模块化规范有CommonJS、AMD和ES6模块化。</p><p>CommonJS是一种用于服务器端JavaScript的模块化规范，它使用require()函数来导入模块，使用module.exports对象来导出模块。</p><p>AMD（Asynchronous Module Definition）是一种用于浏览器端JavaScript的模块化规范，它使用define()函数来定义模块，使用require()函数来导入模块。</p><p>ES6模块化是JavaScript的官方模块化规范，它使用import语句来导入模块，使用export语句来导出模块。ES6模块化具有内置的异步加载和懒加载机制，可以在浏览器端和服务器端使用。</p><p>下面是一个使用ES6模块化导入和导出模块的例子：</p><p>模块A代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>模块B代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> moduleB.js<br>import &#123; greeting, sayHello &#125; from <span class="hljs-string">&#x27;./moduleA.js&#x27;</span>;<br><br>sayHello(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> 输出: Hello, Alice!<br>console.log(greeting); <span class="hljs-regexp">//</span> 输出: Hello<br></code></pre></td></tr></table></figure><p>在上面的例子中，模块A导出了两个变量：greeting和sayHello，模块B使用import语句来导入这两个变量，并使用它们输出信息。需要注意的是，模块A需要使用export语句来将变量导出，而模块B使用import语句来导入变量。</p></blockquote><h3 id="33-如何在JavaScript中使用模块化？"><a href="#33-如何在JavaScript中使用模块化？" class="headerlink" title="33.如何在JavaScript中使用模块化？"></a>33.如何在JavaScript中使用模块化？</h3><blockquote><p>在JavaScript中使用模块化，可以帮助我们更好地组织代码，并且可以避免全局作用域的污染。下面是几种常见的使用模块化的方法：</p><ol><li>CommonJS：<br>CommonJS是一种用于服务器端JavaScript的模块化系统，它使用require()和module.exports来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = add;<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> add = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br></code></pre></td></tr></table></figure><ol start="2"><li>ES6模块：<br>ES6模块是一种新的JavaScript模块化系统，它使用import和export语句来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用import语句来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br></code></pre></td></tr></table></figure><ol start="3"><li>AMD：<br>AMD（Asynchronous Module Definition）是一种在浏览器端使用的模块化系统，它使用define()和require()函数来定义和导入模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: add<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./module.js&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>以上是几种常见的模块化方法，每种方法都有其自己的优缺点，可以根据具体的应用场景选择合适的方法。</p></blockquote><h3 id="34-什么是IIFE？"><a href="#34-什么是IIFE？" class="headerlink" title="34.什么是IIFE？"></a>34.什么是IIFE？</h3><blockquote><p>IIFE代表立即调用的函数表达式（Immediately Invoked Function Expression），它是一种用于在JavaScript中创建局部作用域的常见模式。IIFE是一种匿名函数表达式，可以在定义后立即调用它。</p><p>IIFE通常使用以下模式来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 在这里定义变量和函数</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于函数被定义在一个函数作用域内，因此其中定义的变量和函数只在函数内部可见，不会影响全局作用域。这样可以有效地避免变量名和函数名冲突的问题。</p><p>IIFE的另一个常见的用途是将一段代码作为一个整体，并且可以在其中定义私有变量和函数。这样可以防止其他代码修改这些变量和函数，保护代码的安全性和稳定性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> result = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>();<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个IIFE来创建一个私有的作用域，并在其中定义了变量x和y，以及函数add。然后，我们通过return语句将add函数的返回值返回出来，并将其赋值给变量result。由于x、y和add都是在IIFE的作用域中定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p></blockquote><h3 id="35-如何在JavaScript中使用IIFE？"><a href="#35-如何在JavaScript中使用IIFE？" class="headerlink" title="35.如何在JavaScript中使用IIFE？"></a>35.如何在JavaScript中使用IIFE？</h3><blockquote><p>在JavaScript中使用IIFE非常简单，只需要按照以下模式编写代码即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 在这里编写代码</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于这个匿名函数是立即调用的，因此我们也称之为“立即调用的函数表达式”（IIFE）。</p><p>下面是一个使用IIFE的简单示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> result = x + y;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个IIFE，其中包含了一些变量和逻辑。由于IIFE是立即调用的，因此其中的代码会在JavaScript引擎执行到这个函数时立即执行。在这个例子中，我们在IIFE中定义了变量x和y，并将它们相加赋值给变量result，然后将result打印到控制台上。由于变量x、y和result都是在IIFE的作用域内定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p></blockquote><h3 id="36-如何设置、获取和删除cookie？"><a href="#36-如何设置、获取和删除cookie？" class="headerlink" title="36.如何设置、获取和删除cookie？"></a>36.如何设置、获取和删除cookie？</h3><blockquote><p>在JavaScript中，可以使用document对象的cookie属性来设置、获取和删除cookie。cookie是一种用于在客户端保存数据的机制，它允许Web应用程序在不同的请求之间共享数据。</p><p>以下是如何设置cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;name=value; expires=Thu, 01 Jan 2026 00:00:00 UTC; path=/&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用document.cookie属性将一个名为name，值为value的cookie写入客户端。expires选项指定了cookie的过期时间，path选项指定了cookie的路径。</p><p>以下是如何获取cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cookieValue = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?:(?:^|.*;\s*)name\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="hljs-string">&quot;$1&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用document.cookie属性获取所有的cookie，然后使用正则表达式来提取名为name的cookie的值。这里使用了一个正则表达式来匹配和提取cookie值。</p><p>以下是如何删除cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将名为name的cookie的值设置为空字符串，并将过期时间设置为一个过去的时间，以便将其删除。path选项也需要与之前设置cookie时的path选项相同，否则可能会出现删除不完全的情况。</p><p>需要注意的是，由于cookie是保存在客户端上的，因此它们可能会被篡改或删除。因此，在处理敏感数据时，应该谨慎使用cookie，并使用其他更安全的机制来保存数据。</p></blockquote><h3 id="37-如何使用localStorage和sessionStorage？"><a href="#37-如何使用localStorage和sessionStorage？" class="headerlink" title="37.如何使用localStorage和sessionStorage？"></a>37.如何使用localStorage和sessionStorage？</h3><blockquote><p>localStorage和sessionStorage都是HTML5中提供的Web存储机制，它们可以用来在客户端上保存数据，并且比cookie更方便、更安全。</p><p>localStorage和sessionStorage的主要区别在于它们的生命周期和作用域：</p><ul><li>localStorage中保存的数据没有过期时间，除非被清除，否则一直存在于客户端上。</li><li>sessionStorage中保存的数据只在当前会话期间有效，当用户关闭浏览器窗口或标签页时会被清除。</li></ul><p>以下是如何使用localStorage和sessionStorage的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将数据保存到localStorage中</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;30&#x27;</span>);<br><br><span class="hljs-comment">// 从localStorage中获取数据</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">var</span> age = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><br><span class="hljs-comment">// 从localStorage中删除数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><br><span class="hljs-comment">// 将数据保存到sessionStorage中</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-string">&#x27;New York&#x27;</span>);<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;country&#x27;</span>, <span class="hljs-string">&#x27;USA&#x27;</span>);<br><br><span class="hljs-comment">// 从sessionStorage中获取数据</span><br><span class="hljs-keyword">var</span> city = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>);<br><span class="hljs-keyword">var</span> country = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;country&#x27;</span>);<br><br><span class="hljs-comment">// 从sessionStorage中删除数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先使用setItem()方法将数据保存到localStorage和sessionStorage中，然后使用getItem()方法从中获取数据，使用removeItem()方法从中删除数据。</p><p>需要注意的是，localStorage和sessionStorage中只能保存字符串类型的数据。如果需要保存其他类型的数据，可以先将其序列化为字符串，然后再保存。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;New York&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 将对象序列化为字符串</span><br><span class="hljs-keyword">var</span> personStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(person);<br><br><span class="hljs-comment">// 将字符串保存到localStorage中</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>, personStr);<br><br><span class="hljs-comment">// 从localStorage中获取字符串并反序列化为对象</span><br><span class="hljs-keyword">var</span> personObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>));<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将一个JavaScript对象序列化为一个字符串，然后将这个字符串保存到localStorage中。当需要获取这个对象时，我们先从localStorage中获取这个字符串，然后使用JSON.parse()方法将其反序列化为一个对象。</p></blockquote><h3 id="38-如何使用XMLHttpRequest发送GET请求？"><a href="#38-如何使用XMLHttpRequest发送GET请求？" class="headerlink" title="38.如何使用XMLHttpRequest发送GET请求？"></a>38.如何使用XMLHttpRequest发送GET请求？</h3><blockquote><p>XMLHttpRequest对象是在JavaScript中发送HTTP请求的常用方式之一。使用XMLHttpRequest对象，我们可以向服务器发送GET、POST、PUT等类型的请求，并获取服务器返回的数据。</p><p>以下是使用XMLHttpRequest对象发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个XMLHttpRequest对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 设置请求的URL</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 如果请求成功</span><br><span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">var</span> responseData = xhr.<span class="hljs-property">responseText</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responseData);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// 请求失败，处理错误</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error: &#x27;</span> + xhr.<span class="hljs-property">status</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个XMLHttpRequest对象，然后使用open()方法设置请求的URL和HTTP方法。第三个参数指示是否使用异步方式发送请求。然后我们监听XMLHttpRequest对象的onload事件，在请求完成时触发该事件，并在事件处理程序中处理服务器返回的数据。如果请求失败，我们会在事件处理程序中处理错误。</p><p>需要注意的是，XMLHttpRequest对象只能用于同源的请求。如果需要向不同源的服务器发送请求，可以使用JSONP或CORS等技术来解决跨域问题。</p></blockquote><h3 id="39-如何使用XMLHttpRequest发送POST请求？"><a href="#39-如何使用XMLHttpRequest发送POST请求？" class="headerlink" title="39.如何使用XMLHttpRequest发送POST请求？"></a>39.如何使用XMLHttpRequest发送POST请求？</h3><blockquote><p>使用XMLHttpRequest对象发送POST请求与发送GET请求的过程类似，但是我们需要设置请求的Content-Type头部，并将请求体作为send()方法的参数。</p><p>以下是使用XMLHttpRequest对象发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个XMLHttpRequest对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 设置请求的URL和HTTP方法</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置Content-Type头部</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 如果请求成功</span><br><span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">var</span> responseData = xhr.<span class="hljs-property">responseText</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responseData);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// 请求失败，处理错误</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error: &#x27;</span> + xhr.<span class="hljs-property">status</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 设置请求体并发送请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData));<br></code></pre></td></tr></table></figure><p>在这个示例中，我们设置了POST请求的Content-Type头部为application&#x2F;json，并将请求体序列化为一个JSON字符串，并作为send()方法的参数。在监听XMLHttpRequest对象的onload事件时，我们将服务器返回的数据作为响应的主体，可以使用responseText属性获取。</p><p>需要注意的是，如果发送的请求体是FormData对象，我们不需要手动设置Content-Type头部，因为XMLHttpRequest对象会自动设置为multipart&#x2F;form-data。</p></blockquote><h3 id="40-如何使用fetch发送请求？"><a href="#40-如何使用fetch发送请求？" class="headerlink" title="40.如何使用fetch发送请求？"></a>40.如何使用fetch发送请求？</h3><blockquote><p>Fetch API是现代浏览器中用于发送HTTP请求的一种标准方式。它使用Promise对象处理异步请求，提供了比传统XMLHttpRequest更简单的API。</p><p>以下是使用fetch发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送GET请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用fetch()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在第一个then()方法中，我们将响应体解析为一个JSON对象。在第二个then()方法中，我们可以对解析后的数据进行处理。如果出现错误，我们可以在catch()方法中处理错误。</p><p>以下是使用fetch发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送POST请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, &#123;<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">headers</span>: &#123;<br> <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;,<br><span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData)<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们在fetch()方法的第二个参数中指定了HTTP方法、头部和请求体。与XMLHttpRequest对象类似，我们需要设置Content-Type头部，并将请求体序列化为一个JSON字符串。</p><p>需要注意的是，fetch()方法默认不会发送cookie和身份验证信息。如果需要发送cookie或身份验证信息，需要在fetch()方法的第二个参数中设置credentials属性为’include’。</p></blockquote><h3 id="41-如何使用axios发送请求？"><a href="#41-如何使用axios发送请求？" class="headerlink" title="41.如何使用axios发送请求？"></a>41.如何使用axios发送请求？</h3><blockquote><p>Axios是一种流行的JavaScript库，用于在浏览器和Node.js中发送HTTP请求。它提供了一种简单的API，用于发送GET、POST、PUT、DELETE等类型的请求，并提供了一些可配置的选项，如请求头、超时、取消请求等。</p><p>以下是使用Axios发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送GET请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用axios.get()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p><p>以下是使用Axios发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送POST请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, requestData, &#123;<br><span class="hljs-attr">headers</span>: &#123;<br> <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用axios.post()方法发送了一个POST请求，并将请求体作为第二个参数传递。我们还通过第三个参数指定了请求头。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p><p>需要注意的是，Axios默认情况下会将响应的主体解析为JSON格式，但是如果响应的Content-Type头部不是application&#x2F;json，Axios将不会自动解析JSON数据。如果需要解析其他格式的数据，需要使用其他解析库或手动解析数据。</p></blockquote><h3 id="42-什么是跨域？"><a href="#42-什么是跨域？" class="headerlink" title="42.什么是跨域？"></a>42.什么是跨域？</h3><blockquote><p>跨域（Cross-Origin）是指在浏览器中，一个网页的脚本试图访问不同源（协议、域名或端口）的资源时，就会发生跨域问题。这是由浏览器的同源策略（Same-Origin Policy）导致的，同源策略是一种安全机制，用于防止恶意网站窃取用户数据。</p><p>同源策略要求一个网页的脚本只能与同一源（协议、域名和端口）的资源进行交互。如果脚本试图与不同源的资源进行交互，浏览器就会拒绝请求。例如，一个网页的脚本在example.com域名下运行，试图向api.example.net域名下的API发送请求，这就是跨域请求，浏览器将不会允许这个请求。</p><p>需要注意的是，跨域问题只存在于浏览器环境中，如果是在服务器端发送请求，则不存在跨域问题。因为服务器端不存在同源策略的限制，可以访问任何资源。</p></blockquote><h3 id="43-如何解决跨域问题？"><a href="#43-如何解决跨域问题？" class="headerlink" title="43.如何解决跨域问题？"></a>43.如何解决跨域问题？</h3><blockquote><p>以下是一些解决跨域问题的常用方法：</p><ol><li><p>CORS（Cross-Origin Resource Sharing）：使用CORS，服务器可以发送一个响应头，允许浏览器从不同的源请求资源。CORS需要在服务器端进行配置，通常是在响应头中添加Access-Control-Allow-Origin、Access-Control-Allow-Methods等相关的头信息。</p></li><li><p>JSONP（JSON with Padding）：JSONP是一种使用script元素发送GET请求的技术，由于脚本元素不受同源策略的限制，可以加载任何域名下的JavaScript脚本。使用JSONP，可以将回调函数名作为参数传递给服务器，服务器在返回数据时将数据作为参数传递给回调函数。</p></li><li><p>代理服务器：可以设置一个代理服务器，将客户端请求发送到代理服务器，由代理服务器转发请求到目标服务器，再将目标服务器返回的数据转发给客户端。由于代理服务器是在同一域名下运行的，因此不存在跨域问题。</p></li><li><p>WebSocket：WebSocket是一种全双工通信协议，它可以在不同源之间建立持久连接，可以用于客户端与服务器之间的实时通信，避免了跨域问题。</p></li><li><p>postMessage API：postMessage API可以在不同源之间进行通信，通过在不同窗口之间传递消息，可以实现跨域通信。这种方法需要目标窗口同意，才能进行通信。</p></li></ol><p>需要根据实际情况选择合适的解决方案，其中CORS和代理服务器是最常用的解决方案。</p></blockquote><h3 id="44-什么是事件循环？"><a href="#44-什么是事件循环？" class="headerlink" title="44.什么是事件循环？"></a>44.什么是事件循环？</h3><blockquote><p>事件循环（Event Loop）是JavaScript的一种机制，用于处理异步事件。JavaScript是单线程的，所有任务都在一个线程中执行，包括用户界面操作、计时器事件和网络请求等操作。如果所有任务都是同步的，那么它们将按照代码的书写顺序执行。但是，当涉及到异步任务时，任务的执行顺序就不是确定的，这时就需要事件循环机制来协调任务的执行。</p><p>事件循环通过维护一个事件队列（Event Queue）来管理任务的执行顺序。当任务执行时，如果任务是同步的，则会立即执行并将结果返回，如果任务是异步的，则会将任务加入事件队列中，并继续执行下一个任务。当任务队列为空时，事件循环会等待新的任务加入队列，直到有新的任务加入。</p><p>事件循环机制中的事件队列包括宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）两种。宏任务队列包括定时器事件、I&#x2F;O事件和事件回调等异步任务，而微任务队列则包括Promise和process.nextTick等异步任务。事件循环会先执行微任务队列中的所有任务，然后再执行宏任务队列中的任务。</p><p>事件循环的机制非常重要，因为它决定了异步任务的执行顺序和优先级，理解事件循环机制对于开发高效的JavaScript应用程序非常重要。</p></blockquote><h3 id="45-什么是同步代码？"><a href="#45-什么是同步代码？" class="headerlink" title="45.什么是同步代码？"></a>45.什么是同步代码？</h3><blockquote><p>同步代码是指按照代码的书写顺序依次执行的代码，每个任务必须等待前一个任务完成才能执行。在JavaScript中，通常情况下代码都是同步执行的，例如以下代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，console.log()函数会按照代码的书写顺序依次执行，并输出A、B和C。</p><p>同步代码执行时会阻塞程序的执行，直到当前任务完成，才会执行下一个任务。这意味着如果某个任务执行时间很长，那么整个程序的执行将会被阻塞，用户界面也会变得不响应。</p><p>为了避免长时间的阻塞，可以使用异步代码，将一些耗时的任务放入事件队列中，等待异步处理。当异步任务完成后，事件循环会将其加入执行队列中，优先级高的任务先执行，从而保证程序的响应性和效率。</p></blockquote><h3 id="46-什么是异步代码？"><a href="#46-什么是异步代码？" class="headerlink" title="46.什么是异步代码？"></a>46.什么是异步代码？</h3><blockquote><p>异步代码是指不按照代码书写顺序执行的代码，它们的执行顺序是由事件循环机制控制的。异步代码在执行时不会阻塞程序的执行，因此可以提高程序的效率和响应性。</p><p>在JavaScript中，异步代码通常使用回调函数、Promise、async&#x2F;await等方式来实现。例如，以下代码展示了一个使用回调函数的异步代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，setTimeout函数用于延迟执行，当计时器到期时，事件循环会将回调函数加入执行队列中，从而实现异步执行。由于回调函数是异步执行的，因此会在后台执行，不会阻塞程序的执行。</p><p>异步代码的特点是代码执行不会阻塞程序的执行，可以提高程序的效率和响应性。但是，异步代码的执行顺序是不确定的，需要使用事件循环机制来协调任务的执行。因此，在编写异步代码时需要注意回调函数的使用，避免回调地狱等问题。</p></blockquote><h3 id="47-如何在JavaScript中处理异步代码？"><a href="#47-如何在JavaScript中处理异步代码？" class="headerlink" title="47.如何在JavaScript中处理异步代码？"></a>47.如何在JavaScript中处理异步代码？</h3><blockquote><p>在JavaScript中，处理异步代码通常使用以下三种方式：</p><ol><li>回调函数：回调函数是一种异步编程的基础方式，它是一个作为参数传递给另一个函数的函数，用于在异步任务完成后执行。回调函数的实现通常使用匿名函数或命名函数，例如：</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    callback(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br>asyncFunction(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数是一个异步函数，它接受一个回调函数作为参数，在异步操作完成后执行回调函数。当异步操作完成后，回调函数会被调用，并传递结果参数result。</p><ol start="2"><li>Promise：Promise是一种更加现代化的异步处理方式，它用于处理复杂的异步操作，可以使用链式调用的方式处理多个异步操作。Promise的使用通常分为三个状态：pending、fulfilled和rejected，分别表示异步操作正在进行、异步操作已成功完成和异步操作已失败。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">asyncFunction</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数返回一个Promise对象，异步操作完成后使用resolve方法将结果传递给then方法的回调函数。</p><ol start="3"><li>async&#x2F;await：async&#x2F;await是一种更加简洁和直观的异步处理方式，它基于Promise实现，可以使用同步的方式编写异步代码。async函数用于定义异步函数，await用于暂停代码的执行，等待Promise对象的状态改变。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;<br><br><span class="hljs-title function_">asyncFunction</span>();<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数使用async关键字定义异步函数，await暂停代码的执行，等待Promise对象的状态改变。当Promise对象的状态为fulfilled时，结果会被赋值给result变量，并输出到控制台。</p><p>以上三种方式都可以用于处理异步代码，在实际应用中可以根据具体的场景和需求选择合适的方式。</p></blockquote><h3 id="48-什么是防抖？"><a href="#48-什么是防抖？" class="headerlink" title="48.什么是防抖？"></a>48.什么是防抖？</h3><blockquote><p>在前端开发中，防抖（Debouncing）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p><p>防抖的实现方式是设置一个定时器，当函数被调用时，如果定时器已经存在，则清除定时器并重新设置一个新的定时器，等待一定时间后再执行函数。如果在定时器等待的时间内再次调用了该函数，则会重新设置定时器，并等待一定时间后再次执行函数。如果在定时器等待的时间内没有再次调用该函数，则定时器会到期并执行函数。</p><p>防抖的应用场景包括：</p><ol><li><p>搜索框输入联想功能：在用户输入关键字时，如果每输入一个字符就向服务器发送请求，则会导致频繁的网络请求，影响性能和用户体验。使用防抖可以限制请求的频率，只在用户停止输入一段时间后再向服务器发送请求。</p></li><li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用防抖可以限制计算的频率，只在窗口停止调整一段时间后再重新计算。</p></li></ol><p>防抖的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span><span class="hljs-params">(func, delay)</span> &#123;<br>  let timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    clearTimeout(timer);<br>    timer = setTimeout(() =&gt; &#123;<br>      func.apply(<span class="hljs-keyword">this</span>, args);<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用debounce函数</span><br><span class="hljs-keyword">const</span> debouncedFunc = debounce(<span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，debounce函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间之后执行func函数。如果在延迟时间内再次调用该函数，则清除定时器并重新设置一个新的定时器，等待延迟时间后再次执行函数。调用debounce函数后返回一个新的函数debouncedFunc，该函数可以在需要防抖的地方使用。</p></blockquote><h3 id="49-什么是节流？"><a href="#49-什么是节流？" class="headerlink" title="49.什么是节流？"></a>49.什么是节流？</h3><blockquote><p>在前端开发中，节流（Throttling）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p><p>节流的实现方式是设置一个定时器，在定时器等待的时间内只允许函数执行一次，等待时间结束后再次允许函数执行。如果在等待时间内再次调用该函数，则该调用会被忽略。这样可以有效减少函数被调用的次数，提高应用程序的性能和响应速度。</p><p>节流的应用场景包括：</p><ol><li><p>滚动事件：在处理滚动事件时，如果每次滚动都处理一次事件，则会导致频繁的计算和渲染，影响性能和用户体验。使用节流可以限制事件的处理频率，只在一段时间内处理一次事件。</p></li><li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用节流可以限制计算的频率，只在一段时间内重新计算一次。</p></li></ol><p>节流的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span><span class="hljs-params">(func, delay)</span> &#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        func.apply(<span class="hljs-keyword">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用throttle函数</span><br><span class="hljs-keyword">const</span> throttledFunc = throttle(<span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，throttle函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。调用throttle函数后返回一个新的函数throttledFunc，该函数可以在需要节流的地方使用。</p></blockquote><h3 id="50-如何实现防抖和节流？"><a href="#50-如何实现防抖和节流？" class="headerlink" title="50.如何实现防抖和节流？"></a>50.如何实现防抖和节流？</h3><blockquote><p>防抖和节流是优化前端性能的两种常用方法，它们都通过限制函数的执行次数来减少计算和渲染次数，提高页面性能和响应速度。</p><p>以下是防抖和节流的实现方法：</p><p>防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br><span class="hljs-keyword">let</span> timer;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br> <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br> &#125;, delay);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> debouncedFunc = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，debounce函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数会使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则会清除之前的计时器并重新设置计时器，等待一定时间后执行函数。</p><p>节流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br><span class="hljs-keyword">let</span> timer;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br> <span class="hljs-keyword">if</span> (!timer) &#123;<br>   timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>     timer = <span class="hljs-literal">null</span>;<br>   &#125;, delay);<br> &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> throttledFunc = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，throttle函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。</p><p>使用防抖和节流可以有效地减少函数的执行次数，提高页面性能和响应速度。需要根据具体场景选择合适的优化方法，并根据实际情况调整延迟时间来达到最优化的效果。</p></blockquote><h3 id="51-什么是深拷贝和浅拷贝？"><a href="#51-什么是深拷贝和浅拷贝？" class="headerlink" title="51.什么是深拷贝和浅拷贝？"></a>51.什么是深拷贝和浅拷贝？</h3><blockquote><p>深拷贝和浅拷贝是JavaScript中常用的两种复制对象的方式，它们之间的区别在于拷贝出的对象是否是对原始对象的完全独立拷贝。</p><p>浅拷贝指的是只复制原始对象的引用，而不是复制对象本身。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象会共享同一份数据，对拷贝出的新对象的修改会影响到原始对象，反之亦然。</p><p>以下是一个浅拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br>copy.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用Object.assign方法将原始对象obj的属性复制到一个新的对象中，并将这个新对象赋值给变量copy。由于浅拷贝的特性，copy.b和obj.b指向同一个对象，因此当我们修改copy.b.c时，obj.b.c的值也会相应地改变。</p><p>深拷贝指的是复制对象本身，而不是复制对象的引用。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象是完全独立的，对拷贝出的新对象的修改不会影响到原始对象，反之亦然。</p><p>以下是一个深拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br> <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br> <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>   copy[key] = <span class="hljs-title function_">deepCopy</span>(obj[key]);<br> &#125;<br>&#125;<br><span class="hljs-keyword">return</span> copy;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">deepCopy</span>(obj);<br>copy.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用递归方式实现了一个深拷贝的函数deepCopy，该函数会遍历原始对象的每一个属性，当遇到一个对象类型的属性时，会递归地调用自身来复制这个对象。由于深拷贝的特性，copy.b和obj.b指向两个不同的对象，因此当我们修改copy.b.c时，obj.b.c的值不会改变。</p></blockquote><h3 id="52-如何实现深拷贝和浅拷贝？"><a href="#52-如何实现深拷贝和浅拷贝？" class="headerlink" title="52.如何实现深拷贝和浅拷贝？"></a>52.如何实现深拷贝和浅拷贝？</h3><blockquote><p>JavaScript 中的深拷贝和浅拷贝可以使用以下方式实现：</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝只复制对象的一层属性，而不复制对象的子对象。</p><ol><li>使用 ES6 中的 Object.assign() 方法进行浅拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用展开运算符（spread operator）进行浅拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝复制整个对象及其子对象，不会对原对象造成影响。</p><ol><li>使用 JSON.parse() 和 JSON.stringify() 方法进行深拷贝（需要注意的是，该方法无法处理函数等特殊类型的数据）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: &#123; b: 1 &#125; &#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用递归方式进行深拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      result[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title function_">deepClone</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: &#123; b: 1 &#125; &#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="53-什么是Event-Loop？"><a href="#53-什么是Event-Loop？" class="headerlink" title="53.什么是Event Loop？"></a>53.什么是Event Loop？</h3><blockquote><p>Event Loop（事件循环）是 JavaScript 中的一个机制，它负责协调调度所有的任务（包括异步任务和同步任务），确保它们按照正确的顺序执行。Event Loop 是 JavaScript 运行时环境的一部分，不同的运行时环境（如浏览器和 Node.js）可能有不同的实现方式，但基本原理是相同的。</p><p>在 JavaScript 中，任务分为同步任务和异步任务，同步任务会在调用栈中按顺序执行，而异步任务则会被放到消息队列中，等待 Event Loop 将其取出执行。</p><p>当调用栈中的所有同步任务执行完毕后，Event Loop 会检查消息队列中是否有待执行的异步任务，如果有，就将其从队列中取出放到调用栈中执行。在执行完异步任务后，又会检查消息队列中是否有待执行的任务，依次重复上述步骤。</p><p>由于 JavaScript 是单线程的语言，只有一个调用栈，所以 Event Loop 的机制使得 JavaScript 能够处理异步任务而不会阻塞调用栈的执行。这也是 JavaScript 能够处理大量 I&#x2F;O 操作的关键之一，例如 Ajax 请求、定时器等异步任务。</p></blockquote><h3 id="54-什么是JavaScript的执行上下文？"><a href="#54-什么是JavaScript的执行上下文？" class="headerlink" title="54.什么是JavaScript的执行上下文？"></a>54.什么是JavaScript的执行上下文？</h3><blockquote><p>在 JavaScript 中，执行上下文是指当前代码执行的环境，包括变量、函数、参数等。每当 JavaScript 引擎执行一段代码时，都会创建一个新的执行上下文，用来存储代码执行过程中的各种信息。</p><p>JavaScript 的执行上下文可以分为三种类型：</p><ol><li><p>全局执行上下文：当 JavaScript 代码第一次被解析和执行时，就会创建一个全局执行上下文，该执行上下文的作用域链包含全局变量对象和全局对象。</p></li><li><p>函数执行上下文：当 JavaScript 解析器进入函数时，就会创建一个新的函数执行上下文，该执行上下文的作用域链包含函数的活动对象、函数对象本身以及全局对象。</p></li><li><p>eval 执行上下文：当 JavaScript 解析器遇到 eval 函数时，会创建一个新的执行上下文，该执行上下文的作用域链包含 eval 函数的活动对象、全局对象以及外部函数的活动对象。</p></li></ol><p>执行上下文有三个重要的属性：</p><ol><li><p>变量对象（VO）：变量对象是执行上下文中的一个重要概念，用来存储函数中定义的变量和函数声明。函数执行上下文的变量对象包括函数的所有参数、函数声明和变量声明。</p></li><li><p>作用域链（Scope Chain）：作用域链是一个由当前执行上下文的变量对象和所有外层执行上下文的变量对象组成的列表，用于解析变量和函数的引用。</p></li><li><p>this 值：this 值是指当前执行上下文的 this 指向的对象，它的值取决于函数的调用方式。</p></li></ol><p>理解执行上下文的概念和属性对于理解 JavaScript 的作用域和执行顺序非常重要。</p></blockquote><h3 id="55-什么是作用域？"><a href="#55-什么是作用域？" class="headerlink" title="55.什么是作用域？"></a>55.什么是作用域？</h3><blockquote><p>在 JavaScript 中，作用域是指变量、函数等命名实体的可访问范围。JavaScript 采用的是词法作用域，也就是静态作用域，即作用域在代码编写时就已经确定，而不是在运行时动态确定。</p><p>JavaScript 中有两种作用域：全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p><p>在 JavaScript 中，作用域的创建是通过函数和块级作用域（ES6 中引入）来实现的。当函数被调用时，会创建一个新的作用域，该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。而块级作用域是指在一对花括号 <code>&#123;&#125;</code> 中定义的变量或函数，只能在该块级作用域内部访问。</p><p>作用域的作用是防止命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，它是指由内向外依次连接起来的作用域列表。当访问一个变量或函数时，JavaScript 引擎会先在当前作用域中查找，如果找不到就会向上一级作用域中查找，直到找到该变量或函数为止。</p></blockquote><h3 id="56-JavaScript的作用域是如何工作的？"><a href="#56-JavaScript的作用域是如何工作的？" class="headerlink" title="56.JavaScript的作用域是如何工作的？"></a>56.JavaScript的作用域是如何工作的？</h3><blockquote><p>JavaScript 的作用域是通过词法作用域来实现的，也就是在代码编写时就已经确定了变量的作用域，而不是在运行时动态确定。</p><p>在 JavaScript 中，作用域分为全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p><p>当 JavaScript 解析器遇到一个函数时，会创建一个新的作用域，称为函数作用域。该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。如果在函数内部定义了一个变量，它就会覆盖同名的外部变量，而在函数外部则无法访问到该变量。</p><p>在函数作用域中，变量的查找是通过作用域链来实现的。作用域链是一个由内向外连接起来的作用域列表，它的顶端是当前函数的作用域，底部是全局作用域。当访问一个变量时，JavaScript 引擎会首先在当前作用域中查找，如果没有找到，则会向上一级作用域中查找，直到找到该变量或者抵达全局作用域。如果还没有找到该变量，则会抛出一个“变量未定义”的错误。</p><p>除了函数作用域外，ES6 中还引入了块级作用域，通过 <code>let</code> 和 <code>const</code> 关键字定义的变量就是块级作用域。块级作用域的变量只在块级作用域内部可见，超出该范围则无法访问。</p><p>总的来说，JavaScript 的作用域机制是为了避免命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，通过它可以实现变量的查找和访问。</p></blockquote><h3 id="57-什么是变量提升？"><a href="#57-什么是变量提升？" class="headerlink" title="57.什么是变量提升？"></a>57.什么是变量提升？</h3><blockquote><p>变量提升是 JavaScript 中的一种行为，指在代码执行之前，JavaScript 引擎会默认将所有变量的声明提升到它们所在的作用域的顶部。换句话说，变量声明会被提升到执行上下文的顶部，但是变量的赋值并不会被提升，赋值操作会按照代码的顺序执行。</p><p>例如，以下代码会输出 <code>undefined</code>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这是因为 JavaScript 引擎在执行代码之前会将变量 <code>a</code> 的声明提升到代码的顶部，因此在执行 <code>console.log(a)</code> 时，变量 <code>a</code> 已经被声明，但是并未被赋值，因此输出 <code>undefined</code>。</p><p>需要注意的是，只有变量声明会被提升，而变量赋值不会被提升。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(a)<span class="hljs-comment">; // ReferenceError: a is not defined</span><br>let a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>由于 <code>let</code> 声明的变量不会被提升，因此在执行 <code>console.log(a)</code> 时会抛出一个 <code>ReferenceError</code> 异常。</p><p>变量提升的机制虽然可以在一定程度上简化代码的书写，但是也容易引起混淆和错误，因此建议在代码中避免过度依赖变量提升，尽可能在变量使用之前进行声明和初始化。</p></blockquote><h3 id="58-如何避免变量提升？"><a href="#58-如何避免变量提升？" class="headerlink" title="58.如何避免变量提升？"></a>58.如何避免变量提升？</h3><blockquote><p>虽然变量提升是 JavaScript 的一种特性，但是可以通过以下几种方式来避免它带来的潜在问题：</p><ol><li><p>使用 <code>let</code> 或 <code>const</code> 关键字声明变量：<code>let</code> 和 <code>const</code> 声明的变量不会被提升，因此可以避免变量提升带来的问题。同时，使用 <code>let</code> 和 <code>const</code> 还可以避免变量重复声明和污染全局作用域的问题。</p></li><li><p>将变量声明和赋值分开：为了避免变量提升导致的混淆和错误，可以将变量声明和赋值分开，确保变量在使用前已经被正确地初始化。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let a<span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>console.log(a)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>使用模块化编程：使用模块化编程可以将代码分割成多个独立的模块，每个模块都有自己的作用域，变量不会污染全局作用域，也不会被其他模块访问到，从而避免了变量提升带来的问题。</p></li></ol><p>虽然变量提升可以带来一定的方便，但是建议在编写 JavaScript 代码时尽量避免过度依赖变量提升，以提高代码的可读性和可维护性。</p></blockquote><h3 id="59-什么是模板标签函数？"><a href="#59-什么是模板标签函数？" class="headerlink" title="59.什么是模板标签函数？"></a>59.什么是模板标签函数？</h3><blockquote><p>模板标签函数是一种 JavaScript 函数，可以用于自定义模板字符串的解析方式。模板标签函数的作用是将模板字符串解析成一个 JavaScript 对象，可以对模板字符串中的变量进行处理和格式化。</p><p>模板标签函数的定义方式是在模板字符串前面添加一个标识符，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myTag</span><span class="hljs-params">(strings, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br><span class="hljs-comment">// 处理模板字符串中的字符串和变量</span><br><span class="hljs-comment">// 返回一个处理后的结果</span><br>&#125;<br><br>let str = myTag`Hello, $&#123;name&#125;!`;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>myTag</code> 就是一个模板标签函数，它接收两个参数：<code>strings</code> 和 <code>values</code>。其中，<code>strings</code> 是一个数组，包含了模板字符串中的所有字符串；<code>values</code> 是一个数组，包含了模板字符串中所有的变量。可以根据需要对这些字符串和变量进行处理，最后返回一个处理后的结果。</p><p>使用模板标签函数可以实现一些特定的功能，例如格式化日期、国际化等。例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>let <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(values[<span class="hljs-number">0</span>]);<br>let <span class="hljs-built_in">year</span> = <span class="hljs-built_in">date</span>.getFullYear();<br>let <span class="hljs-built_in">month</span> = <span class="hljs-built_in">date</span>.getMonth() + <span class="hljs-number">1</span>;<br>let <span class="hljs-built_in">day</span> = <span class="hljs-built_in">date</span>.getDate();<br><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">year</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">month</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">day</span>&#125;</span>`</span>;<br>&#125;<br><br>let str = formatTime<span class="hljs-string">`The date is <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>()&#125;</span>`</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str); <span class="hljs-comment">// 输出：The date is 2023-5-10</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>formatTime</code> 是一个模板标签函数，它接收一个时间戳作为参数，将其转换成指定格式的日期字符串。使用模板标签函数可以实现一些常规的字符串处理操作，同时也可以扩展 JavaScript 的语法和功能。</p></blockquote><h3 id="60-如何使用标签模板？"><a href="#60-如何使用标签模板？" class="headerlink" title="60.如何使用标签模板？"></a>60.如何使用标签模板？</h3><h3 id="61-什么是迭代器？"><a href="#61-什么是迭代器？" class="headerlink" title="61.什么是迭代器？"></a>61.什么是迭代器？</h3><h3 id="62-如何使用迭代器？"><a href="#62-如何使用迭代器？" class="headerlink" title="62.如何使用迭代器？"></a>62.如何使用迭代器？</h3><h3 id="63-什么是生成器？"><a href="#63-什么是生成器？" class="headerlink" title="63.什么是生成器？"></a>63.什么是生成器？</h3><h3 id="64-如何使用生成器？"><a href="#64-如何使用生成器？" class="headerlink" title="64.如何使用生成器？"></a>64.如何使用生成器？</h3><h3 id="65-什么是可迭代对象？"><a href="#65-什么是可迭代对象？" class="headerlink" title="65.什么是可迭代对象？"></a>65.什么是可迭代对象？</h3><h3 id="66-如何创建可迭代对象？"><a href="#66-如何创建可迭代对象？" class="headerlink" title="66.如何创建可迭代对象？"></a>66.如何创建可迭代对象？</h3><h3 id="67-如何使用可迭代对象？"><a href="#67-如何使用可迭代对象？" class="headerlink" title="67.如何使用可迭代对象？"></a>67.如何使用可迭代对象？</h3><h3 id="68-什么是Promise-all？"><a href="#68-什么是Promise-all？" class="headerlink" title="68.什么是Promise.all？"></a>68.什么是Promise.all？</h3><h3 id="69-如何使用Promise-all？"><a href="#69-如何使用Promise-all？" class="headerlink" title="69.如何使用Promise.all？"></a>69.如何使用Promise.all？</h3><h3 id="70-什么是Promise-race？"><a href="#70-什么是Promise-race？" class="headerlink" title="70.什么是Promise.race？"></a>70.什么是Promise.race？</h3><h3 id="71-如何使用Promise-race？"><a href="#71-如何使用Promise-race？" class="headerlink" title="71.如何使用Promise.race？"></a>71.如何使用Promise.race？</h3><h3 id="72-什么是Symbol？"><a href="#72-什么是Symbol？" class="headerlink" title="72.什么是Symbol？"></a>72.什么是Symbol？</h3><h3 id="73-如何使用Symbol？"><a href="#73-如何使用Symbol？" class="headerlink" title="73.如何使用Symbol？"></a>73.如何使用Symbol？</h3><h3 id="74-什么是Proxy？"><a href="#74-什么是Proxy？" class="headerlink" title="74.什么是Proxy？"></a>74.什么是Proxy？</h3><h3 id="75-如何使用Proxy？"><a href="#75-如何使用Proxy？" class="headerlink" title="75.如何使用Proxy？"></a>75.如何使用Proxy？</h3><h3 id="76-什么是Reflect？"><a href="#76-什么是Reflect？" class="headerlink" title="76.什么是Reflect？"></a>76.什么是Reflect？</h3><h3 id="77-如何使用Reflect？"><a href="#77-如何使用Reflect？" class="headerlink" title="77.如何使用Reflect？"></a>77.如何使用Reflect？</h3><h3 id="78-什么是尾调用优化？"><a href="#78-什么是尾调用优化？" class="headerlink" title="78.什么是尾调用优化？"></a>78.什么是尾调用优化？</h3><h3 id="79-如何实现尾调用优化？"><a href="#79-如何实现尾调用优化？" class="headerlink" title="79.如何实现尾调用优化？"></a>79.如何实现尾调用优化？</h3><h3 id="80-如何禁用尾调用优化？"><a href="#80-如何禁用尾调用优化？" class="headerlink" title="80.如何禁用尾调用优化？"></a>80.如何禁用尾调用优化？</h3><h3 id="81-什么是柯里化？"><a href="#81-什么是柯里化？" class="headerlink" title="81.什么是柯里化？"></a>81.什么是柯里化？</h3><h3 id="82-如何实现柯里化？"><a href="#82-如何实现柯里化？" class="headerlink" title="82.如何实现柯里化？"></a>82.如何实现柯里化？</h3><h3 id="83-什么是函数组合？"><a href="#83-什么是函数组合？" class="headerlink" title="83.什么是函数组合？"></a>83.什么是函数组合？</h3><h3 id="84-如何实现函数组合？"><a href="#84-如何实现函数组合？" class="headerlink" title="84.如何实现函数组合？"></a>84.如何实现函数组合？</h3><h3 id="85-什么是函数式编程？"><a href="#85-什么是函数式编程？" class="headerlink" title="85.什么是函数式编程？"></a>85.什么是函数式编程？</h3><h3 id="86-如何在JavaScript中使用函数式编程？"><a href="#86-如何在JavaScript中使用函数式编程？" class="headerlink" title="86.如何在JavaScript中使用函数式编程？"></a>86.如何在JavaScript中使用函数式编程？</h3><h3 id="87-什么是纯函数？"><a href="#87-什么是纯函数？" class="headerlink" title="87.什么是纯函数？"></a>87.什么是纯函数？</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo Github 个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-winter</title>
    <link href="/2023/05/25/interview-winter/"/>
    <url>/2023/05/25/interview-winter/</url>
    
    <content type="html"><![CDATA[<h1 id="前端开发面试题"><a href="#前端开发面试题" class="headerlink" title="前端开发面试题"></a>前端开发面试题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a name="preface">前言</a></h2><p><a href="https://markyun.github.io/2015/Front-end-Developer-Questions/" title="Questions">只看问题点这里 </a></p><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" title="Questions-and-Answers">看全部问题和答案点这里</a></p><p>本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！</p><p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。</p><p>最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到<a href="http://markyun.github.io/">github博客</a>。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。</p><p><strong>面试有几点需注意：(来源<a href="http://weibo.com/wintercn" title="微博：寒冬winter">寒冬winter</a> 老师，github:@wintercn)</strong></p><p><img src="/2023/05/25/interview-winter/057.jpg"></p><ol><li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p></li><li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p></li><li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p></li><li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )）</p></li><li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p></li></ol><p><strong>前端开发所需掌握知识点概要：</strong></p><pre><code class="hljs">HTML&amp;CSS：    对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、    Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）；JavaScript：    数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、    内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、其他：    主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、    重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；</code></pre><p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：</p><p>此条由 王子墨 发表在 <a href="http://lab.yuanwai.wang/">攻城师的实验室</a></p><pre><code class="hljs">    1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。    2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。    3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。    4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。    5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。    6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型    7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们    8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。    9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。    10、JSON —— 作用、用途、设计结构。</code></pre><p><strong>备注：</strong></p><pre><code class="hljs">根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。更新记录：2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；2016-10-20： 更新一些已被发现的问题。2016-03-25： 新增ECMAScript6 相关问题</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><a name="html">HTML</a></h2><ul><li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p><pre><code class="hljs">  （1）、&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。    （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</code></pre></li><li><p>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>？</p><pre><code class="hljs">   HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；   而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</code></pre></li><li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p><pre><code class="hljs">  首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。    （1）行内元素有：a b span img input select strong（强调的语气）  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p    （3）常见的空元素：      &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;      鲜为人知的是：      &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;    不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异  参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</code></pre></li><li><p>页面导入样式时，使用link和@import有什么区别？</p><pre><code class="hljs">  （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;  （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;      (4)link支持使用js控制DOM去改变样式，而@import不支持;</code></pre></li><li><p>介绍一下你对浏览器内核的理解？</p><pre><code class="hljs">  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。    JS引擎则：解析和执行javascript来实现网页的动态效果。    最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</code></pre></li><li><p>常见的浏览器内核有哪些？</p><pre><code class="hljs">  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)</code></pre></li><li><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p><pre><code class="hljs">  * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。        绘画 canvas;        用于媒介回放的 video 和 audio 元素;        本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;        sessionStorage 的数据在浏览器关闭后自动删除;        语意化更好的内容元素，比如 article、footer、header、nav、section;        表单控件，calendar、date、time、email、url、search;        新的技术webworker, websocket, Geolocation;    移除的元素：        纯表现的元素：basefont，big，center，font, s，strike，tt，u;        对可用性产生负面影响的元素：frame，frameset，noframes；  * 支持HTML5新标签：       IE8/IE7/IE6支持通过document.createElement方法产生的标签，         可以利用这一特性让这些浏览器支持HTML5新标签，         浏览器支持新标签后，还需要添加标签默认的样式。       当然也可以直接使用成熟的框架、比如html5shim;       &lt;!--[if lt IE 9]&gt;          &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;       &lt;![endif]--&gt;  * 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</code></pre></li><li><p>简述一下你对HTML语义化的理解？</p><pre><code class="hljs">  用正确的标签做正确的事情。  html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;  即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;  搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;  使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre></li><li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p><pre><code class="hljs">  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。  如何使用：  1、页面头部像下面一样加入一个manifest的属性；  2、在cache.manifest文件的编写离线存储的资源；      CACHE MANIFEST      #v0.11      CACHE:      js/app.js      css/style.css      NETWORK:      resourse/logo.png      FALLBACK:      / /offline.html  3、在离线状态时，操作window.applicationCache进行需求实现。</code></pre><p>  详细的使用请参考：</p><p>  <a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/">HTML5 离线缓存-manifest简介</a></p><p>  <a href="http://segmentfault.com/a/1190000000732617">有趣的HTML5：离线存储</a></p></li><li><p>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</p><pre><code class="hljs">  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。  离线的情况下，浏览器就直接使用离线存储的资源。</code></pre><p>  详细请参考：<a href="http://segmentfault.com/a/1190000000732617">有趣的HTML5：离线存储</a></p></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p><pre><code class="hljs">  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。    存储大小：      cookie数据大小不能超过4k。      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。    有期时间：      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；      sessionStorage  数据在当前浏览器窗口关闭后自动删除。      cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</code></pre></li><li><p>iframe有那些缺点？</p><pre><code class="hljs">  *iframe会阻塞主页面的Onload事件；  *搜索引擎的检索程序无法解读这种页面，不利于SEO;    *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。    使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript  动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre></li><li><p>Label的作用是什么？是怎么用的？</p><pre><code class="hljs">  label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;  &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;    &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</code></pre></li><li><p>HTML5的form如何关闭自动完成功能？</p><pre><code class="hljs">  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</code></pre></li><li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p><pre><code class="hljs">  WebSocket、SharedWorker；  也可以调用localstorge、cookies等本地存储方式；    localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，  我们通过监听事件，控制它的值来进行页面信息通信；  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</code></pre></li><li><p>webSocket如何兼容低浏览器？(阿里)</p><pre><code class="hljs">  Adobe Flash Socket 、  ActiveX HTMLFile (IE) 、  基于 multipart 编码发送 XHR 、  基于长轮询的 XHR</code></pre></li><li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p><pre><code class="hljs">  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</code></pre></li><li><p>如何在页面上实现一个圆形的可点击区域？</p><pre><code class="hljs">  1、map+area或者svg  2、border-radius  3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</code></pre></li><li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p><pre><code class="hljs">  &lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p><pre><code class="hljs">  区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；  有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</code></pre></li><li><p>title与h1的区别、b与strong的区别、i与em的区别？</p><pre><code class="hljs">  title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；    strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。    i内容展示为斜体，em表示强调的文本；    Physical Style Elements -- 自然样式标签  b, i, u, s, pre  Semantic Style Elements -- 语义样式标签  strong, em, ins, del, code  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</code></pre></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a name="css">CSS</a></h2><ul><li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p><pre><code class="hljs">  （1）有两种， IE 盒子模型、W3C 盒子模型；  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；  （3）区  别： IE的content部分把 border 和 padding计算了进去;</code></pre></li><li><p>CSS选择符有哪些？哪些属性可以继承？</p><pre><code class="hljs">  *   1.id选择器（ # myid）      2.类选择器（.myclassname）      3.标签选择器（div, h1, p）      4.相邻选择器（h1 + p）      5.子选择器（ul &gt; li）      6.后代选择器（li a）      7.通配符选择器（ * ）      8.属性选择器（a[rel = &quot;external&quot;]）      9.伪类选择器（a:hover, li:nth-child）    *   可继承的样式： font-size font-family color, UL LI DL DD DT;    *   不可继承的样式：border padding margin width height ;</code></pre></li><li><p>CSS优先级算法如何计算？</p><pre><code class="hljs">  *   优先级就近原则，同权重情况下样式定义最近者为准;  *   载入样式以最后载入的定位为准;    优先级为:      同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。      !important &gt;  id &gt; class &gt; tag      important 比 内联优先级高</code></pre></li><li><p>CSS3新增伪类有那些？</p><pre><code class="hljs">      举例：      p:first-of-type选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:last-of-type选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-of-type选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-child选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。      p:nth-child(2)选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。        ::after在元素之前添加内容,也可以用来做清除浮动。      ::before在元素之后添加内容      :enabled        :disabled 控制表单控件的禁用状态。      :checked        单选框或复选框被选中。</code></pre></li><li><p>如何居中div？</p><ul><li><p>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</p><pre><code class="hljs"> div&#123;     width:200px;     margin:0 auto;  &#125;</code></pre></li><li><p>让绝对定位的div居中</p><pre><code class="hljs"> div &#123;     position: absolute;     width: 300px;     height: 300px;     margin: auto;     top: 0;     left: 0;     bottom: 0;     right: 0;     background-color: pink;/* 方便看效果 */ &#125;</code></pre></li><li><p>水平垂直居中一</p><pre><code class="hljs"> 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div &#123;     position: relative;/* 相对定位或绝对定位均可 */     width:500px;     height:300px;     top: 50%;     left: 50%;     margin: -150px 0 0 -250px;     /* 外边距为自身宽高的一半 */     background-color: pink; /* 方便看效果 */  &#125;</code></pre></li><li><p>水平垂直居中二</p><pre><code class="hljs"> 未知容器的宽高，利用 `transform` 属性 div &#123;     position: absolute;/* 相对定位或绝对定位均可 */     width:500px;     height:300px;     top: 50%;     left: 50%;     transform: translate(-50%, -50%);     background-color: pink; /* 方便看效果 */ &#125;</code></pre></li><li><p>水平垂直居中三</p><pre><code class="hljs"> 利用 flex 布局 实际使用时应考虑兼容性 .container &#123;     display: flex;     align-items: center; /* 垂直居中 */     justify-content: center;/* 水平居中 */ &#125; .container div &#123;     width: 100px;     height: 100px;     background-color: pink;/* 方便看效果 */ &#125;</code></pre></li></ul></li><li><p>display有哪些值？说明他们的作用。</p><pre><code class="hljs">    block       块类型。默认宽度为父元素宽度，可设置宽高，换行显示。    none        元素不显示，并从文档流中移除。    inline      行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。    inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。    list-item   象块类型元素一样显示，并添加样式列表标记。    table       此元素会作为块级表格来显示。    inherit     规定应该从父元素继承 display 属性的值。</code></pre></li><li><p>position的值relative和absolute定位原点是？</p><pre><code class="hljs">    absolute      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。    fixed （老IE不支持）      生成绝对定位的元素，相对于浏览器窗口进行定位。    relative      生成相对定位的元素，相对于其正常位置进行定位。    static      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。    inherit      规定从父元素继承 position 属性的值。</code></pre></li><li><p>CSS3有哪些新特性？</p><pre><code class="hljs">    新增各种CSS选择器（: not(.input)：所有 class 不是“input”的节点）        圆角    （border-radius:8px）    多列布局    （multi-column layout）    阴影和反射（Shadow\Reflect）    文字特效（text-shadow、）    文字渲染（Text-decoration）    线性渐变（gradient）    旋转 （transform）    缩放,定位,倾斜,动画,多背景    例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></pre></li><li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p><pre><code class="hljs">   一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。   采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。   在布局上有了比以前更加灵活的空间。   具体：http://www.w3cplus.com/css3/flexbox-basics.html</code></pre></li><li><p>用纯CSS创建一个三角形的原理是什么？</p><pre><code class="hljs">  把上、左、右三条边隐藏掉（颜色设为 transparent）  #demo &#123;    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;  &#125;</code></pre></li><li><p>一个满屏 品 字布局 如何设计?</p><pre><code class="hljs">  简单的方式：      上面的div宽100%，      下面的两个div分别宽50%，      然后用float或者inline使其不换行即可</code></pre></li><li><p>css多列等高如何实现？</p><pre><code class="hljs">  利用padding-bottom|margin-bottom正负值相抵；  设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，  当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，  其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</code></pre></li><li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p><pre><code class="hljs">  * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.    * 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。    * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。      浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;      这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)      渐进识别的方式，从总体中逐渐排除局部。      首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。      css        .bb&#123;            background-color:red;/*所有识别*/            background-color:#00deff\9; /*IE6、7、8识别*/            +background-color:#a200ff;/*IE6、7识别*/            _background-color:#1e0bd1;/*IE6识别*/        &#125;  *  IE下,可以使用获取常规属性的方法来获取自定义属性,     也可以使用getAttribute()获取自定义属性;     Firefox下,只能使用getAttribute()获取自定义属性。     解决方法:统一通过getAttribute()获取自定义属性。  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;     Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。  超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:  L-V-H-A :  a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;</code></pre></li><li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p><pre><code class="hljs">  行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</code></pre></li><li><p>为什么要初始化CSS样式。</p><pre><code class="hljs">  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。    - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。    最简单的初始化方法： * &#123;padding: 0; margin: 0;&#125; （强烈不建议）    淘宝的样式初始化代码：  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;  body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;  h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;  address, cite, dfn, em, var &#123; font-style:normal; &#125;  code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;  small&#123; font-size:12px; &#125;  ul, ol &#123; list-style:none; &#125;  a &#123; text-decoration:none; &#125;  a:hover &#123; text-decoration:underline; &#125;  sup &#123; vertical-align:text-top; &#125;  sub&#123; vertical-align:text-bottom; &#125;  legend &#123; color:#000; &#125;  fieldset, img &#123; border:0; &#125;  button, input, select, textarea &#123; font-size:100%; &#125;  table &#123; border-collapse:collapse; border-spacing:0; &#125;</code></pre></li><li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p><pre><code class="hljs">  无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：  1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；  2、否则,则由这个祖先元素的 padding box 构成。  如果都找不到，则为 initial containing block。    补充：  1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）  2. absolute: 向上找最近的定位为absolute/relative的元素  3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</code></pre></li><li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p><p>  对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.<br>  如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.<br>  仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</p></li><li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p><p>  如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠.</p></li><li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p><pre><code class="hljs">  （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</code></pre></li><li><p>css定义的权重</p><pre><code class="hljs">  以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：    /*权重为1*/  div&#123;  &#125;  /*权重为10*/  .class1&#123;  &#125;  /*权重为100*/  #id1&#123;  &#125;  /*权重为100+1=101*/  #id1 div&#123;  &#125;  /*权重为10+1=11*/  .class1 div&#123;  &#125;  /*权重为10+10+1=21*/  .class1 .class2 div&#123;  &#125;    如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre></li><li><p>请解释一下为什么需要清除浮动？清除浮动的方式</p><p>  清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><pre><code class="hljs">  1、父级div定义height；  2、父级div 也一起浮动；  3、常规的使用一个class；      .clearfix::before, .clearfix::after &#123;          content: &quot; &quot;;          display: table;      &#125;      .clearfix::after &#123;          clear: both;      &#125;      .clearfix &#123;          *zoom: 1;      &#125;    4、SASS编译的时候，浮动元素的父级div定义伪类:after      &amp;::after,&amp;::before&#123;          content: &quot; &quot;;          visibility: hidden;          display: block;          height: 0;          clear: both;      &#125;    解析原理：  1) display:block 使生成的元素以块级元素显示,占满剩余空间;  2) height:0 避免生成内容破坏原有布局的高度。  3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;  4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙；  5）zoom：1 触发IE hasLayout。    通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。</code></pre></li><li><p>什么是外边距合并？</p><pre><code class="hljs">  外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp</code></pre></li><li><p>zoom:1的清除浮动原理?</p><pre><code class="hljs">  清除浮动，触发hasLayout；  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。    来龙去脉大概如下：  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。    Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。    目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？  可以通过css3里面的动画属性scale进行缩放。</code></pre></li><li><p>移动端的布局用过媒体查询吗？</p><p>  假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，<br>  而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p>  <!-- link元素中的CSS媒体查询 --><p>  当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。<br>  当媒体查询返回假， <link> 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。</p>  <link rel="stylesheet" media="(max-width: 800px)" href="example.css">    <!-- 样式表中的CSS媒体查询 --><p>  包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。<br>  CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p>  <style>      @media (min-width: 700px) and (orientation: landscape){        .sidebar {          display: none;        }      }  </style></li><li><p>使用 CSS 预处理器吗？喜欢那个？</p><pre><code class="hljs">  SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</code></pre></li><li><p>CSS优化、提高性能的方法有哪些？</p><pre><code class="hljs">  关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；  如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；  提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;  使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；</code></pre></li><li><p>浏览器是怎样解析CSS选择器的？</p><pre><code class="hljs">  样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。  只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</code></pre></li><li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p></li><li><p>margin和padding分别适合什么场景使用？</p><pre><code class="hljs">  margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。  margin用于布局分开元素使元素与元素互不相干；  padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</code></pre></li><li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p></li><li><p>元素竖向的百分比设定是相对于容器的高度吗？</p></li><li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p></li><li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p></li><li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p></li><li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p><pre><code class="hljs">  单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，  比如:first-line、:first-letter、:before、:after等，  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。    想让插入的内容出现在其它内容前，使用::before，否者，使用::after；  在代码顺序上，::after生成的内容也比::before生成的内容靠后。  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</code></pre></li><li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p><pre><code class="hljs">  input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123;    background-color: rgb(250, 255, 189); /* #FAFFBD; */    background-image: none;    color: rgb(0, 0, 0);  &#125;</code></pre></li><li><p>你对line-height是如何理解的？</p></li><li><p>设置元素浮动后，该元素的display值是多少？</p><pre><code class="hljs">  自动变成了 display:block</code></pre></li><li><p>怎么让Chrome支持小于12px 的文字？</p><pre><code class="hljs">  1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。  2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。  3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。  4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</code></pre></li><li><p>让页面里的字体变清晰，变细用CSS怎么做？</p><pre><code class="hljs">  -webkit-font-smoothing: antialiased;</code></pre></li><li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p><pre><code class="hljs">  倾斜的字体样式</code></pre></li><li><p>position:fixed;在android下无效怎么处理？</p><pre><code class="hljs">  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，  原来的网页还好好的在那，fixed的内容也没有变过位置，  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></pre></li><li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p><pre><code class="hljs">  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</code></pre></li><li><p>display:inline-block 什么时候会显示间隙？(携程)</p><pre><code class="hljs">  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</code></pre></li><li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p></li><li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p></li><li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p></li><li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p><pre><code class="hljs">  如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，  所以不如隔离开。    因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，  这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。    同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，  提高了webserver的http请求的解析速度。</code></pre></li><li><p>style标签写在body后与body前有什么区别？</p></li><li><p>什么是CSS 预处理器 &#x2F; 后处理器？</p><pre><code class="hljs">  - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。    - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</code></pre></li><li><p>rem布局的优缺点</p></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a name="js">JavaScript</a></h2><ul><li><p>介绍js的基本数据类型。</p><pre><code class="hljs">  Undefined、Null、Boolean、Number、String、  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</code></pre></li><li><p>介绍js有哪些内置对象？</p><pre><code class="hljs"> Object 是 JavaScript 中所有对象的父对象  数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error  参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html</code></pre></li><li><p>说几条写JavaScript的基本规范？</p><pre><code class="hljs"> 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre></li><li><p>JavaScript原型，原型链 ? 有什么特点？</p><pre><code class="hljs"> 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.__proto__  特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。  当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。     function Func()&#123;&#125;     Func.prototype.name = &quot;Sean&quot;;     Func.prototype.getInfo = function() &#123;       return this.name;     &#125;     var person = new Func();//现在可以参考var person = Object.create(oldObject);     console.log(person.getInfo());//它拥有了Func的属性和方法     //&quot;Sean&quot;     console.log(Func.prototype);     // Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125;</code></pre></li><li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p><pre><code class="hljs"> 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数）  两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</code></pre><p> <img src="http://www.w3school.com.cn/i/ct_js_value.gif" alt="Stated Clearly Image"></p></li><li><p>如何将字符串转化为数字，例如’12.3b’?</p><pre><code class="hljs">  * parseFloat(&#39;12.3b&#39;);  * 正则表达式，&#39;12.3b&#39;.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</code></pre></li><li><p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p><pre><code class="hljs">  function commafy(num)&#123;      return num &amp;&amp; num          .toString()          .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123;              return $2 + &#39;,&#39;;          &#125;);  &#125;</code></pre></li><li><p>如何实现数组的随机排序？</p><pre><code class="hljs">  方法一：      var arr = [1,2,3,4,5,6,7,8,9,10];      function randSort1(arr)&#123;          for(var i = 0,len = arr.length;i &lt; len; i++ )&#123;              var rand = parseInt(Math.random()*len);              var temp = arr[rand];              arr[rand] = arr[i];              arr[i] = temp;          &#125;          return arr;      &#125;      console.log(randSort1(arr));        方法二：      var arr = [1,2,3,4,5,6,7,8,9,10];      function randSort2(arr)&#123;          var mixedArray = [];          while(arr.length &gt; 0)&#123;              var randomIndex = parseInt(Math.random()*arr.length);              mixedArray.push(arr[randomIndex]);              arr.splice(randomIndex, 1);          &#125;          return mixedArray;      &#125;      console.log(randSort2(arr));    方法三：      var arr = [1,2,3,4,5,6,7,8,9,10];      arr.sort(function()&#123;          return Math.random() - 0.5;      &#125;)      console.log(arr);</code></pre></li><li><p>Javascript如何实现继承？</p><pre><code class="hljs"> 1、构造继承 2、原型继承 3、实例继承 4、拷贝继承  原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。      function Parent()&#123;         this.name = &#39;wang&#39;;     &#125;      function Child()&#123;         this.age = 28;     &#125;     Child.prototype = new Parent();//继承了Parent，通过原型      var demo = new Child();     alert(demo.age);     alert(demo.name);//得到被继承的属性</code></pre></li><li><p>JavaScript继承的几种实现方式？</p><ul><li>参考：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">构造函数的继承</a>，<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">非构造函数的继承</a>；</li></ul></li><li><p>javascript创建对象的几种方式？</p><pre><code class="hljs"> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式     person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;; 2、用function来模拟无参的构造函数     function Person()&#123;&#125;     var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class     person.name=&quot;Mark&quot;;     person.age=&quot;25&quot;;     person.work=function()&#123;     alert(person.name+&quot; hello...&quot;);     &#125;     person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）     function Pet(name,age,hobby)&#123;        this.name=name;//this作用域：当前对象        this.age=age;        this.hobby=hobby;        this.eat=function()&#123;           alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);        &#125;     &#125;     var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象     maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象）      var wcDog =new Object();      wcDog.name=&quot;旺财&quot;;      wcDog.age=3;      wcDog.work=function()&#123;        alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);      &#125;      wcDog.work(); 5、用原型方式来创建     function Dog()&#123;      &#125;      Dog.prototype.name=&quot;旺财&quot;;      Dog.prototype.eat=function()&#123;      alert(this.name+&quot;是个吃货&quot;);      &#125;      var wangcai =new Dog();      wangcai.eat(); 5、用混合方式来创建     function Car(name,price)&#123;       this.name=name;       this.price=price;     &#125;      Car.prototype.sell=function()&#123;        alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);       &#125;     var camry =new Car(&quot;凯美瑞&quot;,27);     camry.sell();</code></pre></li><li><p>Javascript作用链域?</p><pre><code class="hljs"> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</code></pre></li><li><p>谈谈This对象的理解。</p> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">   <span class="hljs-built_in">this</span>总是指向函数的直接调用者（而非间接调用者）；<br>如果有<span class="hljs-keyword">new</span><span class="hljs-type"></span>关键字，<span class="hljs-built_in">this</span>指向<span class="hljs-keyword">new</span><span class="hljs-type"></span>出来的那个对象；<br>在事件中，<span class="hljs-built_in">this</span>指向触发这个事件的对象，特殊的是，IE中的attachEvent中的<span class="hljs-built_in">this</span>总是指向全局对象Window；<br></code></pre></td></tr></table></figure></li><li><p>eval是做什么的？</p><pre><code class="hljs"> 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code></pre></li><li><p>什么是window对象? 什么是document对象?</p><pre><code class="hljs"> window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</code></pre></li><li><p>null，undefined 的区别？</p><pre><code class="hljs"> null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)；  undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined     //&quot;undefined&quot;     undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；     例如变量被声明了，但没有赋值时，就等于undefined typeof null     //&quot;object&quot;     null : 是一个对象(空对象, 没有任何属性和方法)；     例如作为函数的参数，表示该函数的参数不是对象； 注意：     在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined     null == undefined // true     null === undefined // false 再来一个例子：     null     Q：有张三这个人么？     A：有！     Q：张三有房子么？     A：没有！     undefined     Q：有张三这个人么？     A：有！     Q: 张三有多少岁？     A: 不知道（没有被告诉）</code></pre><p> 参考阅读：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">undefined与null的区别</a></p></li><li><p>写一个通用的事件侦听器函数。</p><pre><code class="hljs">     // event(事件)工具集，来源：github.com/markyun     markyun.Event = &#123;         // 页面加载完成后         readyEvent : function(fn) &#123;             if (fn==null) &#123;                 fn=document;             &#125;             var oldonload = window.onload;             if (typeof window.onload != &#39;function&#39;) &#123;                 window.onload = fn;             &#125; else &#123;                 window.onload = function() &#123;                     oldonload();                     fn();                 &#125;;             &#125;         &#125;,         // 视能力分别使用dom0||dom2||IE方式 来绑定事件         // 参数： 操作的元素,事件名称 ,事件处理程序         addEvent : function(element, type, handler) &#123;             if (element.addEventListener) &#123;                 //事件类型、需要执行的函数、是否捕捉                 element.addEventListener(type, handler, false);             &#125; else if (element.attachEvent) &#123;                 element.attachEvent(&#39;on&#39; + type, function() &#123;                     handler.call(element);                 &#125;);             &#125; else &#123;                 element[&#39;on&#39; + type] = handler;             &#125;         &#125;,         // 移除事件         removeEvent : function(element, type, handler) &#123;             if (element.removeEventListener) &#123;                 element.removeEventListener(type, handler, false);             &#125; else if (element.datachEvent) &#123;                 element.detachEvent(&#39;on&#39; + type, handler);             &#125; else &#123;                 element[&#39;on&#39; + type] = null;             &#125;         &#125;,         // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)         stopPropagation : function(ev) &#123;             if (ev.stopPropagation) &#123;                 ev.stopPropagation();             &#125; else &#123;                 ev.cancelBubble = true;             &#125;         &#125;,         // 取消事件的默认行为         preventDefault : function(event) &#123;             if (event.preventDefault) &#123;                 event.preventDefault();             &#125; else &#123;                 event.returnValue = false;             &#125;         &#125;,         // 获取事件目标         getTarget : function(event) &#123;             return event.target || event.srcElement;         &#125;,         // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；         getEvent : function(e) &#123;             var ev = e || window.event;             if (!ev) &#123;                 var c = this.getEvent.caller;                 while (c) &#123;                     ev = c.arguments[0];                     if (ev &amp;&amp; Event == ev.constructor) &#123;                         break;                     &#125;                     c = c.caller;                 &#125;             &#125;             return ev;         &#125;     &#125;;</code></pre></li><li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p><pre><code class="hljs"> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)， 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】; 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。  function parseInt(str, radix) &#123;     return str+&#39;-&#39;+radix; &#125;; var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; a.map(parseInt);  // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix  因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN]  详细解析：http://blog.csdn.net/justjavac/article/details/19473199</code></pre></li><li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p><pre><code class="hljs">  1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。  2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；  3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</code></pre></li><li><p>什么是闭包（closure），为什么要用它？</p><pre><code class="hljs"> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。  闭包的特性：  1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收  //li节点的onclick事件都能正确的弹出当前被点击的li索引  &lt;ul id=&quot;testUL&quot;&gt;     &lt;li&gt; index = 0&lt;/li&gt;     &lt;li&gt; index = 1&lt;/li&gt;     &lt;li&gt; index = 2&lt;/li&gt;     &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt;       var nodes = document.getElementsByTagName(&quot;li&quot;);     for(i = 0;i&lt;nodes.length;i+= 1)&#123;         nodes[i].onclick = (function(i)&#123;                   return function() &#123;                      console.log(i);                   &#125; //不用闭包的话，值每次都是4                 &#125;)(i);     &#125; &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在 使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源 因为say667()的内部函数的执行需要依赖say667()中的变量 这是对闭包作用的非常直白的描述   function say667() &#123;     // Local variable that ends up within closure     var num = 666;     var sayAlert = function() &#123;         alert(num);     &#125;     num++;     return sayAlert; &#125;  var sayAlert = say667();  sayAlert()//执行结果应该弹出的667</code></pre></li><li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p><pre><code class="hljs"> use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,  使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;  提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。</code></pre></li><li><p>如何判断一个对象是否属于某个类？</p><pre><code class="hljs">    使用instanceof （待完善）     if(a instanceof Person)&#123;         alert(&#39;yes&#39;);     &#125;</code></pre></li><li><p>new操作符具体干了什么呢?</p><pre><code class="hljs">      1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。      2、属性和方法被加入到 this 引用的对象中。       3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj  = &#123;&#125;; obj.__proto__ = Base.prototype; Base.call(obj);</code></pre></li><li><p>用原生JavaScript的实现过什么功能吗？</p></li><li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p><pre><code class="hljs"> hasOwnProperty  javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。  如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</code></pre></li><li><p>JSON 的了解？</p><pre><code class="hljs"> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 如：&#123;&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;&#125;  JSON字符串转换为JSON对象: var obj =eval(&#39;(&#39;+ str +&#39;)&#39;); var obj = str.parseJSON(); var obj = JSON.parse(str);  JSON对象转换为JSON字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj);</code></pre></li><li><p><code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</p></li><li><p>js延迟加载的方式有哪些？</p><pre><code class="hljs"> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</code></pre></li><li><p>Ajax 是什么? 如何创建一个Ajax？</p><pre><code class="hljs"> ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。  (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新</code></pre></li><li><p>Ajax 解决浏览器缓存问题？</p><pre><code class="hljs">  1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。  2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。  3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。    4、在URL后面加上时间戳：&quot;nowtime=&quot; + new Date().getTime();。    5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup(&#123;cache:false&#125;)。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</code></pre></li><li><p>同步和异步的区别?</p><p> 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p><p> 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</p><p> 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><p> （待完善）</p></li><li><p>如何解决跨域问题?</p><pre><code class="hljs"> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</code></pre></li><li><p>页面编码和被请求的资源编码如果不一致如何处理？</p></li><li><p>服务器代理转发时，该如何处理cookie？</p><pre><code class="hljs"> nginx</code></pre></li><li><p>模块化开发怎么做？</p><p>  <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/"> 立即执行函数</a>,不暴露私有成员</p><pre><code class="hljs">     var module1 = (function()&#123;     　　　　var _count = 0;     　　　　var m1 = function()&#123;     　　　　　　//...     　　　　&#125;;     　　　　var m2 = function()&#123;     　　　　　　//...     　　　　&#125;;     　　　　return &#123;     　　　　　　m1 : m1,     　　　　　　m2 : m2     　　　　&#125;;     　　&#125;)();</code></pre><p> （待完善）</p></li><li><p>AMD（Modules&#x2F;Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p><blockquote><p>AMD 规范在这里：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p></blockquote><blockquote><p>CMD 规范在这里：<a href="https://github.com/seajs/seajs/issues/242">https://github.com/seajs/seajs/issues/242</a></p></blockquote><pre><code class="hljs"> Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。   区别：      1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：  // CMD define(function(require, exports, module) &#123;     var a = require(&#39;./a&#39;)     a.doSomething()     // 此处略去 100 行     var b = require(&#39;./b&#39;) // 依赖可以就近书写     b.doSomething()     // ... &#125;)  // AMD 默认推荐 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) &#123; // 依赖必须一开始就写好     a.doSomething()     // 此处略去 100 行     b.doSomething()     // ... &#125;)</code></pre></li><li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p><pre><code class="hljs"> 参考：http://annn.me/how-to-realize-cmd-loader/</code></pre></li><li><p>JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</p></li><li><p>谈一谈你对ECMAScript6的了解？</p></li><li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西?</p></li><li><p>异步加载JS的方式有哪些？</p><pre><code class="hljs">   (1) defer，只支持IE        (2) async：        (3) 创建script，插入到DOM中，加载完毕后callBack</code></pre></li><li><p>documen.write和 innerHTML的区别</p><pre><code class="hljs">  document.write只能重绘整个页面    innerHTML可以重绘页面的一部分</code></pre></li><li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p><pre><code class="hljs">  （1）创建新节点    createDocumentFragment()    //创建一个DOM片段    createElement()   //创建一个具体的元素    createTextNode()   //创建一个文本节点  （2）添加、移除、替换、插入    appendChild()    removeChild()    replaceChild()    insertBefore() //在已有的子节点前插入一个新的子节点  （3）查找    getElementsByTagName()    //通过标签名称    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)    getElementById()    //通过元素Id，唯一性</code></pre></li><li><p>.call() 和 .apply() 的区别？</p><pre><code class="hljs">   例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);   注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。     function add(a,b)     &#123;         alert(a+b);     &#125;     function sub(a,b)     &#123;         alert(a-b);     &#125;     add.call(sub,3,1);</code></pre></li><li><p>数组和对象有哪些原生方法，列举一下？</p></li><li><p>JS 怎么实现一个类。怎么实例化这个类</p></li><li><p>JavaScript中的作用域与变量声明提升？</p></li><li><p>如何编写高性能的Javascript？</p></li><li><p>那些操作会造成内存泄漏？</p></li><li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p></li><li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p></li><li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p></li><li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</p></li><li><p>jquery.extend 与 jquery.fn.extend的区别？</p><pre><code class="hljs"> * jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 * jquery.fn.extend:     源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</code></pre></li><li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p></li><li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p></li><li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p></li><li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p></li><li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p></li><li><p>针对 jQuery性能的优化方法？</p></li><li><p>Jquery与jQuery UI 有啥区别？</p><pre><code class="hljs"> *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。  提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</code></pre></li><li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p></li><li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p></li></ul><p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p><pre><code class="hljs">    $.fn.stringifyArray = function(array) &#123;        return JSON.stringify(array)    &#125;    $.fn.parseArray = function(array) &#123;        return JSON.parse(array)    &#125;    然后调用：    $(&quot;&quot;).stringifyArray(array)</code></pre><ul><li><p>jQuery和Zepto的区别？各自的使用场景？</p></li><li><p>针对 jQuery 的优化方法？</p><pre><code class="hljs"> *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。  比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); *for (var i = size; i &lt; arr.length; i++) &#123;&#125;  for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：  for (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125;</code></pre></li><li><p>Zepto的点透问题如何解决？</p></li><li><p>jQueryUI如何自定义组件?</p></li><li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p></li><li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p><pre><code class="hljs">  this === window ? &#39;browser&#39; : &#39;node&#39;;    通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</code></pre></li><li><p>移动端最小触控区域是多大？</p></li><li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p><pre><code class="hljs"> jquery stop(): 如：$(&quot;#div&quot;).stop().animate(&#123;width:&quot;100px&quot;&#125;,100);</code></pre></li><li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p></li><li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p></li><li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p></li><li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p></li><li><p>解释JavaScript中的作用域与变量声明提升？</p></li><li><p>那些操作会造成内存泄漏？</p><pre><code class="hljs"> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。  setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</code></pre></li><li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p><pre><code class="hljs"> * 多个事件同一个函数：     $(&quot;div&quot;).on(&quot;click mouseover&quot;, function()&#123;&#125;); * 多个事件不同函数     $(&quot;div&quot;).on(&#123;         click: function()&#123;&#125;,         mouseover: function()&#123;&#125;     &#125;);</code></pre></li><li><p>Node.js的适用场景？</p></li><li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p></li><li><p>解释一下 Backbone 的 MVC 实现方式？</p></li><li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p></li><li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p><pre><code class="hljs">  Chrome,Safari浏览器内核。</code></pre></li><li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p></li><li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p></li><li><p>简述一下 Handlebars 的基本用法？</p></li><li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p></li><li><p>用js实现千位分隔符?(来源：<a href="http://div.io/topic/744">前端农民工</a>，提示：正则+replace)</p><pre><code class="hljs">  参考：http://www.tuicool.com/articles/ArQZfui  function commafy(num) &#123;      return num &amp;&amp; num          .toString()          .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123;              return $1 + &quot;,&quot;;          &#125;);  &#125;  console.log(commafy(1234567.90)); //1,234,567.90</code></pre></li><li><p>检测浏览器版本版本有哪些方式？</p><pre><code class="hljs">  功能检测、userAgent特征检测    比如：navigator.userAgent  //&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36    (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</code></pre></li><li><p>What is a Polyfill?</p><pre><code class="hljs">  polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。  例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，  所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，  一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</code></pre></li><li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p><pre><code class="hljs">  比如： html5shiv、Geolocation、Placeholder</code></pre></li><li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p></li><li><p>使用JS实现获取文件扩展名？</p><pre><code class="hljs">  function getFileExtension(filename) &#123;    return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);  &#125;    String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。  对于&#39;filename&#39;和&#39;.hiddenfile&#39;，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。  String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</code></pre></li><li><p>Webpack热更新实现原理?</p><pre><code class="hljs">  1. Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)  2. 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端  3. 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash  4. 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端  5. 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档  6. hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</code></pre></li><li><p>请介绍一下JS之事件节流？</p></li><li><p>什么是JS的函数防抖？</p></li></ul><h4 id="ECMAScript6-相关"><a href="#ECMAScript6-相关" class="headerlink" title="ECMAScript6 相关"></a><a name="other">ECMAScript6 相关</a></h4><ul><li><p>Object.is() 与原来的比较操作符“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？</p><pre><code class="hljs">  两等号判等，会在比较时进行类型转换；  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；    Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，  但 Object.is(NaN, NaN) 会返回 true.   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre></li><li><p>ES6是如何实现编译成ES5的？</p></li><li><p>css-loader的原理？</p></li></ul><h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a><a name="other">前端框架</a></h2><ul><li><p>React 使用场景？</p><pre><code class="hljs">      逻辑复杂单页应用，偏中后台管理系统，纯展示性的UI页面不合适、</code></pre></li><li><p>描述一下React 生命周期</p><pre><code class="hljs">      渲染过程调用到的生命周期函数，主要几个要知道；      * constructor       * getInitialState       * getDefaultProps       * componentWillMount       * render       * componentDidMount       更新过程      * componentWillReceiveProps       * shouldComponentUpdate       * componentWillUpdate       * render       * componentDidUpdate       卸载过程      componentWillUnmount</code></pre></li><li><p>实现组件有哪些方式？</p><pre><code class="hljs">  React.createClass 使用API来定义组件  React ES6 class component 用 ES6 的class 来定义组件  Functional stateless component 通过函数定义无状态组件</code></pre></li><li><p>应该在React生命周期的什么阶段发出ajax请求，为什么？</p><pre><code class="hljs">          AJAX请求应在 componentDidMount函数 进行请求。</code></pre></li><li><p>shouldComponentUpdate函数有什么作用？</p><pre><code class="hljs">          shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI，          如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。 让shouldComponentUpdate返回falss, React就会让当前的组件和其子组件保持不变。</code></pre></li><li><p>当组件的setState函数被调用之后，发生了什么？</p><pre><code class="hljs">          React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，          尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，          React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，          并且知道如何只通过必要的更新来最小化重渲染。</code></pre></li><li><p>为什么循环产生的组件中要利用上key这个特殊的prop？</p><pre><code class="hljs">          Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。</code></pre></li><li><p>React-router 路由的实现原理？</p></li><li><p>说说React Native,Weex框架的实现原理？</p></li><li><p>受控组件(Controlled Component)与非受控组件(Uncontrolled Component)的区别</p></li><li><p>refs 是什么?</p><pre><code class="hljs">      Refs是能访问DOM元素或组件实例的一个函数；</code></pre></li><li><p>React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？</p></li><li><p>什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？</p><pre><code class="hljs">      组件用到了state或者用了生命周期函数，那么就该使用Class component。其他情况下，应使用Functional component。</code></pre></li><li><p>什么是HoC（Higher-Order Component）？适用于什么场景？</p><pre><code class="hljs">      高阶组件就是一个 React 组件包裹着另外一个 React 组件</code></pre></li><li><p>并不是父子关系的组件，如何实现相互的数据通信？</p><p>  ​​使用父组件，通过props将变量传入子组件 （如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件 ）</p></li><li><p>用过 React 技术栈中哪些数据流管理库？</p><pre><code class="hljs">      Redux\Dva</code></pre></li><li><p>Redux是如何做到可预测呢？</p></li><li><p>Redux将React组件划分为哪两种？</p></li><li><p>Redux是如何将state注入到React组件上的？</p></li><li><p>请描述一次完整的 Redux 数据流</p></li><li><p>React的批量更新机制 BatchUpdates？</p></li><li><p>React与Vue，各自的组件更新进行对比，它们有哪些区别？</p></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><a name="other">其他问题</a></h2><ul><li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何跨部门合作的？</p></li><li><p>你遇到过比较难的技术问题是？你是如何解决的？</p></li><li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p></li><li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p></li><li><p>页面重构怎么操作？</p><pre><code class="hljs">  网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。  也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。    对于传统的网站来说重构通常是：    表格(table)布局改为DIV+CSS  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)  对于移动平台的优化  针对于SEO进行优化  深层次的网站重构应该考虑的方面    减少代码间的耦合  让代码保持弹性  严格按规范编写代码  设计可扩展的API  代替旧有的框架、语言(如VB)  增强用户体验  通常来说对于速度的优化也包含在重构中    压缩JS、CSS、image等前端资源(通常是由服务器来解决)  程序的性能优化(如数据读写)  采用CDN来加速资源加载  对于JS DOM的优化  HTTP服务器的文件缓存</code></pre></li><li><p>列举IE与其他浏览器不一样的特性？</p><pre><code class="hljs">  1、事件不同之处：         触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；      获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；      阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；      停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</code></pre></li><li><p>99%的网站都需要被重构是那本书上写的？</p><pre><code class="hljs">  网站重构：应用web标准进行设计（第2版）</code></pre></li><li><p>什么叫优雅降级和渐进增强？</p><pre><code class="hljs">  优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。  如：border-shadow    渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。  如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</code></pre></li><li><p>是否了解公钥加密和私钥加密。</p><pre><code class="hljs">  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</code></pre></li><li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p><pre><code class="hljs">  html5提供的Websocket  不可见的iframe  WebSocket通过Flash  XHR长时间连接  XHR Multipart Streaming  &lt;script&gt;标签的长时间连接(可跨域)</code></pre></li><li><p>对Node的优点和缺点提出了自己的看法？</p><pre><code class="hljs">  *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。  *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</code></pre></li><li><p>你有用过哪些前端性能优化的方法？</p><pre><code class="hljs">    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数      （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。      （4） 当需要设置的样式很多时设置className而不是直接操作style。      （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。      （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。      （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。      （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</code></pre></li><li><p>http状态码有那些？分别代表是什么意思？</p><pre><code class="hljs">      简单版      [          100  Continue继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息          200  OK 正常返回信息          201  Created  请求成功并且服务器创建了新的资源          202  Accepted 服务器已接受请求，但尚未处理          301  Moved Permanently  请求的网页已永久移动到新位置。          302 Found  临时性重定向。          303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。          304  Not Modified 自从上次请求后，请求的网页未修改过。            400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。          401 Unauthorized 请求未授权。          403 Forbidden  禁止访问。          404 Not Found  找不到如何与 URI 相匹配的资源。            500 Internal Server Error  最常见的服务器端错误。          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。      ]      完整版    1**(信息类)：表示接收到请求并且继续处理      100——客户必须继续发出请求      101——客户要求服务器根据请求转换HTTP协议版本      2**(响应成功)：表示动作被成功接收、理解和接受      200——表明该请求被成功地完成，所请求的资源发送回客户端      201——提示知道新文件的URL      202——接受和处理、但处理未完成      203——返回信息不确定或不完整      204——请求收到，但返回信息为空      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件      206——服务器已经完成了部分用户的GET请求      3**(重定向类)：为了完成指定的动作，必须接受进一步处理      300——请求的资源可在多处得到      301——本网页被永久性转移到另一个URL      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。      303——建议客户访问其他URL或访问方式      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用      305——请求的资源必须从服务器指定的地址得到      306——前一版本HTTP中使用的代码，现行版本中不再使用      307——申明请求的资源临时性删除      4**(客户端错误类)：请求包含错误语法或不能正确执行      400——客户端请求有语法错误，不能被服务器所理解      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用      HTTP 401.1 - 未授权：登录失败      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败      　　HTTP 401.3 - ACL 禁止访问资源      　　HTTP 401.4 - 未授权：授权被筛选器拒绝      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败      402——保留有效ChargeTo头响应      403——禁止访问，服务器收到请求，但是拒绝提供服务      HTTP 403.1 禁止访问：禁止可执行访问      　　HTTP 403.2 - 禁止访问：禁止读访问      　　HTTP 403.3 - 禁止访问：禁止写访问      　　HTTP 403.4 - 禁止访问：要求 SSL      　　HTTP 403.5 - 禁止访问：要求 SSL 128      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝      　　HTTP 403.7 - 禁止访问：要求客户证书      　　HTTP 403.8 - 禁止访问：禁止站点访问      　　HTTP 403.9 - 禁止访问：连接的用户过多      　　HTTP 403.10 - 禁止访问：配置无效      　　HTTP 403.11 - 禁止访问：密码更改      　　HTTP 403.12 - 禁止访问：映射器拒绝访问      　　HTTP 403.13 - 禁止访问：客户证书已被吊销      　　HTTP 403.15 - 禁止访问：客户访问许可过多      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL      405——用户在Request-Line字段定义的方法不允许      406——根据用户发送的Accept拖，请求资源不可访问      407——类似401，用户必须首先在代理服务器上得到授权      408——客户端没有在用户指定的饿时间内完成请求      409——对当前资源状态，请求不能完成      410——服务器上不再有此资源且无进一步的参考地址      411——服务器拒绝用户定义的Content-Length属性请求      412——一个或多个请求头字段在当前请求中错误      413——请求的资源大于服务器允许的大小      414——请求的资源URL长于服务器允许的长度      415——请求资源不支持请求项目格式      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。      5**(服务端错误类)：服务器不能正确执行一个正确的请求      HTTP 500 - 服务器遇到错误，无法完成请求      　　HTTP 500.100 - 内部服务器错误 - ASP 错误      　　HTTP 500-11 服务器关闭      　　HTTP 500-12 应用程序重新启动      　　HTTP 500-13 - 服务器太忙      　　HTTP 500-14 - 应用程序无效      　　HTTP 500-15 - 不允许请求 global.asa      　　Error 501 - 未实现    HTTP 502 - 网关错误    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</code></pre></li><li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p><pre><code class="hljs">    注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，    而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、    到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；    详细版：      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;      4、进行HTTP协议会话，客户端发送报头(请求报头);      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。      简洁版：      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；      载入解析到的资源文件，渲染页面，完成。</code></pre></li><li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p></li><li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p></li><li><p>第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？</p><pre><code class="hljs">      localStorage</code></pre></li><li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p></li><li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p><pre><code class="hljs">  Sublime Text 3 + 插件  Google chrome 查看页面UI、动画效果和交互功能，Firebug 兼容测试和  Node.js + webpack  Git 版本控制和Code Review</code></pre></li><li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p><pre><code class="hljs">  前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。  1、实现界面交互  2、提升用户体验  3、有了Node.js，前端可以实现服务端的一些事情  前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，  参与项目，快速高质量完成实现效果图，精确到1px；  与团队成员，UI设计，产品经理的沟通；  做好的页面结构，页面重构和用户体验；  处理hack，兼容、写出优美的代码格式；  针对服务器的优化、拥抱最新前端技术。</code></pre></li><li><p>你怎么看待Web App 、hybrid App、Native App？</p></li><li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p></li><li><p>产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？</p><pre><code class="hljs">  非覆盖式发布，API新增而不是在原来的上面修改；  提前做好 @Deprecated的版本提示；</code></pre></li><li><p>你对加班的看法？</p><pre><code class="hljs">     加班就像借钱，原则应当是------救急不救穷</code></pre></li><li><p>平时如何管理你的项目？</p><pre><code class="hljs">  先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等；    编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；    标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；    页面进行标注（例如 页面 模块 开始和结束）；    CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；    JS 分文件夹存放 命名以该JS功能为准的英文翻译。    图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</code></pre></li><li><p>如何设计突发大规模并发架构？</p></li><li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p></li><li><p>说说最近最流行的一些东西吧？常去哪些网站？</p><pre><code class="hljs">      ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化</code></pre></li><li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p></li><li><p>移动端（Android IOS）怎么做好用户体验?</p><pre><code class="hljs">  清晰的视觉纵线、  信息的分组、极致的减法、  利用选择代替输入、  标签及文字的排布方式、  依靠明文确认密码、  合理的键盘利用、</code></pre></li><li><p>简单描述一下你做过的移动APP项目研发流程？</p></li><li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p></li><li><p>你认为怎样才是全端工程师（Full Stack developer）？</p></li><li><p>介绍一个你最得意的作品吧？</p></li><li><p>你有自己的技术博客吗，用了哪些技术？</p></li><li><p>对前端安全有什么看法？</p></li><li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p></li><li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p></li><li><p>最近在学什么东西？</p></li><li><p>你的优点是什么？缺点是什么？</p></li><li><p>如何管理前端团队?</p></li><li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p></li></ul><h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a><a name="web">前端学习网站推荐</a></h2><pre><code class="hljs">1. 极客标签：     http://www.gbtags.com/2. 码农周刊：     http://weekly.manong.io/issues/3. 前端周刊：     http://www.feweekly.com/issues4. 慕课网：       http://www.imooc.com/5. div.io： http://div.io6. Hacker News： https://news.ycombinator.com/news7. InfoQ：       http://www.infoq.com/8. w3cplus：     http://www.w3cplus.com/9. Stack Overflow： http://stackoverflow.com/10.w3school：    http://www.w3school.com.cn/11.mozilla：     https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</code></pre><h2 id="文档推荐"><a href="#文档推荐" class="headerlink" title="文档推荐"></a><a name="web">文档推荐</a></h2><ol><li><p><a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" title="jQuery 基本原理">jQuery 基本原理</a></p></li><li><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></p></li><li><p><a href="http://css.doyoe.com/">CSS参考手册</a></p></li><li><p><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程</a></p></li><li><p><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></p></li></ol><p><strong>备注：</strong></p><pre><code class="hljs">根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。在 github 项目的右上角，有三个按钮,分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰。当你选择Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了pull request、被发起了issue等情况你都会收到邮件通知。star相当于是点赞或收藏，方便以后查找。fork表示你想要补充完善这个项目的内容。更新记录：2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；2016-10-20： 更新一些已被发现的问题。2016-03-25： 新增ECMAScript6 相关问题</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2023/05/25/interview/"/>
    <url>/2023/05/25/interview/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-面试知识点总结"><a href="#JavaScript-面试知识点总结" class="headerlink" title="JavaScript 面试知识点总结"></a>JavaScript 面试知识点总结</h2><p>本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#1-%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 介绍 js 的基本数据类型。</a></li><li><a href="#2-javascript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</a></li><li><a href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li><li>(#4-内部属性-class-是什么)</li><li><a href="#5-%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">5. 介绍 js 有哪些内置对象？</a></li><li><a href="#6-undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB">6. undefined 与 undeclared 的区别？</a></li><li><a href="#7-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB">7. null 和 undefined 的区别？</a></li><li><a href="#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC">8. 如何获取安全的 undefined 值？</a></li><li><a href="#9-%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-javascript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">9. 说几条写 JavaScript 的基本规范？</a></li><li><a href="#10-javascript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">10. JavaScript 原型，原型链？ 有什么特点？</a></li><li><a href="#11-js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">11. js 获取原型的方法？</a></li><li><a href="#12-%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">12. 在 js 中不同进制数字的表示方式</a></li><li><a href="#13-js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91">13. js 中整数的安全范围是多少？</a></li><li><a href="#14-typeof-nan-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">14. typeof NaN 的结果是什么？</a></li><li><a href="#15-isnan-%E5%92%8C-numberisnan-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">15. isNaN 和 Number.isNaN 函数的区别？</a></li><li><a href="#16-array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0">16. Array 构造函数只有一个参数值时的表现？</a></li><li><a href="#17-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">17. 其他值到字符串的转换规则？</a></li><li><a href="#18-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">18. 其他值到数字值的转换规则？</a></li><li><a href="#19-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">19. 其他值到布尔类型的值的转换规则？</a></li><li><a href="#20--%E5%92%8C--%E7%9A%84-valueof-%E5%92%8C-tostring-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</a></li><li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1">21. 什么是假值对象？</a></li><li><a href="#22--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8">22. ~ 操作符的作用？</a></li><li><a href="#23-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</a></li><li><a href="#24--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5">24. 操作符什么时候用于字符串的拼接？</a></li><li><a href="#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">25. 什么情况下会发生布尔值的隐式强制类型转换？</a></li><li><a href="#26--%E5%92%8C--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">26. || 和 &amp;&amp; 操作符的返回值？</a></li><li><a href="#27-symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">27. Symbol 值的强制类型转换？</a></li><li><a href="#28--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">28. &#x3D;&#x3D; 操作符的强制类型转换规则？</a></li><li><a href="#29-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BE%8B%E5%A6%82-123b">29. 如何将字符串转化为数字，例如 ‘12.3b’?</a></li><li><a href="#30-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%E5%A6%821200000011%E8%BD%AC%E5%8C%96%E4%B8%BA1200000011">30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</a></li><li><a href="#31-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">31. 常用正则表达式</a></li><li><a href="#32-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95">32. 生成随机数的各种方法？</a></li><li><a href="#33-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">33. 如何实现数组的随机排序？</a></li><li><a href="#34-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">34. javascript 创建对象的几种方式？</a></li><li><a href="#35-javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">35. JavaScript 继承的几种实现方式？</a></li><li><a href="#36-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0">36. 寄生式组合继承的实现？</a></li><li><a href="#37-javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">37. Javascript 的作用域链？</a></li><li><a href="#38-%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">38. 谈谈 This 对象的理解。</a></li><li><a href="#39-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">39. eval 是做什么的？</a></li><li><a href="#40-%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">40. 什么是 DOM 和 BOM？</a></li><li><a href="#41-%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0">41. 写一个通用的事件侦听器函数。</a></li><li><a href="#42-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88ie-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li><li><a href="#43-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88">43. 三种事件模型是什么？</a></li><li><a href="#44-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88">44. 事件委托是什么？</a></li><li><a href="#45-1-2-3mapparseint-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91">45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</a></li><li><a href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83">46. 什么是闭包，为什么要用它？</a></li><li><a href="#47-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D--%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</a></li><li><a href="#48-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB">48. 如何判断一个对象是否属于某个类？</a></li><li><a href="#49-instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8">49. instanceof 的作用？</a></li><li><a href="#50-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">50. new 操作符具体干了什么呢？如何实现？</a></li><li><a href="#51-javascript%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li><li><a href="#52-%E5%AF%B9%E4%BA%8E-json-%E7%9A%84%E4%BA%86%E8%A7%A3">52. 对于 JSON 的了解？</a></li><li><a href="#53-foreachcallfunctionaastyleoutline1px-solid-mathrandom124tostring16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97">53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</a></li><li><a href="#54-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">54. js 延迟加载的方式有哪些？</a></li><li><a href="#55-ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAajax">55. Ajax 是什么? 如何创建一个 Ajax？</a></li><li><a href="#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">56. 谈一谈浏览器的缓存机制？</a></li><li><a href="#57-ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">57. Ajax 解决浏览器缓存问题？</a></li><li><a href="#58-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">58. 同步和异步的区别？</a></li><li><a href="#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96">59. 什么是浏览器的同源政策？</a></li><li><a href="#60-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">60. 如何解决跨域问题？</a></li><li><a href="#61-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie">61. 服务器代理转发时，该如何处理 cookie？</a></li><li><a href="#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-">62. 简单谈一下 cookie ？</a></li><li><a href="#63-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A">63. 模块化开发怎么做？</a></li><li><a href="#64-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">64. js 的几种模块规范？</a></li><li><a href="#65-amd-%E5%92%8C-cmd-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB">65. AMD 和 CMD 规范的区别？</a></li><li><a href="#66-es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</a></li><li><a href="#67-requirejs-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</a></li><li><a href="#68-js-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</a></li><li><a href="#69-ecmascript6-%E6%80%8E%E4%B9%88%E5%86%99-class%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</a></li><li><a href="#70-documenwrite-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">70. documen.write 和 innerHTML 的区别？</a></li><li><a href="#71-dom-%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9">71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="#72-innerhtml-%E4%B8%8E-outerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">72. innerHTML 与 outerHTML 的区别？</a></li><li><a href="#73-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">73. .call() 和 .apply() 的区别？</a></li><li><a href="#74-javascript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">74. JavaScript 类数组对象的定义？</a></li><li><a href="#75-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B">75. 数组和对象有哪些原生方法，列举一下？</a></li><li><a href="#76-%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95">76. 数组的 fill 方法？</a></li><li><a href="#77--%E7%9A%84%E9%95%BF%E5%BA%A6">77. [,,,] 的长度？</a></li><li><a href="#78-javascript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87">78. JavaScript 中的作用域与变量声明提升？</a></li><li><a href="#79-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-javascript-">79. 如何编写高性能的 Javascript ？</a></li><li><a href="#80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">80. 简单介绍一下 V8 引擎的垃圾回收机制</a></li><li><a href="#81-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">81. 哪些操作会造成内存泄漏？</a></li><li><a href="#82-%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</a></li><li><a href="#83-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%BF%E9%87%8C">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</a></li><li><a href="#84-%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</a></li><li><a href="#85-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li><li><a href="#86-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</a></li><li><a href="#87-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88-%E7%9F%A5%E9%81%93-bdd-tdd-unit-test-%E4%B9%88-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88mocha-sinon-jasmin-qunit">87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</a></li><li><a href="#88-%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">88. 检测浏览器版本版本有哪些方式？</a></li><li><a href="#89-%E4%BB%80%E4%B9%88%E6%98%AF-polyfill-">89. 什么是 Polyfill ？</a></li><li><a href="#90-%E4%BD%BF%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">90. 使用 JS 实现获取文件扩展名？</a></li><li><a href="#91-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">91. 介绍一下 js 的节流与防抖？</a></li><li><a href="#92-objectis-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6--%E7%9A%84%E5%8C%BA%E5%88%AB">92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</a></li><li><a href="#93-escapeencodeuriencodeuricomponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">93. escape,encodeURI,encodeURIComponent 有什么区别？</a></li><li><a href="#94-unicode-%E5%92%8C-utf-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">94. Unicode 和 UTF-8 之间的关系？</a></li><li><a href="#95-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88">95. js 的事件循环是什么？</a></li><li><a href="#96-js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0">96. js 中的深浅拷贝实现？</a></li><li><a href="#97-%E6%89%8B%E5%86%99-callapply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0">97. 手写 call、apply 及 bind 函数</a></li><li><a href="#98-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">98. 函数柯里化的实现</a></li><li><a href="#99-%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">99. 为什么 0.1 0.2 !&#x3D; 0.3？如何解决这个问题？</a></li><li><a href="#100-%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D">100. 原码、反码和补码的介绍</a></li><li><a href="#101-toprecision-%E5%92%8C-tofixed-%E5%92%8C-mathround-%E7%9A%84%E5%8C%BA%E5%88%AB">101. toPrecision 和 toFixed 和 Math.round 的区别？</a></li><li><a href="#102-%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</a></li><li><a href="#103-%E4%BB%80%E4%B9%88%E6%98%AF-csp">103. 什么是 CSP？</a></li><li><a href="#104-%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-csrf-%E6%94%BB%E5%87%BB">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</a></li><li><a href="#105-%E4%BB%80%E4%B9%88%E6%98%AF-samesite-cookie-%E5%B1%9E%E6%80%A7">105. 什么是 Samesite Cookie 属性？</a></li><li><a href="#106-%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">106. 什么是点击劫持？如何防范点击劫持？</a></li><li><a href="#107-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">107. SQL 注入攻击？</a></li><li><a href="#108-%E4%BB%80%E4%B9%88%E6%98%AF-mvvm%E6%AF%94%E4%B9%8B-mvc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-mvp-">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li><li><a href="#109-vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">109. vue 双向数据绑定原理？</a></li><li><a href="#110-objectdefineproperty-%E4%BB%8B%E7%BB%8D">110. Object.defineProperty 介绍？</a></li><li><a href="#111-%E4%BD%BF%E7%94%A8-objectdefineproperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li><a href="#112-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom%E4%B8%BA%E4%BB%80%E4%B9%88-virtual-dom-%E6%AF%94%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li><li><a href="#113-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-dom-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82">113. 如何比较两个 DOM 树的差异？</a></li><li><a href="#114-%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe-">114. 什么是 requestAnimationFrame ？</a></li><li><a href="#115-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95">115. 谈谈你对 webpack 的看法</a></li><li><a href="#116-offsetwidthoffsetheightclientwidthclientheight-%E4%B8%8E-scrollwidthscrollheight-%E7%9A%84%E5%8C%BA%E5%88%AB">116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</a></li><li><a href="#117-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">117. 谈一谈你理解的函数式编程？</a></li><li><a href="#118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">118. 异步编程的实现方式？</a></li><li><a href="#119-js-%E5%8A%A8%E7%94%BB%E4%B8%8E-css-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">119. Js 动画与 CSS 动画区别及相应实现</a></li><li><a href="#120-get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">120. get 请求传参长度的误区</a></li><li><a href="#121-url-%E5%92%8C-uri-%E7%9A%84%E5%8C%BA%E5%88%AB">121. URL 和 URI 的区别？</a></li><li><a href="#122-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">122. get 和 post 请求在缓存方面的区别</a></li><li><a href="#123-%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">123. 图片的懒加载和预加载</a></li><li><a href="#124-mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB">124. mouseover 和 mouseenter 的区别？</a></li><li><a href="#125-js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">125. js 拖拽功能的实现</a></li><li><a href="#126-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-settimeout-%E5%AE%9E%E7%8E%B0-setinterval%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li><li><a href="#127-let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">127. let 和 const 的注意点？</a></li><li><a href="#128-%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0">128. 什么是 rest 参数？</a></li><li><a href="#129-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">129. 什么是尾调用，使用尾调用有什么好处？</a></li><li><a href="#130-symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">130. Symbol 类型的注意点？</a></li><li><a href="#131-set-%E5%92%8C-weakset-%E7%BB%93%E6%9E%84">131. Set 和 WeakSet 结构？</a></li><li><a href="#132-map-%E5%92%8C-weakmap-%E7%BB%93%E6%9E%84">132. Map 和 WeakMap 结构？</a></li><li><a href="#133-%E4%BB%80%E4%B9%88%E6%98%AF-proxy-">133. 什么是 Proxy ？</a></li><li><a href="#134-reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84">134. Reflect 对象创建目的？</a></li><li><a href="#135-require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">135. require 模块引入的查找方式？</a></li><li><a href="#136-%E4%BB%80%E4%B9%88%E6%98%AF-promise-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%98%AF-promisesa-%E8%A7%84%E8%8C%83">136. 什么是 Promise 对象，什么是 Promises&#x2F;A 规范？</a></li><li><a href="#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise">137. 手写一个 Promise</a></li><li><a href="#138-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">138. 如何检测浏览器所支持的最小字体大小？</a></li><li><a href="#139-%E6%80%8E%E4%B9%88%E5%81%9A-js-%E4%BB%A3%E7%A0%81-error-%E7%BB%9F%E8%AE%A1">139. 怎么做 JS 代码 Error 统计？</a></li><li><a href="#140-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">140. 单例模式模式是什么？</a></li><li><a href="#141-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">141. 策略模式是什么？</a></li><li><a href="#142-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">142. 代理模式是什么？</a></li><li><a href="#143-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">143. 中介者模式是什么？</a></li><li><a href="#144-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">144. 适配器模式是什么？</a></li><li><a href="#145-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">145. 观察者模式和发布订阅模式有什么不同？</a></li><li><a href="#146-vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">146. Vue 的生命周期是什么？</a></li><li><a href="#147-vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88">147. Vue 的各个生命阶段是什么？</a></li><li><a href="#148-vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">148. Vue 组件间的参数传递方式？</a></li><li><a href="#149-computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82">149. computed 和 watch 的差异？</a></li><li><a href="#150-vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">150. vue-router 中的导航钩子函数</a></li><li><a href="#151-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">151. $route 和 $router 的区别？</a></li><li><a href="#152-vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">152. vue 常用的修饰符？</a></li><li><a href="#153-vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8">153. vue 中 key 值的作用？</a></li><li><a href="#154-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB">154. computed 和 watch 区别？</a></li><li><a href="#155-keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">155. keep-alive 组件有什么作用？</a></li><li><a href="#156-vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB">156. vue 中 mixin 和 mixins 区别？</a></li><li><a href="#157-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-content-type-">157. 开发中常用的几种 Content-Type ？</a></li><li><a href="#158-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0">158. 如何封装一个 javascript 的类型判断函数？</a></li><li><a href="#159-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1">159. 如何判断一个对象是否为空对象？</a></li><li><a href="#160-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1234">160. 使用闭包实现每隔一秒打印 1,2,3,4</a></li><li><a href="#161-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp">161. 手写一个 jsonp</a></li><li><a href="#162-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">162. 手写一个观察者模式？</a></li><li><a href="#163-eventemitter-%E5%AE%9E%E7%8E%B0">163. EventEmitter 实现</a></li><li><a href="#164-%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AFjs%E9%9D%A2%E8%AF%95%E9%A2%98">164. 一道常被人轻视的前端 JS 面试题</a></li><li><a href="#165-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%E4%BB%80%E4%B9%88%E6%98%AF-performance-api">165. 如何确定页面的可用性时间，什么是 Performance API？</a></li><li><a href="#166-js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">166. js 中的命名规则</a></li><li><a href="#167-js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">167. js 语句末尾分号是否可以省略？</a></li><li><a href="#168-objectassign">168. Object.assign()</a></li><li><a href="#169-mathceil-%E5%92%8C-mathfloor">169. Math.ceil 和 Math.floor</a></li><li><a href="#170-js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9">170. js for 循环注意点</a></li><li><a href="#171-%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%81%87%E8%AE%BE%E6%9C%89100000%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">171. 一个列表，假设有 100000 个数据，这个该怎么办？</a></li><li><a href="#172-js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0">172. js 中倒计时的纠偏实现？</a></li><li><a href="#173-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">173. 进程间通信的方式？</a></li><li><a href="#174-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">174. 如何查找一篇英文文章中出现频率最高的单词？</a></li><li><a href="#175-elegetelementsbyclassname%E5%92%8Celequeryselectorall%E7%9A%84%E5%8C%BA%E5%88%AB">175. ele.getElementsByClassName和ele.querySelectorAll的区别？</a></li></ul><h4 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 一共有五种基本数据类型，分别是 Undefined、Null、<span class="hljs-built_in">Boolean</span>、<span class="hljs-built_in">Number</span>、<span class="hljs-built_in">String</span>，还有在 ES6 中新增的 <span class="hljs-built_in">Symbol</span> 和 ES10 中新增的 <span class="hljs-built_in">BigInt</span> 类型。<br><span class="hljs-built_in">Symbol</span> 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br><span class="hljs-built_in">BigInt</span> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 <span class="hljs-built_in">BigInt</span> 可以安全地存储和操作大整数，即使这个数已经超出了 <span class="hljs-built_in">Number</span> 能够表示的安全整数范围。<br></code></pre></td></tr></table></figure><h4 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h4><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。<br><br>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<br>栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实<br>体。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br><br>基本数据类型....（参考<span class="hljs-number">1</span>）<br><br>复杂数据类型指的是 <span class="hljs-built_in">Object</span> 类型，所有其他的如 <span class="hljs-built_in">Array</span>、<span class="hljs-built_in">Date</span> 等数据类型都可以理解为 <span class="hljs-built_in">Object</span> 类型的子类。<br><br>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/lxcao/article/details/52749421">《JavaScript 有几种类型的值？》</a><br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h4 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">堆和栈的概念存在于数据结构中和操作系统内存中。<br><br>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>二叉树是堆的一种实现方式。<br><br>在操作系统中，内存被分为栈区和堆区。<br><br>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br><br>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h4 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 [[Class]] 是什么？"></a>4. 内部属性 [[Class]] 是什么？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">所有 <span class="hljs-keyword">typeof</span> 返回值为 <span class="hljs-string">&quot;object&quot;</span> 的对象（如数组）都包含一个内部属性 [[<span class="hljs-title class_">Class</span>]]（我们可以把它看作一个内部的分类，而非<br>传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(..) 来查看。例如：<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );<br><span class="hljs-comment">// &quot;[object Array]&quot;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-regexp">/regex-literal/i</span> );<br><span class="hljs-comment">// &quot;[object RegExp]&quot;</span><br><br><span class="hljs-comment">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="hljs-comment">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span> &#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class1</span>()); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// 需要定制[[Class]]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class2</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class2&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class2</span>()); <span class="hljs-comment">// &quot;[object Class2]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h4><p>涉及知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">全局的对象（ global objects ）或称标准内置对象，不要和 <span class="hljs-string">&quot;全局对象（global object）&quot;</span> 混淆。这里说的全局的对象是说在<br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。<br><br>标准内置对象的分类<br><br>（<span class="hljs-number">1</span>）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。<br><br>例如 <span class="hljs-literal">Infinity</span>、<span class="hljs-literal">NaN</span>、<span class="hljs-literal">undefined</span>、<span class="hljs-literal">null</span> 字面量<br><br>（<span class="hljs-number">2</span>）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。<br><br>例如 <span class="hljs-built_in">eval</span>()、<span class="hljs-built_in">parseFloat</span>()、<span class="hljs-built_in">parseInt</span>() 等<br><br>（<span class="hljs-number">3</span>）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。<br><br>例如 <span class="hljs-built_in">Object</span>、<span class="hljs-built_in">Function</span>、<span class="hljs-built_in">Boolean</span>、<span class="hljs-built_in">Symbol</span>、<span class="hljs-built_in">Error</span> 等<br><br>（<span class="hljs-number">4</span>）数字和日期对象，用来表示数字、日期和执行数学计算的对象。<br><br>例如 <span class="hljs-built_in">Number</span>、<span class="hljs-built_in">Math</span>、<span class="hljs-built_in">Date</span><br><br>（<span class="hljs-number">5</span>）字符串，用来表示和操作字符串的对象。<br><br>例如 <span class="hljs-built_in">String</span>、<span class="hljs-built_in">RegExp</span><br><br>（<span class="hljs-number">6</span>）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 <span class="hljs-built_in">Array</span><br><br>（<span class="hljs-number">7</span>）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br><br>例如 <span class="hljs-built_in">Map</span>、<span class="hljs-built_in">Set</span>、<span class="hljs-built_in">WeakMap</span>、<span class="hljs-built_in">WeakSet</span><br><br>（<span class="hljs-number">8</span>）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br><br>例如 SIMD 等<br><br>（<span class="hljs-number">9</span>）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 <span class="hljs-built_in">JSON</span> 编码的数据。<br><br>例如 <span class="hljs-built_in">JSON</span> 等<br><br>（<span class="hljs-number">10</span>）控制抽象对象<br><br>例如 <span class="hljs-built_in">Promise</span>、<span class="hljs-built_in">Generator</span> 等<br><br>（<span class="hljs-number">11</span>）反射<br><br>例如 <span class="hljs-built_in">Reflect</span>、<span class="hljs-built_in">Proxy</span><br><br>（<span class="hljs-number">12</span>）国际化，为了支持多语言处理而加入 ECMAScript 的对象。<br><br>例如 <span class="hljs-built_in">Intl</span>、<span class="hljs-built_in">Intl</span>.Collator 等<br><br>（<span class="hljs-number">13</span>）<span class="hljs-built_in">WebAssembly</span><br><br>（<span class="hljs-number">14</span>）其他<br><br>例如 arguments<br><br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函<br>数对象。一般我们经常用到的如全局变量值 <span class="hljs-literal">NaN</span>、<span class="hljs-literal">undefined</span>，全局函数如 <span class="hljs-built_in">parseInt</span>()、<span class="hljs-built_in">parseFloat</span>() 用来实例化对象的构<br>造函数如 <span class="hljs-built_in">Date</span>、<span class="hljs-built_in">Object</span> 等，还有提供数学计算的单体内置对象如 <span class="hljs-built_in">Math</span> 对象。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24">《JS 所有内置对象属性和方法汇总》</a></p><h4 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">已在作用域中声明但还没有赋值的变量，是 <span class="hljs-literal">undefined</span> 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。<br><br>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b <span class="hljs-keyword">is</span> not defined 。但是我们可以使用 typ<br>eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，<span class="hljs-keyword">typeof</span> 会返回 <span class="hljs-string">&quot;undefined&quot;</span>。<br></code></pre></td></tr></table></figure><h4 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">首先 <span class="hljs-literal">Undefined</span> 和 <span class="hljs-literal">Null</span> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <span class="hljs-literal">undefined</span> 和 <span class="hljs-literal">null</span>。<br><br><span class="hljs-literal">undefined</span> 代表的含义是未定义，<span class="hljs-literal">null</span> 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 <span class="hljs-literal">undefined</span>，<span class="hljs-literal">null</span><br>主要用于赋值给一些可能会返回对象的变量，作为初始化。<br><br><span class="hljs-literal">undefined</span> 在 js 中不是一个保留字，这意味着我们可以使用 <span class="hljs-literal">undefined</span> 来作为一个变量名，这样的做法是非常危险的，它<br>会影响我们对 <span class="hljs-literal">undefined</span> 值的判断。但是我们可以通过一些方法获得安全的 <span class="hljs-literal">undefined</span> 值，比如说 <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>。<br><br>当我们对两种类型使用 <span class="hljs-built_in">typeof</span> 进行判断的时候，<span class="hljs-literal">Null</span> 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等<br>号对两种类型的值进行比较时会返回 <span class="hljs-literal">true</span>，使用三个等号时会返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html">《JavaScript 深入理解之 undefined 与 null》</a></p><h4 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">因为 <span class="hljs-literal">undefined</span> 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 <span class="hljs-literal">undefined</span> 的正常判断。<br><br>表达式 <span class="hljs-keyword">void</span> ___ 没有返回值，因此返回结果是 <span class="hljs-literal">undefined</span>。<span class="hljs-keyword">void</span> 并不改变表达式的结果，只是让表达式不返回值。<br><br>按惯例我们用 <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> 来获得 <span class="hljs-literal">undefined</span>。<br></code></pre></td></tr></table></figure><h4 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">在平常项目开发中，我们遵守一些这样的基本规范，比如说：<br><br>（<span class="hljs-number">1</span>）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 <span class="hljs-keyword">var</span> 声明，不允许出现两个连续的 <span class="hljs-keyword">var</span> 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。<br><br>（<span class="hljs-number">2</span>）代码中出现地址、时间等字符串时需要使用常量代替。<br><br>（<span class="hljs-number">3</span>）在进行比较的时候吧，尽量使用<span class="hljs-string">&#x27;===&#x27;</span>, <span class="hljs-string">&#x27;!==&#x27;</span>代替<span class="hljs-string">&#x27;==&#x27;</span>, <span class="hljs-string">&#x27;!=&#x27;</span>。<br><br>（<span class="hljs-number">4</span>）不要在内置对象的原型上添加方法，如 <span class="hljs-title class_">Array</span>, <span class="hljs-title class_">Date</span>。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">switch</span> 语句必须带有 <span class="hljs-keyword">default</span> 分支。<br><br>（<span class="hljs-number">6</span>）<span class="hljs-keyword">for</span> 循环必须使用大括号。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">if</span> 语句必须使用大括号。<br></code></pre></td></tr></table></figure><h4 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 proto<span class="hljs-keyword">type</span> 属性值，这个属性值是一个对<br>象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部<br>将包含一个指针，这个指针指向构造函数的 proto<span class="hljs-keyword">type</span> 属性对应的值，在 <span class="hljs-type">ES5</span> 中这个指针被称为对象的原型。一般来说我们<br>是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这<br>个属性，因为它不是规范中规定的。<span class="hljs-type">ES5</span> 中新增了一个 <span class="hljs-type">Object</span>.getPrototypeOf() 方法，我们可以通过这个方法来获取对<br>象的原型。<br><br>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又<br>会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span> 所以这就<br>是我们新建的对象为什么能够使用 toString() 等方法的原因。<br><br>特点：<br><br><span class="hljs-type">JavaScript</span> 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与<br>之相关的对象也会继承这一改变。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p><h4 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h4><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h4 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h4><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h4 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 <span class="hljs-number">2</span>^<span class="hljs-number">53</span> - <span class="hljs-number">1</span>，<br>即<span class="hljs-number">9007199254740991</span>，在 ES6 中被定义为 <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER。最小整数是<span class="hljs-number">-9007199254740991</span>，在 ES6 中<br>被定义为 <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER。<br><br>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 <span class="hljs-literal">Infinity</span> 值。如果某次<br>计算返回了正或负的 <span class="hljs-literal">Infinity</span> 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 <span class="hljs-built_in">isFinite</span> 函数<br>来判断。<br></code></pre></td></tr></table></figure><h4 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> 意指“不是一个数字”（not a <span class="hljs-built_in">number</span>），<span class="hljs-literal">NaN</span> 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。<br><br><span class="hljs-built_in">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br><br><span class="hljs-literal">NaN</span> 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 <span class="hljs-literal">NaN</span> != <span class="hljs-literal">NaN</span><br>为 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><h4 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">函数 <span class="hljs-built_in">isNaN</span> 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 <span class="hljs-literal">true</span>，因此非数字值传入也会<br>返回 <span class="hljs-literal">true</span> ，会影响 <span class="hljs-literal">NaN</span> 的判断。<br><br>函数 <span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isNaN</span> 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 <span class="hljs-literal">NaN</span> ，这种方法对于 <span class="hljs-literal">NaN</span> 的判断更为<br>准确。<br></code></pre></td></tr></table></figure><h4 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Array</span> 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（<span class="hljs-built_in">length</span>），而非只充当数组中的一个元素。这样<br>创建出来的只是一个空数组，只不过它的 <span class="hljs-built_in">length</span> 属性被设置成了指定的值。<br><br>构造函数 <span class="hljs-built_in">Array</span>(..) 不要求必须带 <span class="hljs-keyword">new</span> 关键字。不带时，它会被自动补上。<br></code></pre></td></tr></table></figure><h4 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">规范的 <span class="hljs-number">9.8</span> 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。<br><br>（<span class="hljs-number">1</span>）<span class="hljs-literal">Null</span> 和 Undefined 类型 ，<span class="hljs-literal">null</span> 转换为 <span class="hljs-string">&quot;null&quot;</span>，undefined 转换为 <span class="hljs-string">&quot;undefined&quot;</span>，<br><br>（<span class="hljs-number">2</span>）Boolean 类型，<span class="hljs-literal">true</span> 转换为 <span class="hljs-string">&quot;true&quot;</span>，<span class="hljs-literal">false</span> 转换为 <span class="hljs-string">&quot;false&quot;</span>。<br><br>（<span class="hljs-number">3</span>）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。<br><br>（<span class="hljs-number">4</span>）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。<br><br>（<span class="hljs-number">5</span>）对普通对象来说，除非自行定义 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>() 方法，否则会调用 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>()（Object.prototype.<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>()）<br>    来返回内部属性 [[<span class="hljs-keyword">Class</span>]] 的值，如<span class="hljs-string">&quot;[object Object]&quot;</span>。如果对象有自己的 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>() 方法，字符串化时就会<br>    调用该方法并使用其返回值。<br></code></pre></td></tr></table></figure><h4 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss">有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 <span class="hljs-number">9.3</span> 节定义了抽象操作 ToNumber。<br><br>（<span class="hljs-number">1</span>）Undefined 类型的值转换为 NaN。<br><br>（<span class="hljs-number">2</span>）Null 类型的值转换为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">3</span>）Boolean 类型的值，true 转换为 <span class="hljs-number">1</span>，false 转换为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">4</span>）String 类型的值转换如同使用 <span class="hljs-built_in">Number</span>() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">5</span>）Symbol 类型的值不能转换为数字，会报错。<br><br>（<span class="hljs-number">6</span>）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<br><br>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有<span class="hljs-built_in">valueOf</span>() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 <span class="hljs-built_in">toString</span>() 的返回值（如果存在）来进行强制类型转换。<br><br>如果 <span class="hljs-built_in">valueOf</span>() 和 <span class="hljs-built_in">toString</span>() 均不返回基本类型值，会产生 TypeError 错误。<br></code></pre></td></tr></table></figure><h4 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ES5 规范 <span class="hljs-number">9.2</span> 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。<br><br>以下这些是假值：<br>• <span class="hljs-literal">undefined</span><br>• <span class="hljs-literal">null</span><br>• <span class="hljs-literal">false</span><br>• +<span class="hljs-number">0</span>、<span class="hljs-number">-0</span> 和 <span class="hljs-literal">NaN</span><br>• <span class="hljs-string">&quot;&quot;</span><br><br>假值的布尔强制类型转换结果为 <span class="hljs-literal">false</span>。从逻辑上说，假值列表以外的都应该是真值。<br></code></pre></td></tr></table></figure><h4 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，<span class="hljs-built_in">toString</span> 的结果为 <span class="hljs-string">&quot;[object Object]&quot;</span><br><br>[] 的 valueOf 结果为 [] ，<span class="hljs-built_in">toString</span> 的结果为 <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">浏览器在某些特定情况下，在常规 <span class="hljs-keyword">JavaScript </span>语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和<br>普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它<br>是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 <span class="hljs-keyword">JavaScript </span>引擎）提供给 <span class="hljs-keyword">JavaScript </span>程序使用。<br></code></pre></td></tr></table></figure><h4 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。<br><br>~x 大致等同于 -(x+1)。<br></code></pre></td></tr></table></figure><h4 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">解析允许字符串（如 <span class="hljs-built_in">parseInt</span>() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu<br>mber ()）不允许出现非数字字符，否则会失败并返回 NaN。<br></code></pre></td></tr></table></figure><h4 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">根据 ES5 规范 <span class="hljs-number">11.6</span><span class="hljs-number">.1</span> 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 <span class="hljs-string">[[DefaultValue]]</span>，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br><br>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字<br>加法。<br><br>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。<br></code></pre></td></tr></table></figure><h4 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">（<span class="hljs-number">1</span>） <span class="hljs-keyword">if</span> <span class="hljs-comment">(..)</span> 语句中的条件判断表达式。<br>（<span class="hljs-number">2</span>） for <span class="hljs-comment">( .. ; .. ; .. )</span> 语句中的条件判断表达式（第二个）。<br>（<span class="hljs-number">3</span>） <span class="hljs-keyword">while</span> <span class="hljs-comment">(..)</span> 和 do..while<span class="hljs-comment">(..)</span> 循环中的条件判断表达式。<br>（<span class="hljs-number">4</span>） ? : 中的条件判断表达式。<br>（<span class="hljs-number">5</span>） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。<br></code></pre></td></tr></table></figure><h4 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件</span><br>判断。<br><br>对于 <span class="hljs-string">|| 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</span><br><br><span class="hljs-meta">&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</span><br><br><span class="hljs-string">|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</span><br></code></pre></td></tr></table></figure><h4 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。<br><br><span class="hljs-built_in">Symbol</span> 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果<br>都是 <span class="hljs-literal">true</span> ）。<br></code></pre></td></tr></table></figure><h4 id="28-x3D-x3D-操作符的强制类型转换规则？"><a href="#28-x3D-x3D-操作符的强制类型转换规则？" class="headerlink" title="28. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>28. &#x3D;&#x3D; 操作符的强制类型转换规则？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-number">1</span>）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。<br><br>（<span class="hljs-number">2</span>）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-literal">null</span> 和 <span class="hljs-literal">undefined</span> 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。<br><br>（<span class="hljs-number">4</span>）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。<br><br>（<span class="hljs-number">5</span>）如果一个操作值为 <span class="hljs-literal">NaN</span> ，则相等比较返回 <span class="hljs-literal">false</span>（ <span class="hljs-literal">NaN</span> 本身也不等于 <span class="hljs-literal">NaN</span> ）。<br><br>（<span class="hljs-number">6</span>）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <span class="hljs-literal">true</span>，否则，返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/">《JavaScript 字符串间的比较》</a></p><h4 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">（<span class="hljs-number">1</span>）使用 <span class="hljs-built_in">Number</span>() 方法，前提是所包含的字符串不包含不合法字符。<br><br>（<span class="hljs-number">2</span>）使用 <span class="hljs-built_in">parseInt</span>() 方法，<span class="hljs-built_in">parseInt</span>() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 <span class="hljs-number">0</span>，或没有设置该参数时，<span class="hljs-built_in">parseInt</span>() 会根据 string 来判断数字的基数。<br><br>（<span class="hljs-number">3</span>）使用 <span class="hljs-built_in">parseFloat</span>() 方法，该函数解析一个字符串参数并返回一个浮点数。<br><br>（<span class="hljs-number">4</span>）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h4 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number &amp;&amp; number.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">NumberFormat</span>().<span class="hljs-title function_">format</span>(number)<br>&#125;<br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format2</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7">《JS 常用正则汇总》</a></p><h4 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h4><p><a href="http://www.hangge.com/blog/cache/detail_1872.html">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h4 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span><br><br><span class="hljs-comment">// （2）随机从原数组抽取一个元素，加入到新数组</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br><br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * arr.<span class="hljs-property">length</span>);<br>    result.<span class="hljs-title function_">push</span>(arr[randomIndex]);<br>    arr.<span class="hljs-title function_">splice</span>(randomIndex, <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// （3）随机交换数组内的元素（洗牌算法类似）</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> index,<br>    randomIndex,<br>    temp,<br>    len = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; len; index++) &#123;<br>    randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (len - index)) + index;<br><br>    temp = arr[index];<br>    arr[index] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// es6</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> length = array.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array) || length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; length - <span class="hljs-number">1</span>; index++) &#123;<br>    <span class="hljs-keyword">let</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (length - index)) + index;<br><br>    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p><h4 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：<br><br>（<span class="hljs-number">1</span>）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。<br><br>（<span class="hljs-number">2</span>）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 <span class="hljs-keyword">new</span> <span class="hljs-type"></span>来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 <span class="hljs-built_in">this</span> 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 <span class="hljs-built_in">this</span> 的值指向了新建的对象，因此我们可以使用 <span class="hljs-built_in">this</span> 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<br><br>（<span class="hljs-number">3</span>）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 <span class="hljs-keyword">Array</span> 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<br><br>（<span class="hljs-number">4</span>）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<br><br>（<span class="hljs-number">5</span>）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。<br><br>（<span class="hljs-number">6</span>）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。<br><br>嗯我目前了解到的就是这么几种方式。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p><h4 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">我了解的 js 中实现继承的几种方式有：<br><br>（<span class="hljs-number">1</span>）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。<br><br>（<span class="hljs-number">2</span>）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。<br><br>（<span class="hljs-number">3</span>）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。<br><br>（<span class="hljs-number">4</span>）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>() 方法就是原型式继承的实现。缺点与原型链方式相同。<br><br>（<span class="hljs-number">5</span>）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。<br><br>（<span class="hljs-number">6</span>）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html">《JavaScript 深入理解之继承》</a></p><h4 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, grade</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayMyGrade</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My grade is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。<br><br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br><br>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。<br><br>作用域链的创建过程跟执行上下文的建立有关....<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p><h4 id="38-谈谈-This-对象的理解。"><a href="#38-谈谈-This-对象的理解。" class="headerlink" title="38. 谈谈 This 对象的理解。"></a>38. 谈谈 This 对象的理解。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，<span class="hljs-keyword">this</span> 的指向可以通过四种调用模<br>式来判断。<br></code></pre></td></tr></table></figure><ul><li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p></li><li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p></li><li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p></li><li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p></li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 <span class="hljs-keyword">call</span> 和 <span class="hljs-keyword">bind</span> 调用模式，然后是方法调用模式，然后<br>是函数调用模式。<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 this 详解》</a></p><h4 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">它的功能是把对应的字符串解析成 <span class="hljs-keyword">JS </span>代码并运行。<br><br>应该避免使用 eval，不安全，非常耗性能（<span class="hljs-number">2</span>次，一次解析成 <span class="hljs-keyword">js </span>语句，一次执行）。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p><h4 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。<br><br>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM<br>的核心是 <span class="hljs-built_in">window</span>，而 <span class="hljs-built_in">window</span> 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）<br>对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<span class="hljs-built_in">window</span> 对象含有 locati<br><span class="hljs-keyword">on</span> 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 <span class="hljs-built_in">document</span> 对象也是 BOM 的 <span class="hljs-built_in">window</span> 对<br>象的子对象。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h4 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventUtils</span> = &#123;<br>  <span class="hljs-comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br>  <span class="hljs-comment">// 添加事件</span><br>  <span class="hljs-attr">addEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">addEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = handler;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 移除事件</span><br>  <span class="hljs-attr">removeEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">removeEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">removeEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">detachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取事件目标</span><br>  <span class="hljs-attr">getTarget</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br>  <span class="hljs-attr">getEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br>  <span class="hljs-attr">stopPropagation</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">stopPropagation</span>) &#123;<br>      event.<span class="hljs-title function_">stopPropagation</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 取消事件的默认行为</span><br>  <span class="hljs-attr">preventDefault</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;<br>      event.<span class="hljs-title function_">preventDefault</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p><h4 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p></li><li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble &#x3D; true;</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h4 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。<br><br>第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。<br><br>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 <span class="hljs-built_in">document</span>，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。<br><br>第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 <span class="hljs-built_in">document</span> 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h4 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到<br>目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。<br><br>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p><h4 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 <span class="hljs-number">2</span> ~ <span class="hljs-number">36</span> 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。<br><br><br>此处 <span class="hljs-built_in">map</span> 传了 <span class="hljs-number">3</span> 个参数 (element, index, <span class="hljs-built_in">array</span>)，默认第三个参数被忽略掉，因此三次传入的参数分别为 <span class="hljs-string">&quot;1-0&quot;</span>, <span class="hljs-string">&quot;2-1&quot;</span>, <span class="hljs-string">&quot;3-2&quot;</span><br><br>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 <span class="hljs-literal">NaN</span> ，第一次基数为 <span class="hljs-number">0</span> ，按十进制解析返回 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h4 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以<br>访问到当前函数的局部变量。<br><br>闭包有两个常用的用途。<br><br>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外<br>部访问到函数内部的变量，可以使用这种方法来创建私有变量。<br><br>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以<br>这个变量对象不会被回收。<br><br>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p><h4 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h4><p>相关知识点：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。<br><br>设立<span class="hljs-string">&quot;严格模式&quot;</span>的目的，主要有以下几个：<br></code></pre></td></tr></table></figure><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">use <span class="hljs-built_in">strict</span> 指的是严格运行模式，在这种模式对 <span class="hljs-keyword">js</span> 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使<br>用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 <span class="hljs-keyword">js</span> 语法本身的一<br>些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 <span class="hljs-keyword">js</span> 一种更合理、更安全、更严谨的发展方向。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p><h4 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。<br><br>第二种方式可以通过对象的 <span class="hljs-function"><span class="hljs-keyword">constructor</span> 属性来判断，对象的 <span class="hljs-title">constructor</span> 属性指向该对象的构造函数，但是这种方式不是很安全，因为 <span class="hljs-title">constructor</span> 属性可以被改写。</span><br><span class="hljs-function"></span><br><span class="hljs-function">第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 <span class="hljs-title">Object</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span> 方法来打印对象的</span><br><span class="hljs-function">[[<span class="hljs-title">Class</span>]] 属性来进行判断。</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p><h4 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="hljs-comment">// 实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left), <span class="hljs-comment">// 获取对象的原型</span><br>    prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br><br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p><h4 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a>50. new 操作符具体干了什么呢？如何实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）首先创建了一个新的空对象</span><br><span class="hljs-comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="hljs-comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="hljs-comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span><br><br><span class="hljs-comment">// 实现:</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>),<br>    result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 参数判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br><br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p><h4 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">hasOwnProperty<br><br>所有继承了 <span class="hljs-built_in">Object</span> 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和<br><span class="hljs-keyword">in</span> 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p><h4 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h4><p>相关知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">JSON</span> 是一种数据交换格式，基于文本，优于轻量，用于交换数据。<br><br><span class="hljs-built_in">JSON</span> 可以表示数字、布尔值、字符串、<span class="hljs-literal">null</span>、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与<br>值的映射）。<br><br><span class="hljs-built_in">JSON</span> 使用 JavaScript 语法，但是 <span class="hljs-built_in">JSON</span> 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JSON </span>是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br><br>在项目开发中，我们使用 <span class="hljs-keyword">JSON </span>作为前后端数据交换的方式。在前端我们通过将一个符合 <span class="hljs-keyword">JSON </span>格式的数据结构序列化为 <span class="hljs-keyword">JSON </span>字符串，然后将它传递到后端，后端通过 <span class="hljs-keyword">JSON </span>格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br><br>因为 <span class="hljs-keyword">JSON </span>的语法是基于 <span class="hljs-keyword">js </span>的，因此很容易将 <span class="hljs-keyword">JSON </span>和 <span class="hljs-keyword">js </span>中的对象弄混，但是我们应该注意的是 <span class="hljs-keyword">JSON </span>和 <span class="hljs-keyword">js </span>中的对象不是一回事，<span class="hljs-keyword">JSON </span>中对象格式更加严格，比如说在 <span class="hljs-keyword">JSON </span>中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 <span class="hljs-keyword">js </span>对象是不符合 <span class="hljs-keyword">JSON </span>对象的格式的。<br><br>在 <span class="hljs-keyword">js </span>中提供了两个函数来实现 <span class="hljs-keyword">js </span>数据结构和 <span class="hljs-keyword">JSON </span>格式的转换处理，一个是 <span class="hljs-keyword">JSON.stringify </span>函数，通过传入一个符合 <span class="hljs-keyword">JSON </span>格式的数据结构，将其转换为一个 <span class="hljs-keyword">JSON </span>字符串。如果传入的数据结构不符合 <span class="hljs-keyword">JSON </span>格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 <span class="hljs-keyword">JSON </span>格式的字符串。<br><br>另一个函数 <span class="hljs-keyword">JSON.parse() </span>函数，这个函数用来将 <span class="hljs-keyword">JSON </span>格式的字符串转换为一个 <span class="hljs-keyword">js </span>数据结构，如果传入的字符串不是标准的 <span class="hljs-keyword">JSON </span>格式的字符串的话，将会抛出错误。当我们从后端接收到 <span class="hljs-keyword">JSON </span>格式的字符串时，我们可以通过这个方法来将其解析为一个 <span class="hljs-keyword">js </span>数据结构，以此来进行数据的访问。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p><h4 id="53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">（<span class="hljs-number">1</span>）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document<span class="hljs-selector-class">.querySelectorAll</span> 方法。<br><br>（<span class="hljs-number">2</span>）循环遍历 DOM 元素<br><br>（<span class="hljs-number">3</span>）给元素添加 <span class="hljs-attribute">outline</span> 。由于渲染的 <span class="hljs-attribute">outline</span> 是不在 CSS 盒模型中的，所以为元素添加 <span class="hljs-attribute">outline</span> 并不会影响元素的大小和页面的布局。<br><br>（<span class="hljs-number">4</span>）生成随机颜色函数。Math<span class="hljs-selector-class">.random</span>()*(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">24</span>) 可以得到 <span class="hljs-number">0</span>~<span class="hljs-number">2</span>^<span class="hljs-number">24</span> - <span class="hljs-number">1</span> 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 <span class="hljs-built_in">toString</span>(<span class="hljs-number">16</span>) 的方式，转换为一个十六进制的字符串。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p><h4 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h4><p>相关知识点：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">js </span>延迟加载，也就是等页面加载完成之后再加载 <span class="hljs-keyword">JavaScript </span>文件。 <span class="hljs-keyword">js </span>延迟加载有助于提高页面加载速度。<br></code></pre></td></tr></table></figure><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">js </span>的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 <span class="hljs-keyword">js </span>脚本能够尽可能的延迟加载，提高页面的渲染速度。<br><br>我了解到的几种方式是：<br><br>第一种方式是我们一般采用的是将 <span class="hljs-keyword">js </span>脚本放在文档的底部，来使 <span class="hljs-keyword">js </span>脚本尽可能的在最后来加载执行。<br><br>第二种方式是给 <span class="hljs-keyword">js </span>脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。<br><br>第三种方式是给 <span class="hljs-keyword">js </span>脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 <span class="hljs-keyword">js </span>脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。<br><br>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 <span class="hljs-keyword">script </span>标签来引入 <span class="hljs-keyword">js </span>脚本。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h4 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h4><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p>一般实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// promise 封装实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br><br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 <span class="hljs-keyword">http</span> 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br><br>创建一个 ajax 有这样几个步骤<br><br>首先是创建一个 XMLHttpRequest 对象。<br><br>然后在这个对象上使用 <span class="hljs-built_in">open</span> 方法创建一个 <span class="hljs-keyword">http</span> 请求，<span class="hljs-built_in">open</span> 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。<br><br>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 <span class="hljs-number">5</span> 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 <span class="hljs-number">4</span> 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 <span class="hljs-number">2</span>xx 或者 <span class="hljs-number">304</span> 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。<br><br>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p><h4 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">浏览器的缓存机制指的是通过在一段时间内保留已接收到的 <span class="hljs-variable">web</span> 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 <span class="hljs-variable">web</span> 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。<br><br><span class="hljs-variable">web</span> 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。<br><br>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 <span class="hljs-variable">http</span> 头信息中的 <span class="hljs-variable">Expires</span> 属性和 <span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 属性。<br><br>服务器通过在响应头中添加 <span class="hljs-variable">Expires</span> 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。<br><br><span class="hljs-variable">Expires</span> 是 <span class="hljs-variable">http1</span><span class="hljs-number">.0</span> 中的方式，因为它的一些缺点，在 <span class="hljs-variable">http</span> <span class="hljs-number">1.1</span> 中提出了一个新的头部属性就是 <span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 属性，<br>它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 <span class="hljs-variable">max</span><span class="hljs-operator">-</span><span class="hljs-variable">age</span> 来指定资源能够被缓存的时间<br>的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 <span class="hljs-variable">Expires</span><br>来说，这种方式更加有效一些。常用的还有比如 <span class="hljs-variable">private</span> ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 <span class="hljs-variable">n</span><br><span class="hljs-variable">o</span><span class="hljs-operator">-</span><span class="hljs-variable">store</span> ，用来指定资源不能够被缓存，<span class="hljs-variable">no</span><span class="hljs-operator">-</span><span class="hljs-variable">cache</span> 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。<br><br>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 的优先级要高于 <span class="hljs-variable">Expires</span> 。<br><br>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 <span class="hljs-number">304</span> 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 <span class="hljs-variable">http</span> 头信息中的 <span class="hljs-variable">Etag</span> 和 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 属性。<br><br>服务器通过在响应头中添加 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 的属性，属性值为上一次资源返回时的 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 <span class="hljs-number">304</span> 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 标注的最后修改时间只能精确到秒级，如果某些文件在<span class="hljs-number">1</span>秒钟以内，被修改多次的话，那么文件已将改变了但是 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 却没有改变，<br>这样会造成缓存命中的不准确。<br><br>因为 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的这种可能发生的不准确性，<span class="hljs-variable">http</span> 中提供了另外一种方式，那就是 <span class="hljs-variable">Etag</span> 属性。服务器在返回资源的时候，在头信息中添加了 <span class="hljs-variable">Etag</span> 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 属性，这个属性的值就是上次返回的资源的 <span class="hljs-variable">Etag</span> 的值。服务接收到请求后会根据这个值来和资源当前的 <span class="hljs-variable">Etag</span> 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的方式更加精确。<br><br>当 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 和 <span class="hljs-variable">Etag</span> 属性同时出现的时候，<span class="hljs-variable">Etag</span> 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 应该保持一致，因为每个服务器上 <span class="hljs-variable">Etag</span> 的值都不一样，因此在考虑负载平衡时，最好不要设置 <span class="hljs-variable">Etag</span> 属性。<br><br>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p><h4 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h4><ul><li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p></li><li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p></li><li><p>3.在 URL 后面加上一个随机数： “fresh&#x3D;” + Math.random();。</p></li><li><p>4.在 URL 后面加上时间戳：”nowtime&#x3D;” + new Date().getTime();。</p></li><li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p><h4 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h4><p>相关知识点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  <br><br>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 <br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返<br>回为止再继续向下执行。<br><br>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等<br>待消息的返回，当消息返回时系统再通知进程进行处理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p><h4 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我对浏览器的同源政策的理解是，一个域下的 <span class="hljs-keyword">js </span>脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。<br><br>同源政策主要限制了三个方面<br><br>第一个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。<br><br>第二个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够操作访问操作其他域下的 DOM。<br><br>第三个是当前域下 ajax 无法发送跨域请求。<br><br>同源政策的目的主要是为了保证用户的信息安全，它只是对 <span class="hljs-keyword">js </span>脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br><span class="hljs-keyword">script </span>脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br></code></pre></td></tr></table></figure><h4 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h4><p>相关知识点：</p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享（CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p>回答：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">解决跨域的方法我们可以根据我们想要实现的目的来划分。<br><br>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document<span class="hljs-selector-class">.domain</span> 来解决。<br><br>（<span class="hljs-number">1</span>）将 document<span class="hljs-selector-class">.domain</span> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 <span class="hljs-selector-tag">iframe</span> 的话，我们也可以对这个 <span class="hljs-selector-tag">iframe</span> 进行操作。<br><br>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 <span class="hljs-selector-tag">iframe</span> 进行通信的问题，我们可以使用 location<span class="hljs-selector-class">.hash</span> 或者 window<span class="hljs-selector-class">.name</span> 或者 postMessage 来解决。<br><br>（<span class="hljs-number">2</span>）使用 location<span class="hljs-selector-class">.hash</span> 的方法，我们可以在主页面动态的修改 <span class="hljs-selector-tag">iframe</span> 窗口的 hash 值，然后在 <span class="hljs-selector-tag">iframe</span> 窗口里实现监听函数来实现这样一个单向的通信。因为在 <span class="hljs-selector-tag">iframe</span> 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 <span class="hljs-selector-tag">iframe</span> 中再加入一个 <span class="hljs-selector-tag">iframe</span> ，这个 <span class="hljs-selector-tag">iframe</span> 的内容是和父级页面同源的，所以我们可以 window<span class="hljs-selector-class">.parent</span><span class="hljs-selector-class">.parent</span> 来修改最顶级页面的 <span class="hljs-attribute">src</span>，以此来实现双向通信。<br><br>（<span class="hljs-number">3</span>）使用 window<span class="hljs-selector-class">.name</span> 的方法，主要是基于同一个窗口中设置了 window<span class="hljs-selector-class">.name</span> 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window<span class="hljs-selector-class">.name</span> 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window<span class="hljs-selector-class">.name</span> 中的数据了，这种方式的好处是可以传输的数据量大。<br><br>（<span class="hljs-number">4</span>）使用 postMessage 来解决的方法，这是一个 <span class="hljs-selector-tag">h5</span> 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。<br><br>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。<br><br>（<span class="hljs-number">5</span>）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。<br><br>（<span class="hljs-number">6</span>）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是<span class="hljs-string">&quot;跨域资源共享&quot;</span>。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。<br><br>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。<br><br>（<span class="hljs-number">7</span>）使用 websocket 协议，这个协议没有同源限制。<br><br>（<span class="hljs-number">8</span>）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h4 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h4><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p><h4 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 <span class="hljs-number">4</span>k 大小的数据，并且只能够被同源的网页所共享访问。<br><br>服务器端可以使用 <span class="hljs-keyword">Set</span>-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了<span class="hljs-number">9</span>个属性值 <span class="hljs-type">name</span>、<span class="hljs-keyword">value</span>、expires、<span class="hljs-keyword">domain</span>、<span class="hljs-type">path</span>、secure、HttpOnly、SameSite、Priority。其中 <span class="hljs-type">name</span> 和 <span class="hljs-keyword">value</span> 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，<span class="hljs-keyword">domain</span> 是域名、<span class="hljs-type">path</span>是路径，<span class="hljs-keyword">domain</span> 和 <span class="hljs-type">path</span> 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。<br><br>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》 </a><br><a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》 </a></p><h4 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，<span class="hljs-keyword">js </span>只实现一些简单的功能，所以并没有模块的概念<br>，但随着程序越来越复杂，代码的模块化开发变得越来越重要。<br><br>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污<br>染，并且模块间没有联系。<br><br>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所<br>有的所有的模块成员，外部代码可以修改内部属性的值。<br><br>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p><h4 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中现在比较成熟的有四种模块加载方案。<br><br>第一种是 CommonJS 方案，它通过 <span class="hljs-built_in">require</span> 来引入模块，通过 module.<span class="hljs-built_in">exports</span> 定义模块的输出接口。这种模块加载方案是<br>服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式<br>加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。<br><br>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定<br>义在一个回调函数里，等到加载完成后再执行回调函数。<span class="hljs-built_in">require</span>.js 实现了 AMD 规范。<br><br>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 <span class="hljs-built_in">require</span>.js<br>的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考<span class="hljs-number">60</span><br><br>第四种方案是 ES6 提出的方案，使用 <span class="hljs-keyword">import</span> 和 <span class="hljs-keyword">export</span> 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 <span class="hljs-number">61</span>。<br></code></pre></td></tr></table></figure><h4 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h4><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// CMD</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);<br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>); <span class="hljs-comment">// 依赖可以就近书写</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-comment">// AMD 默认推荐</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-comment">// 依赖必须一开始就写好</span><br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p><h4 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><ul><li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p></li><li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><h4 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">require</span>.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 <span class="hljs-built_in">load</span> 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h4 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p><h4 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">在我看来 ES6 新添加的 <span class="hljs-keyword">class</span> 只是为了补充 <span class="hljs-symbol">js</span> 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 <span class="hljs-symbol">class</span> 可以有利于我们更好的组织代码。<br><br>在 <span class="hljs-symbol">class</span> 中添加的方法，其实是添加在类的原型上的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p><h4 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">document.<span class="hljs-built_in">write</span> 的内容会代替整个文档内容，会重写整个页面。<br><br>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p><h4 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createDocumentFragment</span>(node);<br><span class="hljs-title function_">createElement</span>(node);<br><span class="hljs-title function_">createTextNode</span>(text);<br></code></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">appendChild</span>(node)<br><span class="hljs-title function_">removeChild</span>(node)<br><span class="hljs-title function_">replaceChild</span>(<span class="hljs-keyword">new</span>,old)<br><span class="hljs-title function_">insertBefore</span>(<span class="hljs-keyword">new</span>,old)<br></code></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getElementById</span>();<br><span class="hljs-title function_">getElementsByName</span>();<br><span class="hljs-title function_">getElementsByTagName</span>();<br><span class="hljs-title function_">getElementsByClassName</span>();<br><span class="hljs-title function_">querySelector</span>();<br><span class="hljs-title function_">querySelectorAll</span>();<br></code></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getAttribute</span>(key);<br><span class="hljs-title function_">setAttribute</span>(key, value);<br><span class="hljs-title function_">hasAttribute</span>(key);<br><span class="hljs-title function_">removeAttribute</span>(key);<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h4 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">对于这样一个 <span class="hljs-selector-tag">HTML</span> 元素：&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;。<br><br>innerHTML：内部 <span class="hljs-selector-tag">HTML</span>，<span class="hljs-attribute">content</span>&lt;br/&gt;；<br>outerHTML：外部 <span class="hljs-selector-tag">HTML</span>，&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;；<br>innerText：内部文本，<span class="hljs-attribute">content</span> ；<br>outerText：内部文本，<span class="hljs-attribute">content</span> ；<br></code></pre></td></tr></table></figure><h4 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">它们的作用一模一样，区别仅在于传入参数的形式的不同。<br><br>apply 接受两个参数，第一个参数指定了函数体内 <span class="hljs-keyword">this</span> 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。<br><br>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 <span class="hljs-keyword">this</span> 指向，从第二个参数开始往后，每个参数被依次传入函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p><h4 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">一个拥有 <span class="hljs-built_in">length</span> 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。<br><br>常见的类数组对象有 <span class="hljs-keyword">arguments</span> 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 <span class="hljs-built_in">length</span><br>属性值，代表可接收的参数个数。<br></code></pre></td></tr></table></figure><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p><h4 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">数组和字符串的转换方法：<span class="hljs-built_in">toString</span>()、<span class="hljs-built_in">toLocalString</span>()、<span class="hljs-built_in">join</span>() 其中 <span class="hljs-built_in">join</span>() 方法可以指定转换为字符串时的分隔符。<br><br>数组尾部操作的方法 <span class="hljs-built_in">pop</span>() 和 <span class="hljs-built_in">push</span>()，push 方法可以传入多个参数。<br><br>数组首部操作的方法 <span class="hljs-built_in">shift</span>() 和 <span class="hljs-built_in">unshift</span>() 重排序的方法 <span class="hljs-built_in">reverse</span>() 和 <span class="hljs-built_in">sort</span>()，<span class="hljs-built_in">sort</span>() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。<br><br>数组连接的方法 <span class="hljs-built_in">concat</span>() ，返回的是拼接好的数组，不影响原数组。<br><br>数组截取办法 <span class="hljs-built_in">slice</span>()，用于截取数组中的一部分返回，不影响原数组。<br><br>数组插入方法 <span class="hljs-built_in">splice</span>()，影响原数组查找特定项的索引的方法，<span class="hljs-built_in">indexOf</span>() 和 <span class="hljs-built_in">lastIndexOf</span>() 迭代方法 <span class="hljs-built_in">every</span>()、<span class="hljs-built_in">some</span>()、<span class="hljs-attribute">filter</span>()、<span class="hljs-built_in">map</span>() 和 <span class="hljs-built_in">forEach</span>() 方法<br><br>数组归并方法 <span class="hljs-built_in">reduce</span>() 和 <span class="hljs-built_in">reduceRight</span>() 方法<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p><h4 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<span class="hljs-built_in"></span><br><span class="hljs-built_in">fill </span>方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p><h4 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">尾后逗号 （有时叫做“终止逗号”）在向 <span class="hljs-keyword">JavaScript </span>代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。<br><br><span class="hljs-keyword">JavaScript </span>一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript <span class="hljs-number">5</span>）中添加了尾后逗号。最近（ECMAS<br>cript <span class="hljs-number">2017</span>），又将其添加到函数参数中。但是 <span class="hljs-keyword">JSON </span>不支持尾后逗号。<br><br>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数<br>量。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p><h4 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。<br><br>造成变量声明提升的本质原因是 <span class="hljs-keyword">js </span>引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p><h4 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h4><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p><h4 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。<br><br>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。<br><br>新生代被分为 <span class="hljs-selector-tag">From</span> 和 <span class="hljs-selector-tag">To</span> 两个空间，<span class="hljs-selector-tag">To</span> 一般是闲置的。当 <span class="hljs-selector-tag">From</span> 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：<br><br>（<span class="hljs-number">1</span>）首先检查 <span class="hljs-selector-tag">From</span> 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 <span class="hljs-selector-tag">To</span> 空间。<br><br>（<span class="hljs-number">2</span>）如果对象不存活，则释放对象的空间。<br><br>（<span class="hljs-number">3</span>）最后将 <span class="hljs-selector-tag">From</span> 空间和 <span class="hljs-selector-tag">To</span> 空间角色进行交换。<br><br>新生代对象晋升到老生代有两个条件：<br><br>（<span class="hljs-number">1</span>）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 <span class="hljs-selector-tag">From</span> 空间复制到老生代中；若没有经历，则复制到 <span class="hljs-selector-tag">To</span> 空间。<br><br>（<span class="hljs-number">2</span>）第二个是 <span class="hljs-selector-tag">To</span> 空间的内存使用占比是否超过限制。当对象从 <span class="hljs-selector-tag">From</span> 空间复制到 <span class="hljs-selector-tag">To</span> 空间时，若 <span class="hljs-selector-tag">To</span> 空间使用超过 <span class="hljs-number">25%</span>，则对象直接晋升到老生代中。设置 <span class="hljs-number">25%</span> 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 <span class="hljs-selector-tag">To</span> 空间的内存太小，会影响后续的内存分配。<br><br>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。<br><br>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p><h4 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h4><p>相关知识点：</p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。<br><br>第二种情况是我们设置了 <span class="hljs-built_in">setInterval</span> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。<br><br>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回<br>收。<br><br>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h4 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 <span class="hljs-keyword">state</span> 记录加入到 history<br>对象中。一条 <span class="hljs-keyword">state</span> 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 <span class="hljs-keyword">state</span> 对象，我们可<br>以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。<br><br>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问<br>题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p><h4 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-string">&#x27;node&#x27;</span> : <span class="hljs-string">&#x27;browser&#x27;</span>;<br><br>通过判断当前环境的 <span class="hljs-variable language_">window</span> 对象类型是否为 <span class="hljs-literal">undefined</span>，如果是<span class="hljs-literal">undefined</span>，则说明当前脚本运行在node环境，否则说明运行在<span class="hljs-variable language_">window</span>环境。<br></code></pre></td></tr></table></figure><h4 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p><h4 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">移动端点击有 <span class="hljs-number">300</span>ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 <span class="hljs-number">300</span>ms，看用户有没有下一次点击，来判断这次操作是不是双击。<br></code></pre></td></tr></table></figure><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p><h4 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-number">1</span>）什么是前端路由？<br><br>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。<br><br>（<span class="hljs-number">2</span>）什么时候使用前端路由？<br><br>在单页面应用，大部分页面结构不变，只改变部分内容的使用<br><br>（<span class="hljs-number">3</span>）前端路由有什么优点和缺点？<br><br>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户<br><br>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置<br><br>前端路由一共有两种实现方式，一种是通过 <span class="hljs-built_in">hash</span> 的方式，一种是通过使用 pushState 的方式。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p><h4 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p><h4 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">检测浏览器版本一共有两种方式：<br><br>一种是检测 window.navigator.<span class="hljs-keyword">user</span>Agent 的值，但这种方式很不可靠，因为 <span class="hljs-keyword">user</span>Agent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 <span class="hljs-keyword">user</span>Agent 的值为 Mozilla 来躲过服务器的检测。<br><br>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p><h4 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。<br><br>比如说 <span class="hljs-built_in">querySelectorAll</span> 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。<br><br>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p><h4 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><br><span class="hljs-comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><br><span class="hljs-comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileExtension</span>(<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">return</span> filename.<span class="hljs-title function_">slice</span>(((filename.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>) - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p><h4 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span><br><br><span class="hljs-comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span><br><br><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>,<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">函数防抖是指在事件被触发 <span class="hljs-built_in">n</span> 秒后再执行回调，如果在这 <span class="hljs-built_in">n</span> 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。<br><br>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h4 id="92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h4><p>相关知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回<span class="hljs-literal">false</span>）。<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 在三等号判等的基础上特别处理了 <span class="hljs-literal">NaN</span> 、<span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> ，保证 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相同，但 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>) 会返回 <span class="hljs-literal">true</span>.<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。<br><br>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 <span class="hljs-literal">false</span>。<br><br>使用 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相等，两个 <span class="hljs-literal">NaN</span> 认定为是相等的。<br></code></pre></td></tr></table></figure><h4 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h4><p>相关知识点：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。<br>它们的根本区别在于，escape 在处理 <span class="hljs-number">0xff</span> 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF<span class="hljs-number">-8</span>，再在 UTF<span class="hljs-number">-8</span> 的每个字节码前加上一个「%」；在处理 <span class="hljs-number">0xff</span> 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 <span class="hljs-number">16</span> 进制 unicode，同时也是字符的 UTF<span class="hljs-number">-8</span>），只是范围（即哪些字符编码哪些字符不编码）不一样。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">encodeURI</span> 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。<br><br><span class="hljs-built_in">encodeURIComponent</span> 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。<br><br><span class="hljs-built_in">escape</span> 和 <span class="hljs-built_in">encodeURI</span> 的作用相同，不过它们对于 unicode 编码为 <span class="hljs-number">0xff</span> 之外字符的时候会有区别，<span class="hljs-built_in">escape</span> 是直接在字符的 unicode 编码前加上 %u，而 <span class="hljs-built_in">encodeURI</span> 首先会将字符转换为 UTF<span class="hljs-number">-8</span> 的格式，再在每个字节前加上 %。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h4 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Unicode</span> 是一种字符集合，现在可容纳 <span class="hljs-number">100</span> 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。<br><br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">8</span> 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 <span class="hljs-number">1</span>~<span class="hljs-number">4</span> 个字节来表示一个字符。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h4 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h4><p>相关知识点：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，<span class="hljs-keyword">JS </span>引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<br><br>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。<br><br>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲<br>染等。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h4 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = <span class="hljs-title function_">deepCopy</span>(object[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  <span class="hljs-built_in">Object</span>.assign 和展开运算符来实现。<br><br>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 <span class="hljs-built_in">JSON</span> 的两个函数来实现，但是由于 <span class="hljs-built_in">JSON</span> 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 <span class="hljs-built_in">Symbol</span> 类型的值时，会转换失败。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h4 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// apply 函数实现</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h4 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, args</span>) &#123;<br>  <span class="hljs-comment">// 获取函数需要的参数长度</span><br>  <span class="hljs-keyword">let</span> length = fn.<span class="hljs-property">length</span>;<br><br>  args = args || [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> subArgs = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 拼接得到现有的所有参数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      subArgs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span><br>    <span class="hljs-keyword">if</span> (subArgs.<span class="hljs-property">length</span> &gt;= length) &#123;<br>      <span class="hljs-comment">// 如果满足，执行函数</span><br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, subArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span><br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, subArgs);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// es6 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-property">length</span> &lt;= args.<span class="hljs-property">length</span> ? <span class="hljs-title function_">fn</span>(...args) : curry.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, fn, ...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h4 id="99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以<span class="hljs-number"> 64 </span>位双精度格式来存储数字的，只有<span class="hljs-number"> 53 </span>位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以<span class="hljs-number"> 64 </span>位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过<span class="hljs-number"> 53 </span>位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。<br><br>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。<br><br>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !&#x3D;&#x3D; 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h4 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。<br><br>正数的反码和其原码一样；负数的反码，符号位为<span class="hljs-number">1</span>，数值部分按原码取反。<br>如 [+<span class="hljs-number">7</span>]原 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]反 = <span class="hljs-number">00000111</span>； [-<span class="hljs-number">7</span>]原 = <span class="hljs-number">10000111</span>，[-<span class="hljs-number">7</span>]反 = <span class="hljs-number">11111000</span>。<br><br>正数的补码和其原码一样；负数的补码为其反码加<span class="hljs-number">1</span>。<br><br>例如 [+<span class="hljs-number">7</span>]原 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]反 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]补 = <span class="hljs-number">00000111</span>；<br>[-<span class="hljs-number">7</span>]原 = <span class="hljs-number">10000111</span>，[-<span class="hljs-number">7</span>]反 = <span class="hljs-number">11111000</span>，[-<span class="hljs-number">7</span>]补 = <span class="hljs-number">11111001</span><br><br>之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p><h4 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">to</span>Precision 用于处理精度，精度是从左至右第一个不为 <span class="hljs-number">0</span> 的数开始数起。<br><span class="hljs-keyword">to</span>Fixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。<br></code></pre></td></tr></table></figure><h4 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。<br><br>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。<br><br>XSS 一般分为存储型、反射型和 DOM 型。<br><br>存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。<br><br>反射型指的是攻击者构建了特殊的 <span class="hljs-built_in">URL</span>，当服务器接收到请求后，从 <span class="hljs-built_in">URL</span> 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。<br><br>DOM 型指的是攻击者构建了特殊的 <span class="hljs-built_in">URL</span>，用户打开网站后，js 脚本从 <span class="hljs-built_in">URL</span> 中获取数据，从而导致了恶意代码的执行。<br><br>XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。<br><br>对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。<br><br>因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。<br><br>还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。<br><br>还可以对一些敏感信息进行保护，比如 cookie 使用 <span class="hljs-keyword">http</span>-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h4 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。<br><br>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta<br><span class="hljs-attribute">http-equiv</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Content-Security-Policy&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p><h4 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。<br><br>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。<br><br>一般的 CSRF 攻击类型有三种：<br><br>第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提<br>交。<br><br>第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。<br><br>第三种是链接类型的 CSRF 攻击，比如说在 <span class="hljs-keyword">a</span> 标签的 href 属性里构建一个请求，然后诱导用户去点击。<br><br>CSRF 可以用下面几种方法来防护：<br><br>第一种是同源检测的方法，服务器根据 <span class="hljs-keyword">http</span> 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。<br><br>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 <span class="hljs-keyword">token</span> ，然后服务器对这个 <span class="hljs-keyword">token</span> 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 <span class="hljs-keyword">token</span>，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 <span class="hljs-keyword">token</span> 的话，就没有办法验证了。这种情况我们可以通过改变 <span class="hljs-keyword">token</span> 的构建方式来解决。<br><br>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 <span class="hljs-built_in">URL</span> 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。<br><br>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h4 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。<br><br>将 Samesite 设为 <span class="hljs-keyword">strict</span> ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。<br><br>将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 <span class="hljs-keyword">GET</span> 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。<br><br>使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。<br></code></pre></td></tr></table></figure><h4 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 <span class="hljs-selector-tag">iframe</span> 嵌套的方式嵌入自己的网页中，并将 <span class="hljs-selector-tag">iframe</span> 设置为透明，在页面中透出一个按钮诱导用户点击。<br><br>我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 <span class="hljs-selector-tag">iframe</span> 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特<br>定的一些情况才能作为 <span class="hljs-selector-tag">iframe</span> 来使用。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p><h4 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span> 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 <span class="hljs-keyword">SQL</span> 代码，服务器使用参数构建数据库 <span class="hljs-keyword">SQL</span> 命令时，恶意 <span class="hljs-keyword">SQL</span> 被一起构<br>造，破坏原有 <span class="hljs-keyword">SQL</span> 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p><h4 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cos">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。<br><br>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。<br><br>MVC 通过分离 Model、<span class="hljs-keyword">View</span> 和 Controller 的方式来组织代码结构。其中 <span class="hljs-keyword">View</span> 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 <span class="hljs-keyword">View</span> 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 <span class="hljs-keyword">View</span> 层更新页面。Controller 层是 <span class="hljs-keyword">View</span> 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co<br>ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 <span class="hljs-keyword">View</span> 层更新。<br><br>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 <span class="hljs-keyword">View</span> 层的更新。这样 <span class="hljs-keyword">View</span> 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 <span class="hljs-keyword">View</span> 层和 Model 层的解耦。MVC 中的<br>Controller 只知道 Model 的接口，因此它没有办法控制 <span class="hljs-keyword">View</span> 层的更新，MVP 模式中，<span class="hljs-keyword">View</span> 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 <span class="hljs-keyword">View</span> 的变化绑定在一起，以此来实现 <span class="hljs-keyword">View</span> 和 Model 的同步更新。这样就实现了对 <span class="hljs-keyword">View</span> 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。<br><br>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 <span class="hljs-keyword">View</span> 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，<span class="hljs-keyword">View</span> 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功<br>能。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC&#x2F;MVP&#x2F;MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC&#x2F;MVP&#x2F;MVVM》</a></p><h4 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">vue 通过使用双向数据绑定，来实现了 View 和 <span class="hljs-keyword">Model</span> 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。<br><br>首先我们通过 Object.defineProperty() 方法来对 <span class="hljs-keyword">Model</span> 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 <span class="hljs-keyword">Model</span> 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。<br><br>数据在 html 模板中一共有两种绑定情况，一种是使用 v-<span class="hljs-keyword">model</span> 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。<br><br>如果遇到元素节点，并且属性值包含 v-<span class="hljs-keyword">model</span> 的话，我们就从 <span class="hljs-keyword">Model</span> 中去获取 v-<span class="hljs-keyword">model</span> 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 <span class="hljs-keyword">Model</span> 中的对应的属性的值进行更新。<br><br>如果遇到了绑定的文本节点，我们使用 <span class="hljs-keyword">Model</span> 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 <span class="hljs-keyword">Model</span> 层数据发生改变的时候，<span class="hljs-keyword">Model</span> 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数<br>据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p><h4 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Object</span>.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。<br><br>一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p><h4 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3<span class="hljs-number">.0</span> 中已经不使用这种方式了，而是通过使用 <span class="hljs-built_in">Proxy</span> 对对象进行代理，从而实现数据劫持。使用 <span class="hljs-built_in">Proxy</span> 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。<br></code></pre></td></tr></table></figure><h4 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi">我对 <span class="hljs-keyword">Virtual</span> DOM 的理解是，<br><br>首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。<br><br>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。<br><br>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。<br><br>我认为 <span class="hljs-keyword">Virtual</span> DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 <span class="hljs-keyword">Virtual</span> DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h4 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">两个树的完全 diff 算法的时间复杂度为 <span class="hljs-constructor">O(<span class="hljs-params">n</span>^3)</span> ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 <span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>。<br><br>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。<br><br>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。<br></code></pre></td></tr></table></figure><h4 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h4 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源<br>数。<br><br>我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。<br><br>Webpack 具有四个核心的概念，分别是 <span class="hljs-keyword">Entry</span>（入口）、Output（输出）、loader 和 Plugins（插件）。<br><br><span class="hljs-keyword">Entry</span> 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。<br><br>Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。<br><br>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。<span class="hljs-keyword">use</span> 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。<br><br>插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。<br><br>使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.<span class="hljs-number">0</span> 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h4 id="116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？"><a href="#116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？"></a>116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span>，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。<br>clientLeft 返回的左边框的宽度。<br><br>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + <span class="hljs-attribute">border</span> 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。<br>offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。<br><br>scrollWidth/scrollHeight 返回值包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。<br>scrollLeft 属性返回的是元素滚动条到元素左边的距离。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h4 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">简单说，<span class="hljs-string">&quot;函数式编程&quot;</span>是一种<span class="hljs-string">&quot;编程范式&quot;</span>（programming paradigm），也就是如何编写程序的方法论。<br><br>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是<span class="hljs-string">&quot;第一等公民&quot;</span>、只用<span class="hljs-string">&quot;表达式&quot;</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h4 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h4><p>相关资料：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">回调函数<br>优点：简单、容易理解<br>缺点：不利于维护，代码耦合高<br><br>事件监听（采用时间驱动模式，取决于某个事件是否发生）：<br>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：事件驱动型，流程不够清晰<br><br>发布/订阅（观察者模式）<br>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者<br><br><span class="hljs-built_in">Promise</span> 对象<br>优点：可以利用 <span class="hljs-keyword">then</span> 方法，进行链式写法；可以书写错误时的回调函数；<br>缺点：编写和理解，相对比较难<br><br><span class="hljs-built_in">Generator</span> 函数<br>优点：函数体内外的数据交换、错误处理机制<br>缺点：流程管理不方便<br><br><span class="hljs-keyword">async</span> 函数<br>优点：内置执行器、更好的语义、更广的适用性、返回的是 <span class="hljs-built_in">Promise</span>、结构清晰。<br>缺点：错误处理机制<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中的异步机制可以分为以下几种：<br><br>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br><br>第二种是 <span class="hljs-built_in">Promise</span> 的方式，使用 <span class="hljs-built_in">Promise</span> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 <span class="hljs-keyword">then</span> 的链式调用，可能会造成代码的语义不够明确。<br><br>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。<br><br>第四种是使用 <span class="hljs-keyword">async</span> 函数的形式，<span class="hljs-keyword">async</span> 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <span class="hljs-keyword">await</span> 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br></code></pre></td></tr></table></figure><h4 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">CSS3 的动画的优点<br><br>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化<br>代码相对简单<br><br>缺点<br><br>在动画控制上不够灵活<br>兼容性不好<br><br><span class="hljs-keyword">JavaScript </span>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 <span class="hljs-keyword">javascript </span>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧<br></code></pre></td></tr></table></figure><h4 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">误区：我们经常说 <span class="hljs-built_in">get</span> 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。<br><br>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 <span class="hljs-built_in">get</span> 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:<br></code></pre></td></tr></table></figure><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h4 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">URI: Uniform Resource Identifier      指的是统一资源标识符<br><span class="hljs-built_in">URL</span>: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称<br><br>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。<br><br><span class="hljs-built_in">URL</span> 指的是统一资源定位符，URN 指的是统一资源名称。<span class="hljs-built_in">URL</span> 和 URN 是 URI 的子集，<span class="hljs-built_in">URL</span> 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p><h4 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h4><p>相关知识点：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">get</span> 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br><br><span class="hljs-built_in">post</span> 不同，<span class="hljs-built_in">post</span> 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 <span class="hljs-built_in">get</span> 请求适合于请求缓存。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">缓存一般只适用于那些不会更新服务端数据的请求。一般 <span class="hljs-built_in">get</span> 请求都是查找请求，不会对服务器资源数据造成修改，而 <span class="hljs-built_in">post</span> 请求一般都会对服务器数据造成修改，所以，一般会对 <span class="hljs-built_in">get</span> 请求进行缓存，很少会对 <span class="hljs-built_in">post</span> 请求进行缓存。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h4 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h4><p>相关知识点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br><br>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br><br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。<br><br>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。<br><br>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/">《基于用户行为的图片等资源预加载》</a></p><h4 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。<br><br>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h4 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h4><p>相关知识点：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">首先是三个事件，分别是 <span class="hljs-built_in">mousedown</span>，<span class="hljs-built_in">mousemove</span>，<span class="hljs-built_in">mouseup</span><br>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 <span class="hljs-built_in">mousemove</span> 里面的具体方法。<br>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示<br>元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠<br>标抬起，拖拽过程结束。<br><br>这三步分别对应了三个事件，<span class="hljs-built_in">mousedown</span> 事件，<span class="hljs-built_in">mousemove</span> 事件和 <span class="hljs-built_in">mouseup</span> 事件。只有在鼠标按下的状态移动鼠标我们才会<br>执行拖拽事件，因此我们需要在 <span class="hljs-built_in">mousedown</span> 事件中设置一个状态来标识鼠标已经按下，然后在 <span class="hljs-built_in">mouseup</span> 事件中再取消这个状<br>态。在 <span class="hljs-built_in">mousedown</span> 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠<br>标的位置。然后在 <span class="hljs-built_in">mousemove</span> 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。<br>最后 <span class="hljs-built_in">mouseup</span> 事件触发后，清除状态，结束拖拽事件。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465">《原生 js 实现拖拽功能基本思路》</a></p><h4 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  <span class="hljs-keyword">var</span> timer = &#123;<br>    <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">interval</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">flag</span>) &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 启动定时器</span><br>  <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br><br>  <span class="hljs-comment">// 返回控制器</span><br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setInterval</span> 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。<br><br>针对 <span class="hljs-built_in">setInterval</span> 的这个缺点，我们可以使用 <span class="hljs-built_in">setTimeout</span> 递归调用来模拟 <span class="hljs-built_in">setInterval</span>，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 <span class="hljs-built_in">setInterval</span> 的问题。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737">《setInterval 有什么缺点？》</a></p><h4 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h4><ul><li>1.声明的变量只在声明时的代码块内有效</li><li>2.不存在声明提升</li><li>3.存在暂时性死区，如果在变量声明前使用，会报错</li><li>4.不允许重复声明，重复声明会报错</li></ul><h4 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">rest</span> 参数（形式为...变量名），用于获取函数的多余参数。<br></code></pre></td></tr></table></figure><h4 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br></code></pre></td></tr></table></figure><h4 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h4><ul><li>1.Symbol 函数前不能使用 new 命令，否则会报错。</li><li>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><h4 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h4><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li></ul><h4 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h4><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h4 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Proxy</span> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。<br><br><span class="hljs-built_in">Proxy</span> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<span class="hljs-built_in">Proxy</span> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br></code></pre></td></tr></table></figure><h4 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h4><ul><li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li><li>3.让 Object 操作都变成函数行为。</li><li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h4 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当 Node 遇到 <span class="hljs-built_in">require</span>(X) 时，按下面的顺序处理。<br><br>（<span class="hljs-number">1</span>）如果 X 是内置模块（比如 <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)）<br>　　<span class="hljs-selector-tag">a</span>. 返回该模块。<br>　　<span class="hljs-selector-tag">b</span>. 不再继续执行。<br><br>（<span class="hljs-number">2</span>）如果 X 以 <span class="hljs-string">&quot;./&quot;</span> 或者 <span class="hljs-string">&quot;/&quot;</span> 或者 <span class="hljs-string">&quot;../&quot;</span> 开头<br>　　<span class="hljs-selector-tag">a</span>. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　<span class="hljs-selector-tag">b</span>. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X<br>    X<span class="hljs-selector-class">.js</span><br>    X<span class="hljs-selector-class">.json</span><br>    X<span class="hljs-selector-class">.node</span><br><br>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X/package.json（main字段）<br>    X/index<span class="hljs-selector-class">.js</span><br>    X/index<span class="hljs-selector-class">.json</span><br>    X/index<span class="hljs-selector-class">.node</span><br><br>（<span class="hljs-number">3</span>）如果 X 不带路径<br>　　<span class="hljs-selector-tag">a</span>. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　<span class="hljs-selector-tag">b</span>. 依次在每个目录中，将 X 当成文件名或目录名加载。<br><br>（<span class="hljs-number">4</span>）抛出 <span class="hljs-string">&quot;not found&quot;</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p><h4 id="136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript <span class="hljs-built_in">Promise</span> 的标准，规定了一个 <span class="hljs-built_in">Promise</span> 所必须具有的特性。<br><br><span class="hljs-built_in">Promise</span> 是一个构造函数，接收一个函数作为参数，返回一个 <span class="hljs-built_in">Promise</span> 实例。一个 <span class="hljs-built_in">Promise</span> 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们<br>可以在异步操作结束后调用这两个函数改变 <span class="hljs-built_in">Promise</span> 实例的状态，它的原型上定义了一个 <span class="hljs-keyword">then</span> 方法，使用这个 <span class="hljs-keyword">then</span> 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566">《Promises&#x2F;A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p><h4 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED</span> = <span class="hljs-string">&quot;resolved&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 保存初始化状态</span><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">PENDING</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 用于保存 reject 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 状态转变为 resolved 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">RESOLVED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 状态转变为 rejected 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将两个方法传入函数执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span><br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br>  onResolved =<br>    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span><br>      ? onResolved<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>          <span class="hljs-keyword">return</span> value;<br>        &#125;;<br><br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>          <span class="hljs-keyword">throw</span> error;<br>        &#125;;<br><br>  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onResolved);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">RESOLVED</span>) &#123;<br>    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">用 <span class="hljs-keyword">JS </span>设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。<br></code></pre></td></tr></table></figure><h4 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>统计使用浏览器的 window.error 事件。<br></code></pre></td></tr></table></figure><h4 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。<br></code></pre></td></tr></table></figure><h4 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。<br></code></pre></td></tr></table></figure><h4 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。<br></code></pre></td></tr></table></figure><h4 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。<br></code></pre></td></tr></table></figure><h4 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 <span class="hljs-keyword">js </span>时间格式化的接口进行修改，这个时候就可以使用适配器模式。<br></code></pre></td></tr></table></figure><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p><h4 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">发布订阅模式其实属于广义上的观察者模式<br><br>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。<br><br>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p><h4 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Vue</span> 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。<br></code></pre></td></tr></table></figure><h4 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Vue 一共有<span class="hljs-number">8</span>个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<br><br>（<span class="hljs-number">1</span>）<span class="hljs-keyword">beforeCreate </span>钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。<br><br>（<span class="hljs-number">2</span>）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-keyword">beforeMount </span>钩子函数，在组件被挂载到页面之前触发。在 <span class="hljs-keyword">beforeMount </span>之前，会找到对应的 template，并编译成 render 函数。<br><br>（<span class="hljs-number">4</span>）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">beforeUpdate </span>钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。<br><br>（<span class="hljs-number">6</span>）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">beforeDestroy </span>钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。<br><br>（<span class="hljs-number">8</span>）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><br>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p><h4 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）父子组件间通信<br><br>第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事<br>件来向父组件发送数据。<br><br>第二种是通过 ref 属性给子组件设置一个名字。父组件通过 <span class="hljs-variable">$refs</span> 组件名来获得子组件，子组件通过 <span class="hljs-variable">$parent</span> 获得父组<br>件，这样也可以实现通信。<br><br>第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件<br>中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。<br><br>（2）兄弟组件间通信<br><br>第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实<br>例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。<br><br>第二种是通过 <span class="hljs-variable">$parent</span>.<span class="hljs-variable">$refs</span> 来获取到兄弟组件，也可以进行通信。<br><br>（3）任意组件之间<br><br>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。<br><br><br>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候<br>可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个<br>公共数据进行读写操作，这样达到了解耦的目的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p><h4 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。<br><br>（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。<br><br>（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h4 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">（1）全局的钩子函数 beforeEach 和 afterEach<br><br>beforeEach 有三个参数，<span class="hljs-keyword">to</span> 代表要进入的路由对象，<span class="hljs-keyword">from</span> 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 <span class="hljs-literal">false</span>，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 <span class="hljs-built_in">error</span> ，则导航终止，<span class="hljs-built_in">error</span> 传入错误的监听函数。<br><br>（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。<br><br>（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组<br>件内部直接进行定义的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h4 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-variable">$route</span> 是“路由信息对象”，包括<span class="hljs-built_in"> path</span>，params，hash，query，fullPath，matched<span class="hljs-built_in">，name</span> 等路由信息参数。而 <span class="hljs-variable">$router</span> 是“路由实例”对象包括了路由的跳转方法，钩子函数等。<br></code></pre></td></tr></table></figure><h4 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.prevent</span>: 提交事件不再重载页面；<span class="hljs-string">.stop</span>: 阻止单击事件冒泡；<span class="hljs-string">.self</span>: 当事件发生在该元素本身而不是子元素的时候会触发；<br></code></pre></td></tr></table></figure><h4 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lsl">vue 中 <span class="hljs-type">key</span> 值的作用可以分为两种情况来考虑。<br><br>第一种情况是 v-if 中使用 <span class="hljs-type">key</span>。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 <span class="hljs-type">key</span> 来唯一的标识一个元素，这个情况下，使用 <span class="hljs-type">key</span> 的元素不会被复用。这个时候 <span class="hljs-type">key</span> 的作用是用来标识一个独立的元素。<br><br>第二种情况是 v-for 中使用 <span class="hljs-type">key</span>。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 <span class="hljs-type">key</span> 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 <span class="hljs-type">key</span> 的作用是为了高效的更新渲染虚拟 DOM。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h4 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">computed</span> 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。<br><br>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br></code></pre></td></tr></table></figure><h4 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <span class="hljs-meta">keep</span>-alive 组件包裹需要保存的组件。<br></code></pre></td></tr></table></figure><h4 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">mixin</span> 用于全局混入，会影响到每个组件实例。<br><br>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h4 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）application/x-www-form-urlencoded<br><br>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL<br>转码。<br><br>（2）multipart/form-data<br><br>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。<br><br>（3）application/json<br><br>告诉服务器消息主体是序列化后的 JSON 字符串。<br><br>（4）text/xml<br><br>该种方式主要用来提交 XML 格式的数据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p><h4 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value),<br>      type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    type.<span class="hljs-title function_">pop</span>();<br><br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p><h4 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkNullObj</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p><h4 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><br><span class="hljs-comment">// 使用 let 块级作用域</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url, params, callback</span>) &#123;<br>  <span class="hljs-comment">// 判断是否含有参数</span><br>  <span class="hljs-keyword">let</span> queryString = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) === -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>  <span class="hljs-comment">// 添加参数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> params) &#123;<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>      queryString += k + <span class="hljs-string">&quot;=&quot;</span> + params[k] + <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理回调函数名</span><br>  <span class="hljs-keyword">let</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>      .<span class="hljs-title function_">toString</span>()<br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>),<br>    callbackName = <span class="hljs-string">&quot;myJsonp&quot;</span> + random;<br><br>  <span class="hljs-comment">// 添加回调函数</span><br>  queryString += <span class="hljs-string">&quot;callback=&quot;</span> + callbackName;<br><br>  <span class="hljs-comment">// 构建请求</span><br>  <span class="hljs-keyword">let</span> scriptNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>  scriptNode.<span class="hljs-property">src</span> = url + queryString;<br><br>  <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用回调函数</span><br>    <span class="hljs-title function_">callback</span>(...<span class="hljs-variable language_">arguments</span>);<br><br>    <span class="hljs-comment">// 删除这个引入的脚本</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">removeChild</span>(scriptNode);<br>  &#125;;<br><br>  <span class="hljs-comment">// 发起请求</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(scriptNode);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p><h4 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> topics = &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 注册监听函数</span><br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>      topics[topic].<span class="hljs-title function_">push</span>(handler);<br>    &#125;,<br><br>    <span class="hljs-comment">// 发布事件，触发观察者回调事件</span><br>    <span class="hljs-attr">publish</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, info</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) &#123;<br>          <span class="hljs-title function_">handler</span>(info);<br>        &#125;);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的一个观察者的回调事件</span><br>    <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-keyword">var</span> handlerIndex = -<span class="hljs-number">1</span>;<br>      topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (item === handler) &#123;<br>          handlerIndex = index;<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-keyword">if</span> (handlerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        topics[topic].<span class="hljs-title function_">splice</span>(handlerIndex, <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的所有观察者的回调事件</span><br>    <span class="hljs-attr">removeAll</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p><h4 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] || [];<br>    callbacks.<span class="hljs-title function_">push</span>(callback);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn !== callback);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, ...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    callbacks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>(...args);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">wrapFun</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-title function_">callback</span>(...args);<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, wrapFun);<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(event, wrapFun);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>);<br>&#125;;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-comment">//请写出以下输出结果：</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p><h4 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。<br><br>使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 <span class="hljs-built_in">Date</span> 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。<br><br>为了解决这两个不足之处，ECMAScript <span class="hljs-number">5</span>引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到<span class="hljs-number">1</span>毫秒<br>的千分之一（<span class="hljs-number">1</span>秒的百万分之一）。<br><br>navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。<br><br>loadEventEnd：返回当前网页 <span class="hljs-keyword">load</span> 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> t = performance.<span class="hljs-property">timing</span>;<br><span class="hljs-keyword">var</span> pageLoadTime = t.<span class="hljs-property">loadEventEnd</span> - t.<span class="hljs-property">navigationStart</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h4 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal">（<span class="hljs-number">1</span>）第一个字符必须是字母、下划线（_）或美元符号（<span class="hljs-variable">$）</span><br>（<span class="hljs-number">2</span>）余下的字符可以是下划线、美元符号或任何字母或数字字符<br><br>一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p><h4 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有<br>利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。<br></code></pre></td></tr></table></figure><h4 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Object.<span class="hljs-keyword">as</span><span class="hljs-meta">sign</span>() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br></code></pre></td></tr></table></figure><h4 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Math.ceil() <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 向上取整，函数返回一个大于或等于给定数字的最小整数。<br><br>Math.floor() <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 向下取整，函数返回一个小于或等于给定数字的最大整数。<br></code></pre></td></tr></table></figure><h4 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>, j &lt; <span class="hljs-number">9</span>; i++, j++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, j);<br>&#125;<br><br><span class="hljs-comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span><br><span class="hljs-comment">// 当判断语句为空时，循环会一直进行。</span><br></code></pre></td></tr></table></figure><h4 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？<br><br>解决办法：<br><br>（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。<br><br>（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。<br><br>（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。<br></code></pre></td></tr></table></figure><h4 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">在前端实现中我们一般通过 <span class="hljs-built_in">setTimeout</span> 和 <span class="hljs-built_in">setInterval</span> 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，<span class="hljs-built_in">setTimeout</span> 和 <span class="hljs-built_in">setInterval</span> 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。<br><br>一般解决倒计时中的误差的有这样两种办法：<br><br>（<span class="hljs-number">1</span>）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。<br><br>（<span class="hljs-number">2</span>）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 <span class="hljs-built_in">setTimeout</span> 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p><h4 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h4><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p><h4 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostWord</span>(<span class="hljs-params">article</span>) &#123;<br>  <span class="hljs-comment">// 合法性判断</span><br>  <span class="hljs-keyword">if</span> (!article) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 参数处理</span><br>  article = article.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>();<br><br>  <span class="hljs-keyword">let</span> wordList = article.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+/g</span>),<br>    visited = [],<br>    maxNum = <span class="hljs-number">0</span>,<br>    maxWord = <span class="hljs-string">&quot;&quot;</span>;<br><br>  article = <span class="hljs-string">&quot; &quot;</span> + wordList.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;  &quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br><br>  <span class="hljs-comment">// 遍历判断单词出现次数</span><br>  wordList.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">indexOf</span>(item) &lt; <span class="hljs-number">0</span>) &#123;<br><br>      <span class="hljs-comment">// 加入 visited </span><br>      visited.<span class="hljs-title function_">push</span>(item);<br><br>      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot; &quot;</span> + item + <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;g&quot;</span>),<br>        num = article.<span class="hljs-title function_">match</span>(word).<span class="hljs-property">length</span>;<br><br>      <span class="hljs-keyword">if</span> (num &gt; maxNum) &#123;<br>        maxNum = num;<br>        maxWord = item;<br>      &#125;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> maxWord + <span class="hljs-string">&quot;  &quot;</span> + maxNum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="175-ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#175-ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="175. ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>175. ele.getElementsByClassName和ele.querySelectorAll的区别？</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">element</span>.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection<br><span class="hljs-type">element</span>.querySelectorAll 返回一个非即时更新（静态的） NodeList<br>// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> list1 = parent.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> list2 = parent.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list1.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list2.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> newP = docuemnt.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;p&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">newP.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">parent.<span class="hljs-title function_">appendChild</span>(newP);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list1.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 4 (即时更新)</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list2.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3（非即时更新）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>// 在说下返回值<br>// HTMLCollection 和 NodeList 都是类数组形式<br>如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection<br>EventTarget - Node - Element - HTMLElement - HTMLDivElement<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">EventTarget - Node - Element - SVGElement - SVGPathElement</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement">MDN 上元素 div 继承关系</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react-router-dom</title>
    <link href="/2023/05/20/react-router-dom/"/>
    <url>/2023/05/20/react-router-dom/</url>
    
    <content type="html"><![CDATA[<h1 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h1><p>单页面应用（single page web application，SPA），就是只有一张 Web 页面的应用，整个 web 应用只加载一个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。</p><h2 id="单页面应用的优势和缺陷"><a href="#单页面应用的优势和缺陷" class="headerlink" title="单页面应用的优势和缺陷"></a>单页面应用的优势和缺陷</h2><ul><li>优点<ol><li>用户体验好. 切换页面不需要再次请求服务器获取页面,页面加载速度更快</li><li>减轻服务器压力. 因为只有一个 web 页面,视图切换时,不会再次向服务器发起请求</li></ol></li><li>缺点<ol><li>不利于 SEO. 因为所有的页面都在一个 web 页面中动态展示,SEO 效果不如静态页面</li><li>第一次加载耗时长. 整个应用的所有页面都写在一个 web 页面中,包裹 js 和 css 都打包成一个文件.第一次加载时就需要更长的时间</li></ol></li></ul><h2 id="单页面应用原理"><a href="#单页面应用原理" class="headerlink" title="单页面应用原理"></a>单页面应用原理</h2><p> 在单页 Web 应用程序中，当浏览器向服务器发出第一个请求时，服务器会发回 index.html 文件. 用户需要切换页面时,会改变浏览器地址的路径(但不发送请求). 路径发生变化之后,根据之前配置好的前端路由规则,找到与当前路径匹配的视图,让其视图展示.其他视图隐藏. 展示视图需要渲染的数据,通过 ajax 获取.然后在前端渲染</p><h2 id="实现单页面应用要处理的三个问题"><a href="#实现单页面应用要处理的三个问题" class="headerlink" title="实现单页面应用要处理的三个问题"></a>实现单页面应用要处理的三个问题</h2><ol><li>定义路径和视图的一一对应规则(前端路由)</li><li>监听浏览器地址栏路径的变化</li><li>当路径变化,根据前端路由找到对应的视图并展示,其他视图不展示(在 react 中每一个页面视图都是一个组件)</li></ol><h1 id="react-router-使用"><a href="#react-router-使用" class="headerlink" title="react-router 使用"></a>react-router 使用</h1><blockquote><p>react-router 提供了三个包:</p><ul><li><p>react-router 核心包</p></li><li><p>react-router-dom web 单页面应用使用的包,包含 react-router 核心包(我们下载并使用这个包)</p></li><li><p>react-router-native 原生 app 单页面应用使用的包,包含 react-router 核心包</p></li></ul></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>下包</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">npm i react-router-dom<br></code></pre></td></tr></table></figure></li><li><p>在入口文件中使用<code>BrowserRouter</code>包裹整个应用结构</p><blockquote><p><code>&lt;BrowserRouter&gt;</code>包裹整个应用,只需要使用一次。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;3,7-9&#125;">// index.js<br>import * as React from &#x27;react&#x27;<br>import * as ReactDOM from &#x27;react-dom/client&#x27;<br>import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;<br><br>ReactDOM.createRoot(document.getELementById(&#x27;root&#x27;)).render(<br>  &lt;BrowserRouter&gt;<br>    &lt;App /&gt;<br>  &lt;/BrowserRouter&gt;<br>  )<br></code></pre></td></tr></table></figure></li><li><p>在根组件中配置前端路由规则:</p><blockquote><p><code>&lt;Route&gt;</code> 用于配置前端路由规则</p><p><code>&lt;Routes&gt;</code> 每当路径发生变化时,都会查看其所有子 <code>&lt;Route&gt;</code> 元素以找到最佳匹配并呈现 UI</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;/* Route必须被Routes包裹 */&#125;</span><br><span class="language-xml">      &#123;/* Route写在哪里,则Route对应的组件就渲染在哪里(这一点只针对一级路由) */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        &#123;/* path属性用于定义路径  element属性用于定义当前路径所对应的组件 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Login</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        &#123;/* path也可以忽略 /  */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        &#123;/*Route 也可以不写element. 入按照下面的方式定义,则展示Demo组件的路径为: /users/xxx */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Demo</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用 Link 组件定义导航按钮</p><blockquote><p>作用: 修改浏览器的地址栏路径,并且不发送请求(最终渲染的是 a 标签)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Link</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>点击展示home页面<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;4-8,20-22&#125;">// App.js<br>import React from &#x27;react&#x27;<br>import &#123; Routes, Route, Link &#125; from &#x27;react-router-dom&#x27;<br>// 路由组件推荐使用懒加载的方式引入<br>const Home = React.lazy(()=&gt;import(&#x27;./pages/Home&#x27;))<br>const Login = React.lazy(()=&gt;import(&#x27;./pages/Login&#x27;))<br>const Test1 = React.lazy(()=&gt;import(&#x27;./pages/Test1&#x27;))<br>const Test2 = React.lazy(()=&gt;import(&#x27;./pages/Test2&#x27;))<br>import &#x27;./App.css&#x27;<br>export default function App() &#123;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;<br>        &lt;Link to=&quot;/login&quot;&gt;登录页&lt;/Link&gt;<br>        &lt;hr /&gt;<br>      &lt;/div&gt;<br>      &lt;Routes&gt;<br>        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;<br>          &#123;/*Route里面的Route就是嵌套路由,Test1和Test2渲染在Home组件中*/&#125;<br>          &lt;Route path=&quot;/home/test1&quot; element=&#123;&lt;Test1 /&gt;&#125;&gt;&lt;/Route&gt;<br>          &lt;Route path=&quot;/home/test2&quot; element=&#123;&lt;Test2 /&gt;&#125;&gt;&lt;/Route&gt;<br>        &lt;/Route&gt;<br>        &lt;Route path=&quot;/login&quot; element=&#123;&lt;Login /&gt;&#125;&gt;&lt;/Route&gt;<br>      &lt;/Routes&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;12,13&#125;">// Home.js<br>import React from &#x27;react&#x27;<br>import &#123; Link, Outlet &#125; from &#x27;react-router-dom&#x27;<br><br>export default function Home() &#123;<br>  return (<br>    &lt;div style=&#123;&#123; height: &#x27;100vh&#x27;, backgroundColor: &#x27;pink&#x27; &#125;&#125;&gt;<br>      &lt;h1&gt;home&lt;/h1&gt;<br>      &lt;Link to=&quot;/home/test1&quot;&gt;test1&lt;/Link&gt; &lt;br /&gt;<br>      &lt;Link to=&quot;/home/test2&quot;&gt;test2&lt;/Link&gt;<br>      &lt;hr /&gt;<br>      &#123;/*Outlet组件决定了嵌套路由组件渲染的位置*/&#125;<br>      &lt;Outlet&gt;&lt;/Outlet&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><blockquote><p>通过运行代码导致的页面切换被叫做编程式导航</p></blockquote><p>页面切换有两种场景:</p><ol><li><p>用户点击导航按钮</p></li><li><p>程序运行到某个指定阶段自动切换页面(比如: 登录成功之后,页面自动切换到首页)</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>引入<code>useNavigate</code>并调用,返回一个函数.执行返回的函数就可以实现编程式导航</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;3&#125;">import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;<br>export default function Test2() &#123;<br>  const navigate = useNavigate()<br>  const handle = () =&gt; &#123;<br>    //  navigate(&#x27;目标页面的路径&#x27;, &#123;<br>    //   replace: true, // 是否开启替换历史记录 true为开启,默认值是false<br>    // &#125;)<br>    navigate(&#x27;/login&#x27;, &#123;<br>      replace: true<br>    &#125;)<br><br>    // 或 navigate(-1) //类似于history.go()方法<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>      &lt;h1&gt;test2&lt;/h1&gt;<br>      &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h1><blockquote><p>路由传参是值: 页面切换的时候,给目标页面传递数据</p></blockquote><p>路由传参有三种方式:</p><ol><li><p>路由参数(数据在路径中,只能传递简单数据)</p></li><li><p>state(可以传递任何数据)</p></li><li><p>查询字符串(不推荐)</p></li></ol><h2 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h2><ol><li><p>定义路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      &#123;/*:id 为路由参数(必填), 可以配置多个*/&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;about/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      &#123;/*:id 为可选路由参数 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 切换页面的时候传递</span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/about/1&#x27;</span>) <span class="hljs-comment">//这个1就是路由参数</span><br>&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/about/2&quot;</span>&gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span> <span class="hljs-comment">//2 和 3 就是路由参数</span><br></code></pre></td></tr></table></figure></li><li><p>接收路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 在目标路由组件中接收</span><br><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-comment">// params 是一个对象,里面可以获取到路由参数具体的值</span><br><span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParmas</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params) <span class="hljs-comment">// &#123;id:1&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><ol><li><p>传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/目标路径&quot;</span> state=&#123;要传递数据&#125;&gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/目标路径&quot;</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;要传递数据&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/目标路径&#x27;</span>, &#123;<br> <span class="hljs-attr">state</span>: 要传递的数据<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useLocaiton &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>()<br>location.<span class="hljs-property">state</span> <span class="hljs-comment">//可以获取到数据</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><ol><li><p>传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/目标路径?name=zs&amp;age=18&quot;</span> &gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/目标路径?name=zs&amp;age=18&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/目标路径?name=zs&amp;age=18&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>接收</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useSearchParams</span>()<br><span class="hljs-comment">// query是类似formdata对象,获取数据:query.get(&#x27;name&#x27;)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(query.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)) <span class="hljs-comment">// zs</span><br><span class="hljs-comment">// setQuery 可以修改地址栏查询字符串 setQuery(&quot;x=1&amp;y=2&quot;)</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="通过路由表定义路由规则"><a href="#通过路由表定义路由规则" class="headerlink" title="通过路由表定义路由规则"></a>通过路由表定义路由规则</h1><p>实际开发中一般会使用<code>路由表</code>动态创建<code>Routes</code>和<code>Route</code>.</p><p>路由表其实就是一个数组,如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-comment">//path 对应 Route的path</span><br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Home</span>&gt;</span></span>, <span class="hljs-comment">//element 对应Route的element</span><br>    <span class="hljs-comment">// children 对应 嵌套路由</span><br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test1</span>&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;test2&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test2</span>&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;:id&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">About</span>&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">About</span>&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><h2 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h2><p>调用 <code>useRoutes</code>,传入<code>路由表</code>,返回动态创建的 <code>Routes</code> 和 <code>Route</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span> <span class="hljs-comment">//引入路由表</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;useRoutes(routes)&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 上面的useRoutes返回的结果:</span><br>;&lt;Routes&gt;<br>  &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;<br>    &lt;Route path=&quot;test1&quot; element=&#123;&lt;Test1 /&gt;&#125;&gt;&lt;/Route&gt;<br>    &lt;Route path=&quot;test2&quot; element=&#123;&lt;Test2 /&gt;&#125;&gt;&lt;/Route&gt;<br>  &lt;/Route&gt;<br>  &lt;Route path=&quot;about&quot; &gt;<br>    &lt;Route path=&quot;:id&quot; element=&#123;&lt;About /&gt;&#125;&gt;<br>    &lt;Route path=&quot;&quot; element=&#123;&lt;About /&gt;&#125;&gt;<br>  &lt;/Route&gt;<br>&lt;/Routes&gt;<br></code></pre></td></tr></table></figure><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><h2 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h2><blockquote><p>作用: 与 Link 组件一样,但是可以快速实现导航高亮</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 注意: 默认类名是active, 下面是自定义的style和类名</span><br>&lt;<span class="hljs-title class_">NavLink</span><br>    to=<span class="hljs-string">&quot;login&quot;</span><br>    style=&#123;<span class="hljs-function">(<span class="hljs-params">&#123; isActive &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;login&#x27;</span>, isActive)<br>        <span class="hljs-keyword">return</span> isActive ? activeStyle : <span class="hljs-literal">undefined</span><br>    &#125;&#125;&gt;<br>        login<br>&lt;/<span class="hljs-title class_">NavLink</span>&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;(&#123;</span> <span class="hljs-attr">isActive</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(&#x27;home&#x27;, isActive)</span><br><span class="language-xml">        return isActive ? &#x27;base one&#x27; : &#x27;base&#x27;</span><br><span class="language-xml">    &#125;&#125;&gt;</span><br><span class="language-xml">        home</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><br><span class="hljs-comment">// 注意:  默认,当Home的子组件匹配成功,Home的导航也会高亮.当NavLink上添加了end属性,则Home的子组件匹配成功的时候,Home的导航没有高亮效果</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">end</span></span></span><br><span class="hljs-tag"><span class="language-xml">&gt;</span></span><br><span class="language-xml">        home</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="Navigate"><a href="#Navigate" class="headerlink" title="Navigate"></a>Navigate</h2><blockquote><p>只要 Navigate 组件被解析,就会修改路径,切换视图</p><p>一般用来展示 404 页面</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useRoutes</span>([<br>  &#123;<br>    ...忽略,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span> /&gt;</span></span>,<br>  &#125;,<br>])<br></code></pre></td></tr></table></figure><h2 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h2><blockquote><p>作用与 BrowserRouter 一样,但是修改的是地址栏的 hash 值.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript面试题</title>
    <link href="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/"/>
    <url>/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-面试题汇总"><a href="#JavaScript-面试题汇总" class="headerlink" title="JavaScript 面试题汇总"></a><em>JavaScript</em> 面试题汇总</h1><h3 id="1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的"><a href="#1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的" class="headerlink" title="1. 根据下面 ES6 构造函数的书写方式，要求写出 ES5 的"></a>1. 根据下面 <em>ES6</em> 构造函数的书写方式，要求写出 <em>ES5</em> 的</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">kotlin复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123; <br>  <span class="hljs-keyword">constructor</span>(name) &#123; <br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">init</span>() &#123; <br>    <span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-params">()</span></span> =&gt; &#123; console.log(<span class="hljs-keyword">this</span>.name) &#125;<br>    <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>; <br>  &#125; <br>&#125;<br><span class="hljs-keyword">const</span> e = new Example(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>e.<span class="hljs-keyword">init</span>();<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">name</span>) &#123;<br>      <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Class constructor cannot be invoked without new&#x27;</span>);<br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Example</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;init&#x27;</span>, &#123;<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;init is not a constructor&#x27;</span>);<br>           &#125;<br>           <span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>           &#125;<br>           fun.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>      &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>解析：</p><p>此题的关键在于是否清楚 <em>ES6</em> 的 <em>class</em> 和普通构造函数的区别，记住它们有以下区别，就不会有遗漏：</p><ol><li><p><em>ES6</em> 中的 <em>class</em> 必须通过 <em>new</em> 来调用，不能当做普通函数调用，否则报错</p><p>因此，在答案中，加入了 <em>new.target</em> 来判断调用方式</p></li><li><p><em>ES6</em> 的 <em>class</em> 中的所有代码均处于严格模式之下</p></li></ol><p>因此，在答案中，无论是构造函数本身，还是原型方法，都使用了严格模式</p><ol><li><p><em>ES6</em> 中的原型方法是不可被枚举的</p><p>因此，在答案中，定义原型方法使用了属性描述符，让其不可枚举</p></li><li><p>原型上的方法不允许通过 <em>new</em> 来调用</p><p>因此，在答案中，原型方法中加入了 <em>new.target</em> 来判断调用方式</p></li></ol></blockquote><h3 id="2-数组去重有哪些方法？（美团-19-年）"><a href="#2-数组去重有哪些方法？（美团-19-年）" class="headerlink" title="2. 数组去重有哪些方法？（美团 19 年）"></a>2. 数组去重有哪些方法？（美团 <em>19</em> 年）</h3><blockquote><p>参考答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 数字或字符串数组去重，效率高</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>      <span class="hljs-keyword">var</span> result = &#123;&#125;; <span class="hljs-comment">// 利用对象属性名的唯一性来保证不重复</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (!result[arr[i]]) &#123;<br>               result[arr[i]] = <span class="hljs-literal">true</span>;<br>           &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(result); <span class="hljs-comment">// 获取对象所有属性名的数组</span><br>&#125;<br><br><span class="hljs-comment">// 任意数组去重，适配范围光，效率低</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>      <span class="hljs-keyword">var</span> result = []; <span class="hljs-comment">// 结果数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (!result.<span class="hljs-title function_">includes</span>(arr[i])) &#123;<br>               result.<span class="hljs-title function_">push</span>(arr[i]);<br>           &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 利用ES6的Set去重，适配范围广，效率一般，书写简单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>      <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="3-描述下列代码的执行结果"><a href="#3-描述下列代码的执行结果" class="headerlink" title="3. 描述下列代码的执行结果"></a>3. 描述下列代码的执行结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">foo</span>(<span class="hljs-keyword">typeof</span> a);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">p</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> b);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>报错，报错的位置在 <code>console.log(typeof b);</code></p><p>报错原因：<em>ReferenceError: Cannot access ‘b’ before initialization</em></p></blockquote><blockquote><p>解析：</p><p>这道题考查的是 <em>ES6</em> 新增的声明变量关键字 <em>let</em> 以及暂时性死区的知识。<em>let</em> 和以前的 <em>var</em> 关键字不一样，无法在 <em>let</em> 声明变量之前访问到该变量，所以在 <em>typeof b</em> 的地方就会报错。</p></blockquote><h3 id="4-描述下列代码的执行结果"><a href="#4-描述下列代码的执行结果" class="headerlink" title="4. 描述下列代码的执行结果"></a>4. 描述下列代码的执行结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arr</span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = arr; <br>    &#125;<br>    <span class="hljs-title function_">bar</span>(<span class="hljs-params">n</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">arr</span>);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>[ 0 ]<br> [ 1 ]<br> [ 0, 1, 2, 3 ]</p></blockquote><blockquote><p>解析：</p><p>主要考察的是数组相关的知识。 <em>f</em> 对象上面有一个属性 <em>arr</em>，<em>arr</em> 的值在初始化的时候会被初始化为 <em>[0, 1, 2, 3]</em> ，之后就完全是考察数组以及数组方法的使用了。</p></blockquote><h3 id="5-描述下列代码的执行结果"><a href="#5-描述下列代码的执行结果" class="headerlink" title="5. 描述下列代码的执行结果"></a>5. 描述下列代码的执行结果</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-number">01</span> function <span class="hljs-built_in">f</span>(count) &#123;<br><span class="hljs-number">02</span>    console<span class="hljs-selector-class">.log</span>(`foo$&#123;count&#125;`);<br><span class="hljs-number">03</span>    <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123; console<span class="hljs-selector-class">.log</span>(`bar$&#123;count&#125;`); &#125;);<br><span class="hljs-number">04</span> &#125;<br><span class="hljs-number">05</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">06</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>);<br><span class="hljs-number">07</span> <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123; <span class="hljs-built_in">f</span>(<span class="hljs-number">3</span>); &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>foo1<br> foo2<br> bar1<br> bar2<br> foo3<br> bar3</p></blockquote><blockquote><p>解析：</p><p>这个完全是考察的异步的知识。调用 <em>f(1)</em>  的时候，会执行同步代码，打印出 <em>foo1</em>，然后 <em>03</em> 行的 <em>setTimeout</em> 被放入到异步执行队列，接下来调用 <em>f(2)</em>  的时候，打印出 <em>foo2</em>，后面 <em>03</em> 行的 <em>setTimeout</em> 又被放入到异步执行队列。然后执行 <em>07</em> 行的语句，被放入到异步执行队列。至此，所有同步代码就都执行完毕了。</p><p>接下来开始执行异步代码，那么大家时间没写，就都是相同的，所以谁先被放入到异步队列，谁就先执行，所以先打印出 <em>bar1</em>、然后是 <em>bar2</em>，接下来执行之前 <em>07</em> 行放入到异步队列里面的 <em>setTimeout</em>，先执行 <em>f</em> 函数里面的同步代码，打印出 <em>foo3</em>，然后是最后一个异步，打印出 <em>bar3</em></p></blockquote><h3 id="6-描述下列代码的执行结果"><a href="#6-描述下列代码的执行结果" class="headerlink" title="6. 描述下列代码的执行结果"></a>6. 描述下列代码的执行结果</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>var <span class="hljs-attr">b</span> = <span class="hljs-number">5</span><span class="hljs-comment">;</span><br>console.log(<span class="hljs-attr">a</span> === <span class="hljs-number">2</span> || <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">3</span> || <span class="hljs-number">4</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p><em>true</em></p><p>考察的是逻辑运算符。在 || 里面，只要有一个为真，后面的直接短路，都不用去计算。所以 <em>a &#x3D;&#x3D;&#x3D; 2</em> 得到 <em>true</em> 之后直接短路了，返回 <em>true</em>。</p></blockquote><h3 id="7-描述下列代码的执行结果"><a href="#7-描述下列代码的执行结果" class="headerlink" title="7. 描述下列代码的执行结果"></a>7. 描述下列代码的执行结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ButtonWrapper</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">domBtnEl, hash</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">domBtnEl</span> = domBtnEl;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hash</span> = hash;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindEvent</span>();<br>    &#125;<br>    <span class="hljs-title function_">bindEvent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">domBtnEl</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickEvent</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-title function_">detachEvent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">domBtnEl</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickEvent</span>);<br>    &#125;<br>    <span class="hljs-title function_">clickEvent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The hash of the button is: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.hash&#125;</span>`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>上面的代码导出了一个 <em>ButtonWrapper</em> 类，该类在被实例化的时候，实例化对象上面有两个属性，分别是 <em>domBtnEl</em> 和 <em>hash</em>，<em>domBtnEl</em> 是一个 <em>DOM</em> 节点，之后为这个 <em>domBtnEl</em> 绑定了点击事件，点击后打印出 <em>The hash of the button is: hash</em> 那句话。<em>detachEvent</em> 是移除点击事件，当调用实例化对象的 <em>detachEvent</em> 方法时，点击事件就会被移除。</p></blockquote><h3 id="8-箭头函数有哪些特点"><a href="#8-箭头函数有哪些特点" class="headerlink" title="8. 箭头函数有哪些特点"></a>8. 箭头函数有哪些特点</h3><blockquote><p>参考答案：</p><ol><li>更简洁的语法，例如<ul><li>只有一个形参就不需要用括号括起来</li><li>如果函数体只有一行，就不需要放到一个块中</li><li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li></ul></li><li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li><li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li></ol></blockquote><h3 id="9-说一说类的继承"><a href="#9-说一说类的继承" class="headerlink" title="9. 说一说类的继承"></a>9. 说一说类的继承</h3><blockquote><p>参考答案：</p><p>继承是面向对象编程中的三大特性之一。</p><p><em>JavaScript</em> 中的继承经过不断的发展，从最初的对象冒充慢慢发展到了今天的圣杯模式继承。</p><p>其中最需要掌握的就是<strong>伪经典继承</strong>和<strong>圣杯模式</strong>的继承。</p><p>很长一段时间，JS 继承使用的都是<strong>组合继承</strong>。这种继承也被称之为伪经典继承，该继承方式综合了原型链和盗用构造函数的方式，将两者的优点集中了起来。</p><p>组合继承弥补了之前原型链和盗用构造函数这两种方式各自的不足，是 <em>JavaScript</em> 中使用最多的继承方式。</p><p>组合继承最大的问题就是效率问题。最主要就是父类的构造函数始终会被调用两次：一次是在创建子类原型时调用，另一次是在子类构造函数中调用。</p><p>本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p><p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p></blockquote><blockquote><p>解析：该题主要考察就是对 <em>js</em> 中的继承是否了解，以及常见的继承的形式有哪些。最常用的继承就是<strong>组合继承</strong>（伪经典继承）和圣杯模式继承。下面附上 <em>js</em> 中这两种继承模式的详细解析。</p><p>下面是一个组合继承的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-string">&quot;this is a test&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">testFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a testFunc&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Student</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age, gender, score</span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [name, age]); <span class="hljs-comment">// 盗用构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// 改变 Student 构造函数的原型对象</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">testStuFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a testStuFunc&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> zhangsan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">name</span>); <span class="hljs-comment">// 张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">age</span>); <span class="hljs-comment">// 18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">gender</span>); <span class="hljs-comment">// 男</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">score</span>); <span class="hljs-comment">// 100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">test</span>); <span class="hljs-comment">// this is a test</span><br>zhangsan.<span class="hljs-title function_">testFunc</span>(); <span class="hljs-comment">// this is a testFunc</span><br>zhangsan.<span class="hljs-title function_">testStuFunc</span>(); <span class="hljs-comment">// this is a testStuFunc</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，我们使用了组合继承的方式来实现继承，可以看到无论是基类上面的属性和方法，还是子类自己的属性和方法，都得到了很好的实现。</p><p>但是在组合继承中存在效率问题，比如在上面的代码中，我们其实调用了两次 <em>Person</em>，产生了两组 <em>name</em> 和 <em>age</em> 属性，一组在原型上，一组在实例上。</p><p>也就是说，我们在执行 <em>Student.prototype &#x3D; new Person( )</em>  的时候，我们是想要 <em>Person</em> 原型上面的方法，属性是不需要的，因为属性之后可以通过 <em>Person.apply(this, [name, age])</em>  拿到，但是当你 <em>new Person( )</em>  的时候，会实例化一个 <em>Person</em> 对象出来，这个对象上面，属性和方法都有。</p><p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p><p>下面是一个圣杯模式的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// target 是子类，origin 是基类</span><br><span class="hljs-comment">// target ---&gt; Student, origin ---&gt; Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">target, origin</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123; &#125;; <span class="hljs-comment">// 没有任何多余的属性</span><br><br>    <span class="hljs-comment">// origin.prototype === Person.prototype, origin.prototype.constructor === Person 构造函数</span><br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = origin.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><br>    <span class="hljs-comment">// 假设 new F() 出来的对象叫小 f</span><br>    <span class="hljs-comment">// 那么这个 f 的原型对象 === F.prototype === Person.prototype</span><br>    <span class="hljs-comment">// 那么 f.constructor === Person.prototype.constructor === Person 的构造函数</span><br>    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br><br>    <span class="hljs-comment">// 而 f 这个对象又是 target 对象的原型对象</span><br>    <span class="hljs-comment">// 这意味着 target.prototype.constructor === f.constructor</span><br>    <span class="hljs-comment">// 所以 target 的 constructor 会指向 Person 构造函数</span><br><br>    <span class="hljs-comment">// 我们要让子类的 constructor 重新指向自己</span><br>    <span class="hljs-comment">// 若不修改则会发现 constructor 指向的是父类的构造函数</span><br>    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = target;<br>&#125;<br><br><br><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-string">&quot;this is a test&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">testFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a testFunc&#x27;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Student</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age, gender, score</span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [name, age]);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 使用圣杯模式实现继承</span><br><span class="hljs-comment">// 在子类上面添加方法</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">testStuFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a testStuFunc&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> zhangsan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">100</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">name</span>); <span class="hljs-comment">// 张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">age</span>); <span class="hljs-comment">// 18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">gender</span>); <span class="hljs-comment">// 男</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">score</span>); <span class="hljs-comment">// 100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zhangsan.<span class="hljs-property">test</span>); <span class="hljs-comment">// this is a test</span><br>zhangsan.<span class="hljs-title function_">testFunc</span>(); <span class="hljs-comment">// this is a testFunc</span><br>zhangsan.<span class="hljs-title function_">testStuFunc</span>(); <span class="hljs-comment">// this is a testStuFunc</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们在 <em>inherit</em> 方法中创建了一个中间层，之后让 <em>F</em> 的原型和父类的原型指向同一地址，再让子类的原型指向这个 <em>F</em> 的实例化对象来实现了继承。</p><p>这样我们的继承，属性就不会像之前那样实例对象上一份，原型对象上一份，拥有两份。圣杯模式继承是目前 <em>js</em> 继承的最优解。</p><p>最后我再画个图帮助大家理解，如下图：</p><p>组合模式（伪经典模式）下的继承示意图：</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/4550d93c80d64574854729dcdff963bdtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210808102111003"><p>圣杯模式下的继承示意图：</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/d47742fb22584c429c83e45b7e6b06dbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210808101303180"></blockquote><h3 id="10-new-操作符都做了哪些事？"><a href="#10-new-操作符都做了哪些事？" class="headerlink" title="10. new 操作符都做了哪些事？"></a>10. <em>new</em> 操作符都做了哪些事？</h3><blockquote><p>参考答案：</p><p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p><em>new</em> 关键字会进行如下的操作：<br> 步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br> 步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br> 步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br> 步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p></blockquote><h3 id="11-call、apply、bind-的区别-？"><a href="#11-call、apply、bind-的区别-？" class="headerlink" title="11. call、apply、bind 的区别 ？"></a>11. <em>call、apply、bind</em> 的区别 ？</h3><blockquote><p>参考答案：</p><p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p><ul><li><em>fn.call(obj, arg1, arg2, …)</em>  调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li><li><em>fn.apply(obj, [argsArray])</em>  调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li></ul><p><em>bind</em> 和 <em>call&#x2F;apply</em> 有一个很重要的区别，一个函数被 <em>call&#x2F;apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em>  的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p></blockquote><h3 id="12-事件循环机制（宏任务、微任务）"><a href="#12-事件循环机制（宏任务、微任务）" class="headerlink" title="12. 事件循环机制（宏任务、微任务）"></a>12. 事件循环机制（宏任务、微任务）</h3><blockquote><p>参考答案：</p><p>在 <em>js</em> 中任务会分为同步任务和异步任务。</p><p>如果是同步任务，则会在主线程（也就是 <em>js</em> 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。</p><p>当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。</p><p>一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（<em>js</em> 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。</p><p>在 <em>js</em> 中，任务队列中的任务又可以被分为 <em>2</em> 种类型：宏任务（<em>macrotask</em>）与微任务（<em>microtask</em>）</p><p>宏任务可以理解为每次执行栈所执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中所执行的任务。</p><p>微任务可以理解为当前宏任务执行结束后立即执行的任务。</p></blockquote><h3 id="13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变"><a href="#13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变" class="headerlink" title="13. 你了解 node 中的事件循环机制吗？node11 版本以后有什么改变"></a>13. 你了解 <em>node</em> 中的事件循环机制吗？<em>node11</em> 版本以后有什么改变</h3><blockquote><p>参考答案：</p><p><em>Node.js</em> 在主线程里维护了一个**事件队列，**当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时（没有请求接入时），就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 *I&#x2F;O* 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 *I&#x2F;O* 任务，就从**线程池**中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p><p>当线程中的 <em>I&#x2F;O</em> 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 <strong>事件循环</strong> (<em>Event Loop</em>)。</p><p>无论是 <em>Linux</em> 平台还是 <em>Windows</em> 平台，<em>Node.js</em> 内部都是通过<strong>线程池</strong>来完成异步 <em>I&#x2F;O</em> 操作的，而 <em>LIBUV</em> 针对不同平台的差异性实现了统一调用。因此，*<strong>Node.js* 的单线程仅仅是指 *JavaScript* 运行在单线程中，而并非 *Node.js* 是单线程。</strong></p><p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p><ul><li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li><li><em>I&#x2F;O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I&#x2F;O</em> 回调</li><li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li><li><em>poll</em> 阶段：获取新的 <em>I&#x2F;O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li><li><em>check</em> 阶段：执行 <em>setImmediate( )</em>  的回调</li><li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li></ul><p>事件循环的执行顺序为：</p><p>外部输入数据 –-&gt; 轮询阶段（ <em>poll</em> ）-–&gt; 检查阶段（ <em>check</em> ）-–&gt; 关闭事件回调阶段（ <em>close callback</em> ）–-&gt; 定时器检测阶段（ <em>timer</em> ）–-&gt; <em>I&#x2F;O</em> 事件回调阶段（ <em>I&#x2F;O callbacks</em> ）-–&gt;闲置阶段（ <em>idle、prepare</em> ）–-&gt;轮询阶段（按照该顺序反复运行）…</p><p>浏览器和 <em>Node.js</em> 环境下，微任务任务队列的执行时机不同</p><ul><li><em>Node.js</em> 端，微任务在事件循环的各个阶段之间执行</li><li>浏览器端，微任务在事件循环的宏任务执行完之后执行</li></ul><p><em>Node.js v11.0.0</em> 版本于 <em>2018</em> 年 <em>10</em> 月，主要有以下变化：</p><ol><li><em>V8</em> 引擎更新至版本 <em>7.0</em></li><li><em>http、https</em> 和 <em>tls</em> 模块默认使用 <em>WHESWG URL</em> 解析器。</li><li>隐藏子进程的控制台窗口默认改为了 <em>true</em>。</li><li><em>FreeBSD 10</em>不再支持。</li><li>增加了多线程 <em>Worker Threads</em></li></ol></blockquote><h3 id="14-什么是函数柯里化？"><a href="#14-什么是函数柯里化？" class="headerlink" title="14. 什么是函数柯里化？"></a>14. 什么是函数柯里化？</h3><blockquote><p>参考答案：</p><p>柯里化（<em>currying</em>）又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><p>举个例子，就是把原本：</p><p><em>function(arg1,arg2)</em>  变成 <em>function(arg1)(arg2)</em><br> <em>function(arg1,arg2,arg3)</em>  变成 <em>function(arg1)(arg2)(arg3)</em><br> <em>function(arg1,arg2,arg3,arg4)</em>  变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p><p>总而言之，就是将：</p><p><em>function(arg1,arg2,…,argn)</em>  变成 <em>function(arg1)(arg2)…(argn)</em></p></blockquote><h3 id="15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？"><a href="#15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？" class="headerlink" title="15. promise.all 方法的使用场景？数组中必须每一项都是 promise 对象吗？不是 promise 对象会如何处理 ？"></a>15. <em>promise.all</em> 方法的使用场景？数组中必须每一项都是 <em>promise</em> 对象吗？不是 <em>promise</em> 对象会如何处理 ？</h3><blockquote><p>参考答案：</p><p>*<strong>promise.all(promiseArray)</strong> * 方法是 <em>promise</em> 对象上的静态方法，该方法的作用是将多个 <em>promise</em> 对象实例包装，生成并返回一个新的 <em>promise</em> 实例。</p><p>此方法在集合多个 <em>promise</em> 的返回结果时很有用。</p><p>返回值将会按照参数内的 <em>promise</em> 顺序排列，而不是由调用 <em>promise</em> 的完成顺序决定。</p><p>*<strong>promise.all* 的特点</strong></p><p>接收一个<em>Promise</em>实例的数组或具有<em>Iterator</em>接口的对象</p><p>如果元素不是<em>Promise</em>对象，则使用<em>Promise.resolve</em>转成<em>Promise</em>对象</p><p>如果全部成功，状态变为<em>resolved</em>，返回值将组成一个数组传给回调</p><p>只有有一个失败，状态就变为 <em>rejected</em>，返回值将直接传递给回调 *all( )*的返回值，也是新的 <em>promise</em> 对象</p></blockquote><h3 id="16-this-的指向哪几种-？"><a href="#16-this-的指向哪几种-？" class="headerlink" title="16. this 的指向哪几种 ？"></a>16. <em>this</em> 的指向哪几种 ？</h3><blockquote><p>参考答案：</p><p>总结起来，<em>this</em> 的指向规律有如下几条：</p><ul><li>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 <em>this</em> 会被绑定到 <em>undefined</em> 上，在非严格模式下则会被绑定到全局对象 <em>window&#x2F;global</em> 上。</li><li>一般使用 <em>new</em> 方法调用构造函数时，构造函数内的 <em>this</em> 会被绑定到新创建的对象上。</li><li>一般通过 <em>call&#x2F;apply&#x2F;bind</em> 方法显式调用函数时，函数体内的 <em>this</em> 会被绑定到指定参数的对象上。</li><li>一般通过上下文对象调用函数时，函数体内的 <em>this</em> 会被绑定到该对象上。</li><li>在箭头函数中，<em>this</em> 的指向是由外层（函数或全局）作用域来决定的。</li></ul></blockquote><h3 id="17-JS-中继承实现的几种方式"><a href="#17-JS-中继承实现的几种方式" class="headerlink" title="17. JS 中继承实现的几种方式"></a>17. <em>JS</em> 中继承实现的几种方式</h3><blockquote><p>参考答案：</p><p><em>JS</em> 的继承随着语言的发展，从最早的对象冒充到现在的圣杯模式，涌现出了很多不同的继承方式。每一种新的继承方式都是对前一种继承方式不足的一种补充。</p><ol><li>原型链继承</li></ol><ul><li>重点：让新实例的原型等于父类的实例。</li><li>特点：实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</li><li>缺点：<ul><li>1、新实例无法向父类构造函数传参。</li><li>2、继承单一。</li><li>3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li></ul></li></ul><ol><li>借用构造函数继承</li></ol><ul><li>重点：用 <em>call( )</em>  和 <em>apply( )</em>  将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</li><li>特点：<br> - 1、只继承了父类构造函数的属性，没有继承父类原型的属性。<ul><li>2、解决了原型链继承缺点1、2、3。</li><li>3、可以继承多个构造函数属性（call多个）。</li><li>4、在子实例中可向父实例传参。</li></ul></li><li>缺点：<br> - 1、只能继承父类构造函数的属性。<ul><li>2、无法实现构造函数的复用。（每次用每次都要重新调用）</li><li>3、每个新实例都有父类构造函数的副本，臃肿。</li></ul></li></ul><ol><li>组合模式（又被称之为伪经典模式）</li></ol><ul><li>重点：结合了两种模式的优点，传参和复用</li><li>特点：<br> - 1、可以继承父类原型上的属性，可以传参，可复用。<br> - 2、每个新实例引入的构造函数属性是私有的。</li><li>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</li></ul><ol><li>寄生组合式继承（圣杯模式）</li></ol><ul><li>重点：修复了组合继承的问题</li></ul></blockquote><h3 id="18-什么是事件监听"><a href="#18-什么是事件监听" class="headerlink" title="18. 什么是事件监听"></a>18. 什么是事件监听</h3><blockquote><p>参考答案：</p><p>首先需要区别清楚事件监听和事件监听器。</p><p>在绑定事件的时候，我们需要对应的书写一个事件处理程序，来应对事件发生时的具体行为。</p><p>这个事件处理程序我们也称之为事件监听器。</p><p>当事件绑定好后，程序就会对事件进行监听，当用户触发事件时，就会执行对应的事件处理程序。</p><p>关于事件监听，<em>W3C</em> 规范中定义了 <em>3</em> 个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p><ul><li><strong>捕获</strong>阶段：在事件对象到达事件目标之前，事件对象必须从 <em>window</em> 经过目标的祖先节点传播到事件目标。 这个阶段被我们称之为捕获阶段。在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件。</li><li><strong>目标</strong> 阶段：事件对象到达其事件目标。 这个阶段被我们称为目标阶段。一旦事件对象到达事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到达此阶段时就会终止传播。</li><li><strong>冒泡</strong> 阶段：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到 <em>window</em>。这个阶段被称之为冒泡阶段。在此阶段注册的事件监听器会对相应的冒泡事件进行处理。</li></ul></blockquote><h3 id="19-什么是-js-的闭包？有什么作用？"><a href="#19-什么是-js-的闭包？有什么作用？" class="headerlink" title="19. 什么是 js 的闭包？有什么作用？"></a>19. 什么是 <em>js</em> 的闭包？有什么作用？</h3><blockquote><p>参考答案：</p><p>一个函数和对其周围状态（<em>lexical environment</em>，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<em>closure</em>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 <em>JavaScript</em> 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p><p>闭包的用处：</p><ol><li>匿名自执行函数</li><li>结果缓存</li><li>封装</li><li>实现类和继承</li></ol></blockquote><h3 id="20-事件委托以及冒泡原理"><a href="#20-事件委托以及冒泡原理" class="headerlink" title="20. 事件委托以及冒泡原理"></a>20. 事件委托以及冒泡原理</h3><blockquote><p>参考答案：</p><p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p><p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p><p>对事件处理程序过多问题的解决方案就是事件委托。</p><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p><p>事件冒泡（<em>event bubbling</em>），是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><h3 id="21-let-const-var-的区别？什么是块级作用域？如何用？"><a href="#21-let-const-var-的区别？什么是块级作用域？如何用？" class="headerlink" title="21. let const var 的区别？什么是块级作用域？如何用？"></a>21. <em>let const var</em> 的区别？什么是块级作用域？如何用？</h3><blockquote><p>参考答案：</p><ol><li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li><li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li><li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li></ol><p>最初在 <em>JS</em> 中作用域有：全局作用域、函数作用域。没有块作用域的概念。</p><p><em>ES6</em> 中新增了块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p><p>在以前没有块作用域的时候，在 if 或者 for 循环中声明的变量会泄露成全局变量，其次就是 { } 中的内层变量可能会覆盖外层变量。块级作用域的出现解决了这些问题。</p></blockquote><h3 id="22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？"><a href="#22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？" class="headerlink" title="22. ES5 的方法实现块级作用域（立即执行函数） ES6 呢？"></a>22. <em>ES5</em> 的方法实现块级作用域（立即执行函数） <em>ES6</em> 呢？</h3><blockquote><p>参考答案：</p><p><em>ES6</em> 原生支持块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p><p>使用 <em>let</em> 声明的变量或者使用 <em>const</em> 声明的常量，只能在块作用域里访问，不能跨块访问。</p></blockquote><h3 id="23-ES6-箭头函数的特性"><a href="#23-ES6-箭头函数的特性" class="headerlink" title="23. ES6 箭头函数的特性"></a>23. <em>ES6</em> 箭头函数的特性</h3><blockquote><p>参考答案：</p><ol><li>更简洁的语法，例如<ul><li>只有一个形参就不需要用括号括起来</li><li>如果函数体只有一行，就不需要放到一个块中</li><li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li></ul></li><li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li><li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li></ol></blockquote><h3 id="24-箭头函数与普通函数的区别-？"><a href="#24-箭头函数与普通函数的区别-？" class="headerlink" title="24. 箭头函数与普通函数的区别 ？"></a>24. 箭头函数与普通函数的区别 ？</h3><blockquote><p>参考答案：</p><ol><li><p>外形不同。箭头函数使用箭头定义，普通函数中没有</p></li><li><p>普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</p></li><li><p>**箭头函数不能用于构造函数，不能使用 <em>new</em>，**普通函数可以用于构造函数，以此创建对象实例。</p></li><li><p><strong>箭头函数中 <em>this</em> 的指向不同，</strong>在普通函数中，<em>this</em> 总是指向调用它的对象，如果用作构造函数，<em>this</em> 指向创建的对象实例。<br> 箭头函数本身不创建 <em>this</em>，也可以说箭头函数本身没有 <em>this</em>，但是它在声明时可以捕获其所在上下文的 <em>this</em> 供自己使用。</p></li><li><p>每一个普通函数调用后都具有一个 <em>arguments</em> 对象，用来存储实际传递的参数。</p><p>但是箭头函数并没有此对象。<strong>取而代之用rest参数来解决</strong>。</p></li><li><p>箭头函数不能用于 <em>Generator</em> 函数，不能使用 <em>yeild</em> 关键字。</p></li><li><p>箭头函数不具有 <em>prototype</em> 原型对象。而普通函数具有 <em>prototype</em> 原型对象。</p></li><li><p>箭头函数不具有 <em>super</em>。</p></li><li><p>箭头函数不具有 <em>new.target</em>。</p></li></ol></blockquote><h3 id="25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别"><a href="#25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别" class="headerlink" title="25. JS 的基本数据类型有哪些？基本数据类型和引用数据类型的区别"></a>25. <em>JS</em> 的基本数据类型有哪些？基本数据类型和引用数据类型的区别</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p><p>基本数据类型，一共有 <em>6</em> 种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript<br>复制代码<span class="hljs-built_in">string</span>，<span class="hljs-built_in">symbol</span>，<span class="hljs-built_in">number</span>，<span class="hljs-built_in">boolean</span>，<span class="hljs-literal">undefined</span>，<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p><p>引用数据类型，就只有 <em>1</em> 种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp<br>复制代码<span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p><p>两者的区别在于：</p><p>**原始值是表示 *JavaScript* 中可用的数据或信息的最底层形式或最简单形式。**简单类型的值被称为原始值，是因为它们是**不可细化**的。</p><p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p><p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p><p>最后总结一下两者的区别：</p><ol><li>访问方式<ul><li>原始值：访问到的是值</li><li>引用值：访问到的是引用地址</li></ul></li><li>比较方式<ul><li>原始值：比较的是值</li><li>引用值：比较的是地址</li></ul></li><li>动态属性<ul><li>原始值：无法添加动态属性</li><li>引用值：可以添加动态属性</li></ul></li><li>变量赋值<ul><li>原始值：赋值的是值</li><li>引用值：赋值的是地址</li></ul></li></ol></blockquote><h3 id="26-NaN-是什么的缩写"><a href="#26-NaN-是什么的缩写" class="headerlink" title="26. NaN 是什么的缩写"></a>26. <em>NaN</em> 是什么的缩写</h3><blockquote><p>参考答案：</p><p><em>NaN</em> 的全称为 <em>Not a Number</em>，表示非数，或者说不是一个数。虽然 NaN 表示非数，但是它却属于 <em>number</em> 类型。</p><p><em>NaN</em> 有两个特点：</p><ol><li>任何涉及 <em>NaN</em> 的操作都会返回 <em>NaN</em></li><li><em>NaN</em> 和任何值都不相等，包括它自己本身</li></ol></blockquote><h3 id="27-JS-的作用域类型"><a href="#27-JS-的作用域类型" class="headerlink" title="27. JS 的作用域类型"></a>27. <em>JS</em> 的作用域类型</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 里面，作用域一共有 4 种：全局作用域，局部作用域、函数作用域以及 <em>eval</em> 作用域。</p><p><strong>全局作用域：</strong>这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。</p><p><strong>局部作用域：</strong>当使用 <em>let</em> 或者 <em>const</em> 声明变量时，这些变量在一对花括号中存在局部作用域，只能够在花括号内部进行访问使用。</p><p><strong>函数作用域：</strong>当进入到一个函数的时候，就会产生一个函数作用域。函数作用域里面所声明的变量只在函数中提供访问使用。</p><p><strong><em>eval</em> 作用域：</strong>当调用 <em>eval( )</em>  函数的时候，就会产生一个 <em>eval</em> 作用域。</p></blockquote><h3 id="28-undefined-x3D-x3D-null-返回的结果是什么？undefined-与-null-的区别在哪？"><a href="#28-undefined-x3D-x3D-null-返回的结果是什么？undefined-与-null-的区别在哪？" class="headerlink" title="28. undefined&#x3D;&#x3D;null 返回的结果是什么？undefined 与 null 的区别在哪？"></a>28. <em>undefined&#x3D;&#x3D;null</em> 返回的结果是什么？<em>undefined</em> 与 <em>null</em> 的区别在哪？</h3><blockquote><p>参考答案：</p><p>返回 <em>true</em>。</p><p>这两个值都表示“无”的意思。</p><p>通常情况下， 当我们试图访问某个不存在的或者没有赋值的变量时，就会得到一个 <em>undefined</em> 值。<em>Javascript</em> 会自动将声明是没有进行初始化的变量设为 <em>undifined</em>。</p><p>而 <em>null</em> 值表示空，<em>null</em> 不能通过 <em>Javascript</em> 来自动赋值，也就是说必须要我们自己手动来给某个变量赋值为 <em>null</em>。</p></blockquote><blockquote><p>解析：</p><p>那么为什么 <em>JavaScript</em> 要设置两个表示”无”的值呢？这其实是历史原因。</p><p><em>1995</em> 年 <em>JavaScript</em> 诞生时，最初像 <em>Java</em> 一样，只设置了 <em>null</em> 作为表示”无”的值。根据 <em>C</em> 语言的传统，<em>null</em> 被设计成可以自动转为<em>0</em>。</p><p>但是，<em>JavaScript</em> 的设计者，觉得这样做还不够，主要有以下两个原因。</p><ol><li><em>null</em> 像在 <em>Java</em> 里一样，被当成一个对象。但是，<em>JavaScript</em> 的数据类型分成原始类型（<em>primitive</em>）和合成类型（<em>complex</em>）两大类，作者觉得表示”无”的值最好不是对象。</li><li><em>JavaScript</em> 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者觉得，如果 <em>null</em> 自动转为 <em>0</em>，很不容易发现错误。</li></ol><p>因此，作者又设计了一个 <em>undefined</em>。</p><p><strong>这里注意：先有 *null* 后有 *undefined* 出来，*undefined* 是为了填补之前的坑。</strong></p><p><em>JavaScript</em> 的最初版本是这样区分的：</p><p><em>null</em> 是一个表示”无”的对象（空对象指针），转为数值时为 <em>0</em>；</p><p>典型用法是：</p><ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul><p><em>undefined</em> 是一个表示”无”的原始值，转为数值时为 <em>NaN</em>。</p><p>典型用法是：</p><ul><li>变量被声明了，但没有赋值时，就等于 <em>undefined</em>。</li><li>调用函数时，应该提供的参数没有提供，该参数等于 <em>undefined</em>。</li><li>对象没有赋值的属性，该属性的值为 <em>undefined</em>。</li><li>函数没有返回值时，默认返回 <em>undefined</em>。</li></ul></blockquote><h3 id="29-写一个函数判断变量类型"><a href="#29-写一个函数判断变量类型" class="headerlink" title="29. 写一个函数判断变量类型"></a>29. 写一个函数判断变量类型</h3><blockquote><p>参考答案：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span> = <span class="hljs-keyword">typeof</span> data;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span> !== <span class="hljs-string">&quot;object&quot;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^[object (\S+)]$/</span>,<span class="hljs-string">&#x27;$1&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])); <span class="hljs-comment">// Array</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(<span class="hljs-regexp">/abc/</span>)); <span class="hljs-comment">// RegExp</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>)); <span class="hljs-comment">// Date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>)); <span class="hljs-comment">// Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getType</span>(&#123;&#125;)); <span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="30-js-的异步处理函数"><a href="#30-js-的异步处理函数" class="headerlink" title="30. js 的异步处理函数"></a>30. <em>js</em> 的异步处理函数</h3><blockquote><p>参考答案：</p><p>在最早期的时候，<em>JavaScript</em> 中要实现异步操作，使用的就是 <em>Callback</em> 回调函数。</p><p>但是回调函数会产生回调地狱（<em>Callback Hell</em>）</p><p>之后 ES6 推出了 <em>Promise</em> 解决方案来解决回调地狱的问题。不过，虽然 <em>Promise</em> 作为 <em>ES6</em> 中提供的一种新的异步编程解决方案，但是它也有问题。比如，代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。</p><p>之后，就出现了基于 <em>Generator</em> 的异步解决方案。不过，这种方式需要编写外部的执行器，而执行器的代码写起来一点也不简单。当然也可以使用一些插件，比如 <em>co</em> 模块来简化执行器的编写。</p><p><em>ES7</em> 提出的 <em>async</em> 函数，终于让 <em>JavaScript</em> 对于异步操作有了终极解决方案。</p><p>实际上，<em>async</em> 只是生成器的一种语法糖而已，简化了外部执行器的代码，同时利用 <em>await</em> 替代 <em>yield</em>，<em>async</em> 替代生成器的<code>*</code>号。</p></blockquote><h3 id="31-defer-与-async-的区别"><a href="#31-defer-与-async-的区别" class="headerlink" title="31. defer 与 async 的区别"></a>31. <em>defer</em> 与 <em>async</em> 的区别</h3><blockquote><p>参考答案：</p><p>按照惯例，所有 <em>script</em> 元素都应该放在页面的 <em>head</em> 元素中。这种做法的目的就是把<strong>所有外部文件（*CSS* 文件和 *JavaScript* 文件）的引用都放在相同的地方</strong>。可是，在文档的 <em>head</em> 元素中包含所有 <em>JavaScript</em> 文件，意味着必须等到全部 <em>JavaScript</em> 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <em>body</em> 标签时才开始呈现内容）。</p><p>对于那些需要很多 <em>JavaScript</em> 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现在 *<strong>Web* 应用程序一般都全部 *JavaScript* 引用放在 *body* 元素中页面的内容后面</strong>。这样一来，在解析包含的 <em>JavaScript</em> 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p><p>有了 <em>defer</em> 和 <em>async</em> 后，这种局面得到了改善。</p><p>*<strong>defer* （延迟脚本）</strong></p><p>延迟脚本：<em>defer</em> 属性只适用于外部脚本文件。</p><p>如果给 <em>script</em> 标签定义了<em>defer</em> 属性，这个属性的作用是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，如果 <em>script</em> 元素中设置了 <em>defer</em> 属性，相当于告诉浏览器立即下载，但延迟执行。</p><p>*<strong>async*（异步脚本）</strong></p><p>异步脚本：<em>async</em> 属性也只适用于外部脚本文件，并告诉浏览器立即下载文件。</p><p><strong>但与 *defer* 不同的是：标记为 *async* 的脚本并不保证按照指定它们的先后顺序执行。</strong></p><p>所以总结起来，两者之间最大的差异就是在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的。</p><p><em>defer</em> 是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后，<em>DOMContentLoaded</em> 事件触发之前完成。<em>async</em> 是立即下载并执行，加载和渲染后续文档元素的过程将和 <em>js</em> 脚本的加载与执行并行进行（异步）。</p></blockquote><h3 id="32-浏览器事件循环和任务队列"><a href="#32-浏览器事件循环和任务队列" class="headerlink" title="32. 浏览器事件循环和任务队列"></a>32. 浏览器事件循环和任务队列</h3><blockquote><p>参考答案：</p><p><em>JavaScript</em> 的异步机制由事件循环和任务队列构成。</p><p><em>JavaScript</em> 本身是单线程语言，所谓异步依赖于浏览器或者操作系统等完成。<em>JavaScript</em> 主线程拥有一个执行栈以及一个任务队列，主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。</p><p>遇到异步操作（例如：<em>setTimeout、Ajax</em>）时，异步操作会由浏览器(<em>OS</em>)执行，浏览器会在这些任务完成后，将事先定义的回调函数推入主线程的任务队列(<em>task queue</em>)中,当主线程的执行栈清空之后会读取任务队列中的回调函数,当任务队列被读取完毕之后,主线程接着执行,从而进入一个无限的循环，这就是事件循环。</p></blockquote><h3 id="33-原型与原型链-（美团-19年）"><a href="#33-原型与原型链-（美团-19年）" class="headerlink" title="33. 原型与原型链 （美团 19年）"></a>33. 原型与原型链 （美团 19年）</h3><blockquote><p>参考答案：</p><ul><li>每个对象都有一个 <code>__proto__</code> 属性，该属性指向自己的原型对象</li><li>每个构造函数都有一个 <code>prototype</code> 属性，该属性指向实例对象的原型对象</li><li>原型对象里的 <code>constructor</code> 指向构造函数本身</li></ul><p>如下图：</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/4c9b041b778440e895578fcf64761a42tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210812161401493"><p>每个对象都有自己的原型对象，而原型对象本身，也有自己的原型对象，从而形成了一条原型链条。</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></blockquote><h3 id="34-作用域与作用域链-（美团-19年）"><a href="#34-作用域与作用域链-（美团-19年）" class="headerlink" title="34. 作用域与作用域链 （美团 19年）"></a>34. 作用域与作用域链 （美团 19年）</h3><blockquote><p>参考答案：</p><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。<em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域。<em>ES6</em> 的到来，为我们提供了块级作用域。</p><p>作用域链指的是作用域与作用域之间形成的链条。当我们查找一个当前作用域没有定义的变量（自由变量）的时候，就会向上一级作用域寻找，如果上一级也没有，就再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p></blockquote><h3 id="35-闭包及应用场景以及闭包缺点-（美团-19年）"><a href="#35-闭包及应用场景以及闭包缺点-（美团-19年）" class="headerlink" title="35. 闭包及应用场景以及闭包缺点 （美团 19年）"></a>35. 闭包及应用场景以及闭包缺点 （美团 19年）</h3><blockquote><p>参考答案：</p><p>闭包的应用场景：</p><ol><li>匿名自执行函数</li><li>结果缓存</li><li>封装</li><li>实现类和继承</li></ol><p>闭包的缺点：</p><p>因为闭包的作用域链会引用包含它的函数的活动对象，导致这些活动对象不会被销毁，因此会占用更多的内存。</p></blockquote><h3 id="36-继承方式-（美团-19年）"><a href="#36-继承方式-（美团-19年）" class="headerlink" title="36. 继承方式 （美团 19年）"></a>36. 继承方式 （美团 19年）</h3><blockquote><p>参考答案：</p><p>参阅前面第 <em>9</em> 题以及第 <em>18</em> 题答案。</p></blockquote><h3 id="37-原始值与引用值-（美团-19年）"><a href="#37-原始值与引用值-（美团-19年）" class="headerlink" title="37. 原始值与引用值 （美团 19年）"></a>37. 原始值与引用值 （美团 19年）</h3><blockquote><p>参考答案：</p><p>**原始值是表示 *JavaScript* 中可用的数据或信息的最底层形式或最简单形式。**简单类型的值被称为原始值，是因为它们是**不可细化**的。</p><p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p><p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p><p>最后总结一下两者的区别：</p><ol><li>访问方式<ul><li>原始值：访问到的是值</li><li>引用值：访问到的是引用地址</li></ul></li><li>比较方式<ul><li>原始值：比较的是值</li><li>引用值：比较的是地址</li></ul></li><li>动态属性<ul><li>原始值：无法添加动态属性</li><li>引用值：可以添加动态属性</li></ul></li><li>变量赋值<ul><li>原始值：赋值的是值</li><li>引用值：赋值的是地址</li></ul></li></ol></blockquote><h3 id="38-描述下列代码的执行结果"><a href="#38-描述下列代码的执行结果" class="headerlink" title="38. 描述下列代码的执行结果"></a>38. 描述下列代码的执行结果</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">3</span>);<br>    let <span class="hljs-selector-tag">p</span> = new <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; &#123;<br>        console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">7</span>);<br>        <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>            console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>            console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">resolve</span>(<span class="hljs-number">3</span>);<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">resolve</span>(<span class="hljs-number">4</span>);<br>    &#125;);<br>    <span class="hljs-built_in">resolve</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.then</span>((arg) =&gt; &#123;<br>        console<span class="hljs-selector-class">.log</span>(arg, <span class="hljs-number">5</span>); <span class="hljs-comment">// 1 bb</span><br>    &#125;);<br>    <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>        console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">6</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;))<br><span class="hljs-built_in">first</span>()<span class="hljs-selector-class">.then</span>((arg) =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(arg, <span class="hljs-number">7</span>); <span class="hljs-comment">// 2 aa</span><br>    <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>        console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">8</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">9</span>);<br>&#125;, <span class="hljs-number">0</span>);<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>3<br> 7<br> 10<br> 4 5<br> 2 7<br> 1<br> 2<br> 6<br> 9<br> 8</p></blockquote><h3 id="39-如何判断数组或对象（美团-19年）"><a href="#39-如何判断数组或对象（美团-19年）" class="headerlink" title="39. 如何判断数组或对象（美团 19年）"></a>39. 如何判断数组或对象（美团 19年）</h3><blockquote><p>参考答案：</p><ol><li>通过 <em>instanceof</em> 进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ol><li>通过对象的 <em>constructor</em> 属性</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<span class="hljs-comment">;</span><br>console.log(<span class="hljs-attr">arr.constructor</span> === Array) // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol><li><em>Object.prototype.toString.call(arr)</em></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;jerry&quot;</span>&#125;));<span class="hljs-comment">//[object Object]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]));<span class="hljs-comment">//[object Array]</span><br></code></pre></td></tr></table></figure><ol><li>可以通过 <em>ES6</em> 新提供的方法 <em>Array.isArray( )</em></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br>复制代码<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([]) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）"><a href="#40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）" class="headerlink" title="40. 对象深拷贝与浅拷贝，单独问了 Object.assign（美团 19年）"></a>40. 对象深拷贝与浅拷贝，单独问了 <em>Object.assign</em>（美团 19年）</h3><blockquote><p>参考答案：</p><ul><li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p></li><li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p></li></ul><p><em>Object.assign</em> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <em>Object.assign</em> 方法进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p></blockquote><h3 id="42-说说-instanceof-原理，并回答下面的题目（美团-19年）"><a href="#42-说说-instanceof-原理，并回答下面的题目（美团-19年）" class="headerlink" title="42. 说说 instanceof 原理，并回答下面的题目（美团 19年）"></a>42. 说说 <em>instanceof</em> 原理，并回答下面的题目（美团 19年）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>)&#123;&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>(); <br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> B) <span class="hljs-comment">// true of false ?</span><br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>答案为 <em>true</em>。</p><p><em>instanceof</em> 原理：</p><p><em>instanceof</em> 用于检测一个对象是否为某个构造函数的实例。</p><p>例如：<em>A instanceof B</em><br> <em>instanceof</em> 用于检测对象 <em>A</em> 是不是 <em>B</em> 的实例，而检测是基于原型链进行查找的，也就是说 <em>B</em> 的 <em>prototype</em> 有没有在对象 <em>A</em> 的__<em>proto</em>__ 原型链上，如果有就返回 <em>true</em>，否则返回 <em>false</em></p></blockquote><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="43-内存泄漏（美团-19-年）"><a href="#43-内存泄漏（美团-19-年）" class="headerlink" title="43. 内存泄漏（美团 19 年）"></a>43. 内存泄漏（美团 19 年）</h3><blockquote><p>参考答案：</p><p>内存泄漏（<em>Memory Leak</em>）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p><em>Javascript</em> 是一种高级语言，它不像 <em>C</em> 语言那样要手动申请内存，然后手动释放，<em>Javascript</em> 在声明变量的时候自动会分配内存，普通的类型比如 <em>number</em>，一般放在栈内存里，对象放在堆内存里，声明一个变量，就分配一些内存，然后定时进行垃圾回收。垃圾回收的任务由 <em>JavaScript</em> 引擎中的垃圾回收器来完成，它监视所有对象，并删除那些不可访问的对象。</p><p>基本的垃圾回收算法称为<strong>“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p><ul><li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li><li>然后它访问并“标记”所有来自它们的引用。</li><li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li><li>以此类推，直到有未访问的引用(可以从根访问)为止。</li><li>除标记的对象外，所有对象都被删除。</li></ul></blockquote><h3 id="44-ES6-新增哪些东西？让你自己说（美团-19-年）"><a href="#44-ES6-新增哪些东西？让你自己说（美团-19-年）" class="headerlink" title="44. ES6 新增哪些东西？让你自己说（美团 19 年）"></a>44. <em>ES6</em> 新增哪些东西？让你自己说（美团 19 年）</h3><blockquote><p>参考答案：</p><p><em>ES6</em> 新增内容众多，这里列举出一些关键的以及平时常用的新增内容：</p><ol><li>箭头函数</li><li>字符串模板</li><li>支持模块化（<em>import、export</em>）</li><li>类（<em>class、constructor、extends</em>）</li><li><em>let、const</em> 关键字</li><li>新增一些数组、字符串等内置构造函数方法，例如 <em>Array.from</em>、<em>Array.of</em> 、<em>Math.sign</em>、<em>Math.trunc</em> 等</li><li>新增一些语法，例如扩展操作符、解构、函数默认参数等</li><li>新增一种基本数据类型 <em>Symbol</em></li><li>新增元编程相关，例如 <em>proxy</em>、<em>Reflect</em></li><li><em>Set</em> 和 <em>Map</em> 数据结构</li><li><em>Promise</em></li><li><em>Generator</em> 生成器</li></ol></blockquote><h3 id="45-weakmap、weakset（美团-19-年）"><a href="#45-weakmap、weakset（美团-19-年）" class="headerlink" title="45. weakmap、weakset（美团 19 年）"></a>45. <em>weakmap、weakset</em>（美团 <em>19</em> 年）</h3><blockquote><p>参考答案：</p><p><em>WeakSet</em> 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在 <em>WeakSet</em> 的集合中是唯一的</p><p>它和 <em>Set</em> 对象的区别有两点:</p><ul><li>与 <em>Set</em> 相比，<em>WeakSet</em> 只能是<strong>对象的集合</strong>，而不能是任何类型的任意值。</li><li><em>WeakSet</em> 持弱引用：集合中对象的引用为弱引用。 如果没有其他的对 <em>WeakSet</em> 中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <em>WeakSet</em> 中没有存储当前对象的列表。 正因为这样，<em>WeakSet</em> 是不可枚举的。</li></ul><p><em>WeakMap</em> 对象也是键值对的集合。它的<strong>键必须是对象类型</strong>，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 <em>GC</em> 回收掉。<em>WeakMap</em> 提供的接口与 <em>Map</em> 相同。</p><p>与 <em>Map</em> 对象不同的是，<em>WeakMap</em> 的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。</p></blockquote><h3 id="46-为什么-ES6-会新增-Promise（美团-19年）"><a href="#46-为什么-ES6-会新增-Promise（美团-19年）" class="headerlink" title="46. 为什么 ES6 会新增 Promise（美团 19年）"></a>46. 为什么 <em>ES6</em> 会新增 <em>Promise</em>（美团 19年）</h3><blockquote><p>参考答案：</p><p>在 <em>ES6</em> 以前，解决异步的方法是回调函数。但是回调函数有一个最大的问题就是回调地狱（<em>callback hell</em>），当我们的回调函数嵌套的层数过多时，就会导致代码横向发展。</p><p><em>Promise</em> 的出现就是为了解决回调地狱的问题。</p></blockquote><h3 id="47-ES5-实现继承？（虾皮）"><a href="#47-ES5-实现继承？（虾皮）" class="headerlink" title="47. ES5 实现继承？（虾皮）"></a>47. <em>ES5</em> 实现继承？（虾皮）</h3><blockquote><p>参考答案：</p><ol><li>借用构造函数实现继承</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-function">function <span class="hljs-title">Parent1</span>()</span>&#123;<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;parent1&quot;</span><br>&#125;<br><span class="hljs-function">function <span class="hljs-title">Child1</span>()</span>&#123;<br>    Parent1.call(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">&quot;child1&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：<em>Child1</em> 无法继承 <em>Parent1</em> 的原型对象，并没有真正的实现继承 (部分继承)。</p><ol><li>借用原型链实现继承</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function Parent2()&#123;<br>    <span class="hljs-attr">this.name</span> = <span class="hljs-string">&quot;parent2&quot;</span><span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.play</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br>&#125;<br>function Child2()&#123;<br>    <span class="hljs-attr">this.type</span> = <span class="hljs-string">&quot;child2&quot;</span><span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-attr">Child2.prototype</span> = new Parent2()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>缺点：原型对象的属性是共享的。</p><ol><li>组合式继承</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function Parent3()&#123;<br>    <span class="hljs-attr">this.name</span> = <span class="hljs-string">&quot;parent3&quot;</span><span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.play</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br>&#125;<br>function Child3()&#123;<br>    Parent3.call(this)<span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.type</span> = <span class="hljs-string">&quot;child3&quot;</span><span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-attr">Child3.prototype</span> = Object.create(Parent3.prototype)<span class="hljs-comment">;</span><br><span class="hljs-attr">Child3.prototype.constructor</span> = Child3<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="48-科里化？（搜狗）"><a href="#48-科里化？（搜狗）" class="headerlink" title="48. 科里化？（搜狗）"></a>48. 科里化？（搜狗）</h3><blockquote><p>参考答案：</p><p>柯里化，英语全称 <em>Currying</em>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>举个例子，就是把原本：</p><p><em>function(arg1,arg2)</em>  变成 <em>function(arg1)(arg2)</em><br> <em>function(arg1,arg2,arg3)</em>  变成 <em>function(arg1)(arg2)(arg3)</em><br> <em>function(arg1,arg2,arg3,arg4)</em>  变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p><p>总而言之，就是将：</p><p><em>function(arg1,arg2,…,argn)</em>  变成 <em>function(arg1)(arg2)…(argn)</em></p></blockquote><h3 id="49-防抖和节流？（虾皮）"><a href="#49-防抖和节流？（虾皮）" class="headerlink" title="49. 防抖和节流？（虾皮）"></a>49. 防抖和节流？（虾皮）</h3><blockquote><p>参考答案：</p><p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p><p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p><p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p></blockquote><h3 id="50-闭包？（好未来—探讨了-40-分钟）"><a href="#50-闭包？（好未来—探讨了-40-分钟）" class="headerlink" title="50. 闭包？（好未来—探讨了 40 分钟）"></a>50. 闭包？（好未来—探讨了 <em>40</em> 分钟）</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p></blockquote><h3 id="51-原型和原型链？（字节）"><a href="#51-原型和原型链？（字节）" class="headerlink" title="51. 原型和原型链？（字节）"></a>51. 原型和原型链？（字节）</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>34</em> 题答案。</p></blockquote><h3 id="52-排序算法—（时间复杂度、空间复杂度）"><a href="#52-排序算法—（时间复杂度、空间复杂度）" class="headerlink" title="52. 排序算法—（时间复杂度、空间复杂度）"></a>52. 排序算法—（时间复杂度、空间复杂度）</h3><blockquote><p>参考答案：</p><p>算法（<em>Algorithm</em>）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p><p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><p>排序也称排序算法(<em>Sort Algorithm</em>)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p><p>排序的分类分为<strong>内部排序</strong>和<strong>外部排序法</strong>。</p><ul><li>内部排序：指将需要处理的所有数据都加载到**内部存储器(内存)**中进行排序。</li><li>外部排序：<strong>数据量过大</strong>，无法全部加载到内存中，需要借助**外部存储(文件等)**进行排序。</li></ul><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/52d4f819b8824955a7c5b42306ea8741tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210813134746501"></blockquote><h3 id="53-浏览器事件循环和-node-事件循环（搜狗）"><a href="#53-浏览器事件循环和-node-事件循环（搜狗）" class="headerlink" title="53. 浏览器事件循环和 node 事件循环（搜狗）"></a>53. 浏览器事件循环和 <em>node</em> 事件循环（搜狗）</h3><blockquote><p>参考答案：</p><ol><li>浏览器中的 <em>Event Loop</em></li></ol><p>事件循环中的异步队列有两种：<em>macro</em>（宏任务）队列和 <em>micro</em>（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p><ul><li>常见的 <em>macro-task</em> 比如：<em>setTimeout、setInterval、 setImmediate、script</em>（整体代码）、 <em>I&#x2F;O</em> 操作、<em>UI</em> 渲染等。</li><li>常见的 <em>micro-task</em> 比如: <em>process.nextTick、new Promise( ).then</em>(回调)、<em>MutationObserver</em>(<em>html5</em> 新特性) 等。</li></ul><p>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p><ol><li><em>Node</em> 中的事件循环</li></ol><p><em>Node</em> 中的 <em>Event Loop</em> 和浏览器中的是完全不相同的东西。<em>Node.js</em> 采用 <em>V8</em> 作为 <em>js</em> 的解析引擎，而 <em>I&#x2F;O</em> 处理方面使用了自己设计的 <em>libuv</em>，<em>libuv</em> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 <em>API</em>，事件循环机制也是它里面的实现。</p><p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p><ul><li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li><li><em>I&#x2F;O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I&#x2F;O</em> 回调</li><li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li><li><em>poll</em> 阶段：获取新的 <em>I&#x2F;O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li><li><em>check</em> 阶段：执行 <em>setImmediate( )</em>  的回调</li><li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li></ul><p><em>Node.js</em> 的运行机制如下:</p><ul><li><em>V8</em> 引擎解析 <em>JavaScript</em> 脚本。</li><li>解析后的代码，调用 <em>Node API</em>。</li><li><em>libuv</em> 库负责 <em>Node API</em> 的执行。它将不同的任务分配给不同的线程，形成一个 <em>Event Loop</em>（事件循环），以异步的方式将任务的执行结果返回给 <em>V8</em> 引擎。</li><li><em>V8</em> 引擎再将结果返回给用户。</li></ul></blockquote><h3 id="54-闭包的好处"><a href="#54-闭包的好处" class="headerlink" title="54. 闭包的好处"></a>54. 闭包的好处</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p></blockquote><h3 id="55-let、const、var-的区别"><a href="#55-let、const、var-的区别" class="headerlink" title="55. let、const、var 的区别"></a>55. <em>let、const、var</em> 的区别</h3><blockquote><p>参考答案：</p><ol><li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li><li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li><li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li></ol></blockquote><h3 id="56-闭包、作用域（可以扩充到作用域链）"><a href="#56-闭包、作用域（可以扩充到作用域链）" class="headerlink" title="56. 闭包、作用域（可以扩充到作用域链）"></a>56. 闭包、作用域（可以扩充到作用域链）</h3><blockquote><p>参考答案：</p><p><strong>什么是作业域?</strong></p><p>ES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量(变量名或者函数名)查找。</p><p><strong>什么是作用域链?</strong></p><p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><p><strong>闭包产生的本质</strong></p><p>当前环境中存在指向父级作用域的引用</p><p><strong>什么是闭包</strong></p><p>闭包是一种特殊的对象，它由两部分组成：执行上下文(代号 A)，以及在该执行上下文中创建的函数 (代号 B)，当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包。</p><p><strong>一般如何产生闭包</strong></p><ul><li>返回函数</li><li>函数当做参数传递</li></ul><p><strong>闭包的应用场景</strong></p><ul><li>柯里化 bind</li><li>模块</li></ul></blockquote><h3 id="57-Promise"><a href="#57-Promise" class="headerlink" title="57. Promise"></a>57. <em>Promise</em></h3><blockquote><p>参考答案：</p><p><em>Promise</em> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，<em>ES6</em>将其写进了语言标准，统一了用法，并原生提供了<em>Promise</em>对象。</p><p><strong>特点</strong></p><ol><li>对象的状态不受外界影响 （<em>3</em> 种状态）<ul><li><em>Pending</em> 状态（进行中）</li><li><em>Fulfilled</em> 状态（已成功）</li><li><em>Rejected</em> 状态（已失败）</li></ul></li><li>一旦状态改变就不会再变 （两种状态改变：成功或失败）<ul><li><em>Pending</em> -&gt; <em>Fulfilled</em></li><li><em>Pending</em> -&gt; <em>Rejected</em></li></ul></li></ol><p><strong>用法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br>    <span class="hljs-comment">// ... some code</span><br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调"><a href="#58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调" class="headerlink" title="58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调"></a>58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">/**</span><br><span class="hljs-comment">    <span class="hljs-doctag">@params</span> url: 请求接口地址;</span><br><span class="hljs-comment">    <span class="hljs-doctag">@params</span> body: 设置的请求体;</span><br><span class="hljs-comment">    <span class="hljs-doctag">@params</span> succ: 请求成功后的回调</span><br><span class="hljs-comment">    <span class="hljs-doctag">@params</span> error: 请求失败后的回调</span><br><span class="hljs-comment">    <span class="hljs-doctag">@params</span> maxCount: 设置请求的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url, body, succ, error, maxCount = <span class="hljs-number">5</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, body)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-title function_">succ</span>(res))<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (maxCount &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求超时&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(url, body, succ, error, --maxCount);<br>        &#125;);<br>&#125;<br><br><span class="hljs-comment">// 调用请求函数</span><br><span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;https://java.some.com/pc/reqCount&#x27;</span>, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-attr">headers</span>: &#123;&#125; &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="59-冒泡排序"><a href="#59-冒泡排序" class="headerlink" title="59. 冒泡排序"></a>59. 冒泡排序</h3><blockquote><p>参考答案：</p><p>冒泡排序的核心思想是：</p><ol><li>比较相邻的两个元素，如果前一个比后一个大或者小（取决于排序的顺序是小到大还是大到小），则交换位置。</li><li>比较完第一轮的时候，最后一个元素是最大或最小的元素。</li><li>这时候最后一个元素已经是最大或最小的了，所以下一次冒泡的时候最后一个元素不需要参与比较。</li></ol><p>示例代码：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function bSort(arr) &#123;<br>    var <span class="hljs-attr">len</span> = arr.length<span class="hljs-comment">;</span><br>    // 外层 for 循环控制冒泡的次数<br>    for (var <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; len - 1; i++) &#123;</span><br>        for (var <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; len - 1 - i; j++) &#123;</span><br>            // 内层 for 循环控制每一次冒泡需要比较的次数<br>            // 因为之后每一次冒泡的两两比较次数会越来越少，所以 -i<br>            if (arr<span class="hljs-section">[j]</span> &gt; arr<span class="hljs-section">[j + 1]</span>) &#123;<br>                var <span class="hljs-attr">temp</span> = arr[j]<span class="hljs-comment">;</span><br>                arr<span class="hljs-section">[j]</span> = arr<span class="hljs-section">[j + 1]</span><span class="hljs-comment">;</span><br>                arr<span class="hljs-section">[j + 1]</span> = temp<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    return arr<span class="hljs-comment">;</span><br>&#125;<br><br>//举个数组<br><span class="hljs-attr">myArr</span> = [<span class="hljs-number">20</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">27</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">35</span>]<span class="hljs-comment">;</span><br>//使用函数<br>console.log(bSort(myArr))<span class="hljs-comment">; // [ -7, -1, 20, 27, 35 ]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="60-数组降维"><a href="#60-数组降维" class="headerlink" title="60. 数组降维"></a>60. 数组降维</h3><blockquote><p>参考答案：</p><p>数组降维就是将一个嵌套多层的数组进行降维操作，也就是对数组进行扁平化。在 <em>ES5</em> 时代我们需要自己手写方法或者借助函数库来完成，但是现在可以使用 <em>ES6</em> 新提供的数组方法 <em>flat</em> 来完成数组降维操作。</p></blockquote><blockquote><p>解析：使用 <em>flat</em> 方法会接收一个参数，这个参数是数值类型，是要处理扁平化数组的深度，生成后的新数组是独立存在的，不会对原数组产生影响。</p><p><em>flat</em> 方法的语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-tag">var</span> newArray = arr<span class="hljs-selector-class">.flat</span>(<span class="hljs-selector-attr">[depth]</span>)<br></code></pre></td></tr></table></figure><p>其中 <em>depth</em> 指定要提取嵌套数组结构的深度，默认值为 <em>1</em>。</p><p>示例如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">less</span>复制代码<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">arr</span> = <span class="hljs-selector-attr">[1, 2, [3, 4, [5, 6]</span>]];<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(arr.<span class="hljs-built_in">flat</span>());      <span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(arr.<span class="hljs-built_in">flat</span>(<span class="hljs-number">2</span>));     <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p>上面的代码定义了一个层嵌套的数组，默认情况下只会拍平一层数组，也就是把原来的三维数组降低到了二维数组。在传入的参数为 <em>2</em> 时，则会降低两维，成为一个一维数组。</p><p>使用 <em>Infinity</em>，可展开任意深度的嵌套数组，示例如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]]]<span class="hljs-comment">;</span><br>console.log(arr.flat(Infinity))<span class="hljs-comment">;  // [1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure><p>在数组中有空项的时候，使用 <em>flat</em> 方法会将中的空项进行移除。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, , <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br>console.log(arr.flat())<span class="hljs-comment">; // [1, 2, 4, 5]</span><br></code></pre></td></tr></table></figure><p>上面的代码中，数组中第三项是空值，在使用 <em>flat</em> 后会对空项进行移除。</p></blockquote><h3 id="61-call-apply-bind"><a href="#61-call-apply-bind" class="headerlink" title="61. call apply bind"></a>61. <em>call apply bind</em></h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>11</em> 题答案。</p></blockquote><h3 id="62-promise-代码题"><a href="#62-promise-代码题" class="headerlink" title="62. promise 代码题"></a>62. promise 代码题</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript复制代码<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject1&#x27;</span>) &#125;)<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;error&#x27;</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject2&#x27;</span>) &#125;)<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>2<br> 4<br> reject1<br> reject2</p><p>直播课或者录播课进行解析。</p></blockquote><h3 id="63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别"><a href="#63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别" class="headerlink" title="63. proxy 是实现代理，可以改变 js 底层的实现方式, 然后说了一下和 Object.defineProperty 的区别"></a>63. <em>proxy</em> 是实现代理，可以改变 <em>js</em> 底层的实现方式, 然后说了一下和 <em>Object.defineProperty</em> 的区别</h3><blockquote><p>参考答案：</p><p>两者的区别总结如下：</p><ul><li>代理原理：Object.defineProperty的原理是通过将数据属性转变为存取器属性的方式实现的属性读写代理。而Proxy则是因为这个内置的Proxy对象内部有一套监听机制，在传入handler对象作为参数构造代理对象后，一旦代理对象的某个操作触发，就会进入handler中对应注册的处理函数，此时我们就可以有选择的使用Reflect将操作转发被代理对象上。</li><li>代理局限性：Object.defineProperty始终还是局限于属性层面的读写代理，对于对象层面以及属性的其它操作代理它都无法实现。鉴于此，由于数组对象push、pop等方法的存在，它对于数组元素的读写代理实现的并不完全。而使用Proxy则可以很方便的监视数组操作。</li><li>自我代理：Object.defineProperty方式可以代理到自身（代理之后使用对象本身即可），也可以代理到别的对象身上（代理之后需要使用代理对象）。Proxy方式只能代理到Proxy实例对象上。这一点在其它说法中是Proxy对象不需要侵入对象就可以实现代理，实际上Object.defineProperty方式也可以不侵入。</li></ul></blockquote><h3 id="64-使用-ES5-与-ES6-分别实现继承"><a href="#64-使用-ES5-与-ES6-分别实现继承" class="headerlink" title="64. 使用 ES5 与 ES6 分别实现继承"></a>64. 使用 <em>ES5</em> 与 <em>ES6</em> 分别实现继承</h3><blockquote><p>参考答案：</p><p>如果是使用 <em>ES5</em> 来实现继承，那么现在的最优解是使用圣杯模式。圣杯模式的核心思想就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。具体代码可以参阅前面第 <em>9</em> 题的解析。</p><p><em>ES6</em> 新增了 <em>extends</em> 关键字，直接使用该关键字就能够实现继承。</p></blockquote><h3 id="65-深拷贝"><a href="#65-深拷贝" class="headerlink" title="65. 深拷贝"></a>65. 深拷贝</h3><blockquote><p>参考答案：</p><p>有深拷贝就有浅拷贝。</p><p>浅拷贝就是只拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，任何一个修改都会使得所有对象的值修改，因为它们共用一条数据。</p><p>深拷贝不是单纯的拷贝一份引用数据类型的引用地址，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突。</p></blockquote><blockquote><p>解析：</p><p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p><p>分析下怎么做「深拷贝」：</p><ol><li>首先假设深拷贝这个方法已经完成，为 deepClone</li><li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function deepClone(o1, o2) &#123;<br>    for (let k in o2) &#123;<br>        if (typeof o2<span class="hljs-section">[k]</span> === &#x27;object&#x27;) &#123;<br>            o1<span class="hljs-section">[k]</span> = &#123;&#125;<span class="hljs-comment">;</span><br>            deepClone(o1<span class="hljs-section">[k]</span>, o2<span class="hljs-section">[k]</span>)<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            o1<span class="hljs-section">[k]</span> = o2<span class="hljs-section">[k]</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br>// 测试用例<br>let <span class="hljs-attr">obj</span> = &#123;<br>    a: 1,<br>    b: <span class="hljs-section">[1, 2, 3]</span>,<br>    c: &#123;&#125;<br>&#125;<span class="hljs-comment">;</span><br>let <span class="hljs-attr">emptyObj</span> = Object.create(null)<span class="hljs-comment">;</span><br>deepClone(emptyObj, obj)<span class="hljs-comment">;</span><br>console.log(<span class="hljs-attr">emptyObj.a</span> == obj.a)<span class="hljs-comment">;</span><br>console.log(<span class="hljs-attr">emptyObj.b</span> == obj.b)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，<em>Chrome</em> 的 <em>V8</em> 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过 <em>for</em> 或者 <em>while</em> 来代替递归。</p></blockquote><h3 id="66-async-与-await-的作用"><a href="#66-async-与-await-的作用" class="headerlink" title="66. async 与 await 的作用"></a>66. <em>async</em> 与 <em>await</em> 的作用</h3><blockquote><p>参考答案：</p><p><em>async</em> 是一个修饰符，<em>async</em> 定义的函数会默认的返回一个 <em>Promise</em> 对象 <em>resolve</em> 的值，因此对 <em>async</em> 函数可以直接进行 <em>then</em> 操作，返回的值即为 <em>then</em> 方法的传入函数。</p><p><em>await</em> 关键字只能放在 <em>async</em> 函数内部， <em>await</em> 关键字的作用就是获取 <em>Promise</em> 中返回的内容， 获取的是 <em>Promise</em> 函数中 <em>resolve</em> 或者 <em>reject</em> 的值。</p></blockquote><h3 id="67-数据的基础类型（原始类型）有哪些"><a href="#67-数据的基础类型（原始类型）有哪些" class="headerlink" title="67. 数据的基础类型（原始类型）有哪些"></a>67. 数据的基础类型（原始类型）有哪些</h3><blockquote><p>参考答案：</p><p><em>JavaScript</em> 中的基础数据类型，一共有 <em>6</em> 种：</p><p><em>string，symbol，number，boolean，undefined，null</em></p><p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p></blockquote><h3 id="68-typeof-null-返回结果"><a href="#68-typeof-null-返回结果" class="headerlink" title="68. typeof null 返回结果"></a>68. <em>typeof null</em> 返回结果</h3><blockquote><p>参考答案：</p><p>返回 <em>object</em></p></blockquote><blockquote><p>解析：至于为什么会返回 <em>object</em>，这实际上是来源于 <em>JavaScript</em> 从第一个版本开始时的一个 <em>bug</em>，并且这个 <em>bug</em> 无法被修复。修复会破坏现有的代码。</p><p>原理这是这样的，不同的对象在底层都表现为二进制，在 <em>JavaScript</em> 中二进制前三位都为 <em>0</em> 的话会被判断为 <em>object</em> 类型，<em>null</em> 的二进制全部为 <em>0</em>，自然前三位也是 <em>0</em>，所以执行 <em>typeof</em> 值会返回 <em>object</em>。</p></blockquote><h3 id="69-对变量进行类型判断的方式有哪些"><a href="#69-对变量进行类型判断的方式有哪些" class="headerlink" title="69. 对变量进行类型判断的方式有哪些"></a>69. 对变量进行类型判断的方式有哪些</h3><blockquote><p>参考答案：</p><p>常用的方法有 <em>4</em> 种：</p><ol><li><em>typeof</em></li></ol><p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p><ol><li><em>instanceof</em></li></ol><p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p><ol><li><em>constructor</em></li></ol><p>当一个函数 <em>F</em> 被定义时，<em>JS</em> 引擎会为 <em>F</em> 添加 <em>prototype</em> 原型，然后再在 <em>prototype</em> 上添加一个 <em>constructor</em> 属性，并让其指向 <em>F</em> 的引用。</p><ol><li><em>toString</em></li></ol><p><em>toString( )</em>  是 <em>Object</em> 的原型方法，调用该方法，默认返回当前对象的 <em><a href="https://link.juejin.cn/?target=">Class</a></em> 。这是一个内部属性，其格式为 <em>[object Xxx]</em>  ，其中 <em>Xxx</em> 就是对象的类型。</p><p>对于 <em>Object</em> 对象，直接调用 <em>toString( )</em>  就能返回 <em>[object Object]</em>  。而对于其他对象，则需要通过 <em>call &#x2F; apply</em> 来调用才能返回正确的类型信息。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) ;  <span class="hljs-comment">// [object String]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>) ;   <span class="hljs-comment">// [object Number]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>) ;<span class="hljs-comment">// [object Boolean]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Symbol</span>());<span class="hljs-comment">//[object Symbol]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) ;<span class="hljs-comment">// [object Undefined]</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) ;<span class="hljs-comment">// [object Null]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="70-typeof-与-instanceof-的区别？-instanceof-是如何实现？"><a href="#70-typeof-与-instanceof-的区别？-instanceof-是如何实现？" class="headerlink" title="70. typeof 与 instanceof 的区别？ instanceof 是如何实现？"></a>70. <em>typeof</em> 与 <em>instanceof</em> 的区别？ <em>instanceof</em> 是如何实现？</h3><blockquote><p>参考答案：</p><ol><li><em>typeof</em></li></ol><p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p><ol><li><em>instanceof</em></li></ol><p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p><p>用一段伪代码来模拟其内部执行过程：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码instanceof (A,B) = &#123;<br>    <span class="hljs-attr">varL</span> = A.__proto__<span class="hljs-comment">;</span><br>    <span class="hljs-attr">varR</span> = B.prototype<span class="hljs-comment">;</span><br>    if(<span class="hljs-attr">L</span> === R) &#123;<br>        // A的内部属性 __proto__ 指向 B 的原型对象<br>        return true<span class="hljs-comment">;</span><br>    &#125;<br>    return false<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上述过程可以看出，当 <em>A</em> 的 *<strong>proto*</strong> 指向 <em>B</em> 的 <em>prototype</em> 时，就认为 <em>A</em> 就是 <em>B</em> 的实例。</p><p>需要注意的是，<em>instanceof</em> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p><p>例如： <em>[ ] instanceof Object</em> 返回的也会是 <em>true</em>。</p></blockquote><h3 id="71-引用类型有哪些，有什么特点"><a href="#71-引用类型有哪些，有什么特点" class="headerlink" title="71. 引用类型有哪些，有什么特点"></a>71. 引用类型有哪些，有什么特点</h3><blockquote><p>参考答案：</p><p>JS 中七种内置类型（<em>null，undefined，boolean，number，string，symbol，object</em>）又分为两大类型</p><p>两大类型：</p><ul><li>基本类型： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code></li><li>引用类型Object： <code>Array</code> ，<code>Function</code>， <code>Date</code>， <code>RegExp</code>等</li></ul><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/3f177970e2924361902991e8910673cftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210813153833385"><p>基本类型和引用类型的主要区别有以下几点：</p><p><strong>存放位置：</strong></p><ul><li>基本数据类型：基本类型值在内存中占据固定大小，直接存储在<strong>栈内存</strong>中的数据</li><li>引用数据类型：引用类型在栈中存储了指针，这个指针指向堆内存中的地址，真实的数据存放在<strong>堆内存</strong>里。</li></ul><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/9cbe609ed3174512b51e643e5d894226tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="image-20210813154040287"><p><strong>值的可变性：</strong></p><ul><li>基本数据类型： 值不可变，<em>javascript</em> 中的原始值（<em>undefined、null</em>、布尔值、数字和字符串）是不可更改的</li><li>引用数据类型：引用类型是可以直接改变其值的</li></ul><p><strong>比较：</strong></p><ul><li>基本数据类型： 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的</li><li>引用数据类型： 引用数据类型的比较是引用的比较，看其的引用是否指向同一个对象</li></ul></blockquote><h3 id="72-如何得到一个变量的类型—指函数封装实现"><a href="#72-如何得到一个变量的类型—指函数封装实现" class="headerlink" title="72. 如何得到一个变量的类型—指函数封装实现"></a>72. 如何得到一个变量的类型—指函数封装实现</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>30</em> 题答案。</p></blockquote><h3 id="73-什么是作用域、闭包"><a href="#73-什么是作用域、闭包" class="headerlink" title="73. 什么是作用域、闭包"></a>73. 什么是作用域、闭包</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>56</em> 题。</p></blockquote><h3 id="74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？"><a href="#74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？" class="headerlink" title="74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？"></a>74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？</h3><blockquote><p>参考答案：</p><p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p><p>因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以<strong>闭包使用过多，会占用较多的内存，这也是一个副作用，内存泄漏。</strong></p><p>如果要销毁一个闭包，可以 把被引用的变量设置为<em>null</em>，即手动清除变量，这样下次 <em>js</em> 垃圾回收机制回收时，就会把设为 <em>null</em> 的量给回收了。</p><p>闭包的应用场景：</p><ol><li>匿名自执行函数</li><li>结果缓存</li><li>封装</li><li>实现类和继承</li></ol></blockquote><h3 id="75-JS的垃圾回收站机制"><a href="#75-JS的垃圾回收站机制" class="headerlink" title="75. JS的垃圾回收站机制"></a>75. <em>JS</em>的垃圾回收站机制</h3><blockquote><p>参考答案：</p><p><em>JS</em> 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p><p><em>JS</em> 常见的垃圾回收方式：标记清除、引用计数方式。</p><p>1、标记清除方式：</p><ul><li>工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</li><li>工作流程：</li><li>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；</li><li>去掉环境中的变量以及被环境中的变量引用的变量的标记；</li><li>被加上标记的会被视为准备删除的变量；</li><li>垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。</li></ul><p>2、引用计数方式：</p><ul><li>工作原理：跟踪记录每个值被引用的次数。</li><li>工作流程：</li><li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 <em>1</em>；</li><li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；</li><li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 <em>1</em>；</li><li>当引用次数变成 <em>0</em> 时，说明没办法访问这个值了；</li><li>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</li></ul></blockquote><h3 id="76-什么是作用域链、原型链"><a href="#76-什么是作用域链、原型链" class="headerlink" title="76. 什么是作用域链、原型链"></a>76. 什么是作用域链、原型链</h3><blockquote><p>参考答案：</p><p><strong>什么是作用域链?</strong></p><p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p><p><strong>什么原型链?</strong></p><p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p></blockquote><h3 id="77-new-一个构造函数发生了什么"><a href="#77-new-一个构造函数发生了什么" class="headerlink" title="77. new 一个构造函数发生了什么"></a>77. <em>new</em> 一个构造函数发生了什么</h3><blockquote><p>参考答案：</p><p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p><em>new</em> 关键字会进行如下的操作：<br> 步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br> 步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br> 步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br> 步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p></blockquote><h3 id="78-对一个构造函数实例化后-它的原型链指向什么"><a href="#78-对一个构造函数实例化后-它的原型链指向什么" class="headerlink" title="78. 对一个构造函数实例化后. 它的原型链指向什么"></a>78. 对一个构造函数实例化后. 它的原型链指向什么</h3><blockquote><p>参考答案：</p><p>指向该构造函数实例化出来对象的原型对象。</p><p>对于构造函数来讲，可以通过 <em>prototype</em> 访问到该对象。</p><p>对于实例对象来讲，可以通过隐式属性 *<strong>proto*</strong> 来访问到。</p></blockquote><h3 id="79-什么是变量提升"><a href="#79-什么是变量提升" class="headerlink" title="79. 什么是变量提升"></a>79. 什么是变量提升</h3><blockquote><p>参考答案：</p><p>当 <em>JavaScript</em> 编译所有代码时，所有使用 <em>var</em> 的变量声明都被提升到它们的函数&#x2F;局部作用域的顶部(如果在函数内部声明的话)，或者提升到它们的全局作用域的顶部(如果在函数外部声明的话)，而不管实际的声明是在哪里进行的。这就是我们所说的“提升”。</p><p>请记住，这种“提升”实际上并不发生在你的代码中，而只是一种比喻，与 <em>JavaScript</em> 编译器如何读取你的代码有关。记住当我们想到“提升”的时候，我们可以想象任何被提升的东西都会被移动到顶部，但是实际上你的代码并不会被修改。</p><p>函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。</p><p>在编译阶段变量和函数声明会被放入内存中，但是你在代码中编写它们的位置会保持不变。</p></blockquote><h3 id="80-x3D-x3D-和-x3D-x3D-x3D-的区别是什么"><a href="#80-x3D-x3D-和-x3D-x3D-x3D-的区别是什么" class="headerlink" title="80. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别是什么"></a>80. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别是什么</h3><blockquote><p>参考答案：</p><p>简单来说： &#x3D;&#x3D; 代表相同， &#x3D;&#x3D;&#x3D; 代表严格相同（数据类型和值都相等）。</p><p>当进行双等号比较时候，先检查两个操作数数据类型，如果相同，则进行&#x3D;&#x3D;&#x3D;比较，如果不同，则愿意为你进行一次类型转换，转换成相同类型后再进行比较，而 &#x3D;&#x3D;&#x3D; 比较时，如果类型不同，直接就是false。</p><p>从这个过程来看，大家也能发现，某些情况下我们使用 &#x3D;&#x3D;&#x3D; 进行比较效率要高些，因此，没有歧义的情况下，不会影响结果的情况下，在 <em>JS</em> 中首选 &#x3D;&#x3D;&#x3D; 进行逻辑比较。</p></blockquote><h3 id="81-Object-is-方法比较的是什么"><a href="#81-Object-is-方法比较的是什么" class="headerlink" title="81. Object.is 方法比较的是什么"></a>81. <em><a href="https://link.juejin.cn/?target=http://Object.is">Object.is</a></em> 方法比较的是什么</h3><blockquote><p>参考答案：</p><p><em><a href="https://link.juejin.cn/?target=http://Object.is">Object.is</a></em> 方法是 <em>ES6</em> 新增的用来比较两个值是否严格相等的方法，与 &#x3D;&#x3D;&#x3D; (严格相等)的行为基本一致。不过有两处不同：</p><ul><li>+0 不等于 -0。</li><li><em>NaN</em> 等于自身。</li></ul><p>所以可以将*<a href="https://link.juejin.cn/?target=http://Object.is">Object.is</a>* 方法看作是加强版的严格相等。</p></blockquote><h3 id="82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？"><a href="#82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？" class="headerlink" title="82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？"></a>82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？</h3><blockquote><p>参考答案：</p><p>在 <em>ECMAScript</em> 规范中，共定义了 <em>7</em> 种数据类型，分为 <strong>基本类型</strong> 和 <strong>引用类型</strong> 两大类，如下所示：</p><ul><li><strong>基本类型</strong>：<em>String、Number、Boolean、Symbol、Undefined、Null</em></li><li><strong>引用类型</strong>：<em>Object</em></li></ul><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(<em>heap</em>)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 <em>Object</em> 外，还包括 <em>Function 、Array、RegExp、Date</em> 等等。</p></blockquote><h3 id="83-箭头函数解决了什么问题？"><a href="#83-箭头函数解决了什么问题？" class="headerlink" title="83. 箭头函数解决了什么问题？"></a>83. 箭头函数解决了什么问题？</h3><blockquote><p>参考答案：</p><p>箭头函数主要解决了 <em>this</em> 的指向问题。</p></blockquote><blockquote><p>解析：</p><p>在 <em>ES5</em> 时代，一旦对象的方法里面又存在函数，则 <em>this</em> 的指向往往会让开发人员抓狂。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">//错误案例，this 指向会指向 Windows 或者 undefined</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>; <span class="hljs-comment">// 18</span><br>        <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>; <span class="hljs-comment">// this 指向 window 或 undefined</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getAge</span>()); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>然而，箭头函数没有 <em>this</em>，箭头函数的 <em>this</em> 是继承父执行上下文里面的 <em>this</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>; <span class="hljs-comment">// 18</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>; <span class="hljs-comment">// this 指向 obj 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getAge</span>()); <span class="hljs-comment">// 2003</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="84-new-一个箭头函数后，它的-this-指向什么？"><a href="#84-new-一个箭头函数后，它的-this-指向什么？" class="headerlink" title="84. new 一个箭头函数后，它的 this 指向什么？"></a>84. <em>new</em> 一个箭头函数后，它的 <em>this</em> 指向什么？</h3><blockquote><p>参考答案：</p><p>我不知道这道题是出题人写错了还是故意为之。</p><p>箭头函数无法用来充当构造函数，所以是无法 <em>new</em> 一个箭头函数的。</p><p>当然，也有可能是面试官故意挖的一个坑，等着你往里面跳。</p></blockquote><h3 id="85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别"><a href="#85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别" class="headerlink" title="85. promise 的其他方法有用过吗？如 all、race。请说下这两者的区别"></a>85. <em>promise</em> 的其他方法有用过吗？如 <em>all、race</em>。请说下这两者的区别</h3><blockquote><p>参考答案：</p><p><em>promise.all</em> 方法参数是一个 <em>promise</em> 的数组,只有当所有的 <em>promise</em> 都完成并返回成功，才会调用 <em>resolve</em>，当有一个失败，都会进<em>catch</em>，被捕获错误，<em>promise.all</em> 调用成功返回的结果是每个 <em>promise</em> 单独调用成功之后返回的结果组成的数组,如果调用失败的话，返回的则是第一个 <em>reject</em> 的结果</p><p><em>promise.race</em> 也会调用所有的 <em>promise</em>，返回的结果则是所有 <em>promise</em> 中最先返回的结果，不关心是成功还是失败。</p></blockquote><h3 id="86-class-是如何实现的"><a href="#86-class-是如何实现的" class="headerlink" title="86. class 是如何实现的"></a>86. <em>class</em> 是如何实现的</h3><blockquote><p>参考答案：</p><p><em>class</em> 是 <em>ES6</em> 新推出的关键字，它是一个语法糖，本质上就是基于这个原型实现的。只不过在以前 <em>ES5</em> 原型实现的基础上，添加了一些 <em>_classCallCheck、_defineProperties、_createClass</em>等方法来做出了一些特殊的处理。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>   &#125;<br>   <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)<br>   &#125;<br>&#125;<br>javascript复制代码<span class="hljs-string">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) &#123;<br>     <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span>)) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Cannot call a class as a function&quot;</span>);<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-params">target, props</span>) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.<span class="hljs-property">length</span>; i++) &#123;<br>         <span class="hljs-keyword">var</span> descriptor = props[i];<br>         descriptor.<span class="hljs-property">enumerable</span> = descriptor.<span class="hljs-property">enumerable</span> || <span class="hljs-literal">false</span>;<br>         descriptor.<span class="hljs-property">configurable</span> = <span class="hljs-literal">true</span>;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-keyword">in</span> descriptor)<br>             descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">true</span>;<br>         <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, descriptor.<span class="hljs-property">key</span>, descriptor);<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_createClass</span>(<span class="hljs-params">Constructor, protoProps, staticProps</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Constructor::&quot;</span>,<span class="hljs-title class_">Constructor</span>);<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;protoProps::&quot;</span>,protoProps);<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;staticProps::&quot;</span>,staticProps);<br>     <span class="hljs-keyword">if</span> (protoProps)<br>         <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, protoProps);<br>     <span class="hljs-keyword">if</span> (staticProps)<br>         <span class="hljs-title function_">_defineProperties</span>(<span class="hljs-title class_">Constructor</span>, staticProps);<br>     <span class="hljs-keyword">return</span> <span class="hljs-title class_">Constructor</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params">x</span>) &#123;<br>       <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Hello</span>);<br><br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>   &#125;<br><br>   <span class="hljs-title function_">_createClass</span>(<span class="hljs-title class_">Hello</span>, [&#123;<br>       <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;greet&quot;</span>,<br>       <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>       &#125;<br> &#125;]);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Hello</span>;<br>&#125;();<br></code></pre></td></tr></table></figure></blockquote><h3 id="87-let、const、var-的区别"><a href="#87-let、const、var-的区别" class="headerlink" title="87. let、const、var 的区别"></a>87. <em>let、const、var</em> 的区别</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>22</em> 题答案。</p></blockquote><h3 id="88-ES6-中模块化导入和导出与-common-js-有什么区别"><a href="#88-ES6-中模块化导入和导出与-common-js-有什么区别" class="headerlink" title="88. ES6 中模块化导入和导出与 common.js 有什么区别"></a>88. <em>ES6</em> 中模块化导入和导出与 <em>common.js</em> 有什么区别</h3><blockquote><p>参考答案：</p><p>CommonJs模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化不会影响到这个值.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码// common.js<br>var <span class="hljs-attr">count</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br>var <span class="hljs-attr">printCount</span> = () =&gt;&#123; <br>  return ++count<span class="hljs-comment">;</span><br>&#125;<br><br><span class="hljs-attr">module.exports</span> = &#123;<br>    printCount: printCount,<br>    count: count<br>&#125;<span class="hljs-comment">;</span><br>// index.js<br>let <span class="hljs-attr">v</span> = require(<span class="hljs-string">&#x27;./common&#x27;</span>)<span class="hljs-comment">;</span><br>console.log(v.count)<span class="hljs-comment">; // 1</span><br>console.log(v.printCount())<span class="hljs-comment">; // 2</span><br>console.log(v.count)<span class="hljs-comment">; // 1</span><br></code></pre></td></tr></table></figure><p>你可以看到明明common.js里面改变了count，但是输出的结果还是原来的。这是因为count是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动的值。将common.js里面的module.exports 改写成</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码module.exports = &#123;<br>    printCount: printCount,<br>    <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">count</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> count<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样子的输出结果是 1，2，2</p><p>而在ES6当中，写法是这样的，是利用export 和import导入的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// es6.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printCount</span>(<span class="hljs-params"></span>) &#123;<br>    ++count;<br>&#125;<br><span class="hljs-comment">// main1.js</span><br><span class="hljs-keyword">import</span>  &#123; count, printCount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./es6&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">printCount</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count)<br></code></pre></td></tr></table></figure><p>ES6 模块是动态引用，并且不会缓存，模块里面的变量绑定其所有的模块，而是动态地去加载值，并且不能重新赋值，</p><p>ES6 输入的模块变量，只是一个“符号连接符”，所以这个变量是只读的，对它进行重新赋值会报错。如果是引用类型，变量指向的地址是只读的，但是可以为其添加属性或成员。</p><p>另外还想说一个 <em>export default</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printCount</span>(<span class="hljs-params"></span>) &#123;<br>    ++count;<br>&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; count, printCount&#125;<br><span class="hljs-comment">// main3.js</span><br><span class="hljs-keyword">import</span> res form <span class="hljs-string">&#x27;./main3.js&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">count</span>)<br></code></pre></td></tr></table></figure><p>export与export default的区别及联系：</p><ol><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>你可以在其它文件或模块中通过 import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</li><li>在一个文件或模块中，export、import可以有多个，export default仅有一个</li><li>通过export方式导出，在导入时要加{ }，export default则不需要。</li></ol></blockquote><h3 id="89-说一下普通函数和箭头函数的区别"><a href="#89-说一下普通函数和箭头函数的区别" class="headerlink" title="89. 说一下普通函数和箭头函数的区别"></a>89. 说一下普通函数和箭头函数的区别</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>8、25、83</em> 题答案。</p></blockquote><h3 id="90-说一下-promise-和-async-和-await-什么关系"><a href="#90-说一下-promise-和-async-和-await-什么关系" class="headerlink" title="90. 说一下 promise 和 async 和 await 什么关系"></a>90. 说一下 <em>promise</em> 和 <em>async</em> 和 <em>await</em> 什么关系</h3><blockquote><p>参考答案：</p><p><em>await</em> 表达式会造成异步函数停止执行并且等待<em>promise</em>的解决，当值被<em>resolved</em>，异步函数会恢复执行以及返回<em>resolved</em>值。如果该值不是一个<em>promise</em>，它将会被转换成一个<em>resolved</em>后的<em>promise</em>。如果<em>promise</em>被<em>rejected</em>，<em>await</em> 表达式会抛出异常值。</p></blockquote><h3 id="91-说一下你学习过的有关-ES6-的知识点"><a href="#91-说一下你学习过的有关-ES6-的知识点" class="headerlink" title="91. 说一下你学习过的有关 ES6 的知识点"></a>91. 说一下你学习过的有关 <em>ES6</em> 的知识点</h3><blockquote><p>参考答案：</p><p>这种题目是开放题，可以简单列举一下 <em>ES6</em> 的新增知识点。（ <em>ES6</em> 的新增知识点参阅前面第 <em>44</em> 题）</p><p>然后说一下自己平时开发中用得比较多的是哪些即可。</p><p>一般面试官会针对你所说的内容进行二次提问。例如：你回答平时开发中箭头函数用得比较多，那么面试官极大可能针对箭头函数展开二次提问，询问你箭头函数有哪些特性？箭头函数 <em>this</em> 特点之类的问题。</p></blockquote><h3 id="92-了解过-js-中-arguments-吗？接收的是实参还是形参？"><a href="#92-了解过-js-中-arguments-吗？接收的是实参还是形参？" class="headerlink" title="92. 了解过 js 中 arguments 吗？接收的是实参还是形参？"></a>92. 了解过 <em>js</em> 中 <em>arguments</em> 吗？接收的是实参还是形参？</h3><blockquote><p>参考答案：</p><p><em>JS</em> 中的 <em>arguments</em> 是一个伪数组对象。这个伪数组对象将包含调用函数时传递的所有的实参。</p><p>与之相对的，<em>JS</em> 中的函数还有一个 <em>length</em> 属性，返回的是函数形参的个数。</p></blockquote><h3 id="93-ES6-相比于-ES5-有什么变化"><a href="#93-ES6-相比于-ES5-有什么变化" class="headerlink" title="93. ES6 相比于 ES5 有什么变化"></a>93. <em>ES6</em> 相比于 <em>ES5</em> 有什么变化</h3><blockquote><p>参考答案：</p><p><em>ES6</em> 相比 <em>ES5</em> 新增了很多新特性，这里可以自己简述几个。</p><p>具体的新增特性可以参阅前面第 <em>44</em> 题。</p></blockquote><h3 id="94-强制类型转换方法有哪些？"><a href="#94-强制类型转换方法有哪些？" class="headerlink" title="94. 强制类型转换方法有哪些？"></a>94. 强制类型转换方法有哪些？</h3><blockquote><p>参考答案：</p><p>JavaScript 中的数据类型转换，主要有三种方式：</p><ol><li>转换函数</li></ol><p><em>js</em> 提供了诸如 <em>parseInt</em> 和 <em>parseFloat</em> 这些转换函数，通过这些转换函数可以进行数据类型的转换 。</p><ol><li>强制类型转换</li></ol><p>还可使用强制类型转换（<em>type casting</em>）处理转换值的类型。</p><p>例如：</p><ul><li><em>Boolean</em>(<em>value</em>) 把给定的值转换成 <em>Boolean</em> 型；</li><li><em>Number</em>(<em>value</em>)——把给定的值转换成数字（可以是整数或浮点数）；</li><li><em>String</em>(<em>value</em>)——把给定的值转换成字符串。</li></ul><ol><li>利用 <em>js</em> 变量弱类型转换。</li></ol><p>例如：</p><ul><li>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></li><li>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></li><li>转换数值：数据*1 或 &#x2F;1，例如：<code>&quot;Hello * 1&quot;</code></li></ul></blockquote><h3 id="95-纯函数"><a href="#95-纯函数" class="headerlink" title="95. 纯函数"></a>95. 纯函数</h3><blockquote><p>参考答案：</p><p>一个函数，如果符合以下两个特点，那么它就可以称之为<strong>纯函数</strong>：</p><ol><li>对于相同的输入，永远得到相同的输出</li><li>没有任何可观察到的副作用</li></ol></blockquote><blockquote><p>解析：</p><p>针对上面的两个特点，我们一个一个来看。</p><ul><li>相同输入得到相同输出</li></ul><p>我们先来看一个不纯的反面典型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&#x27;Hello&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span> (name) &#123;<br>  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">&#x27; &#x27;</span> + name<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;World&#x27;</span>)) <span class="hljs-comment">// Hello World</span><br></code></pre></td></tr></table></figure><p>上面的代码中，<em>greet(‘World’)</em>  是不是永远返回 <em>Hello World</em> ? 显然不是，假如我们修改 <em>greeting</em> 的值，就会影响 <em>greet</em> 函数的输出。即函数 <em>greet</em> 其实是 <strong>依赖外部状态</strong> 的。</p><p>那我们做以下修改：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">arduino复制代码<span class="hljs-function">function <span class="hljs-title">greet</span> <span class="hljs-params">(greeting, name)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> greeting + <span class="hljs-string">&#x27; &#x27;</span> + name<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">greet</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;Savo&#x27;</span>)) <span class="hljs-comment">// Hi Savo</span><br></code></pre></td></tr></table></figure><p>将 <em>greeting</em> 参数也传入，这样对于任何输入参数，都有与之对应的唯一的输出参数了，该函数就符合了第一个特点。</p><ul><li>没有副作用</li></ul><p>副作用的意思是，这个函数的运行，<strong>不会修改外部的状态</strong>。</p><p>下面再看反面典型：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码const <span class="hljs-attr">user</span> = &#123;<br>  username: &#x27;savokiss&#x27;<br>&#125;<br><br>let <span class="hljs-attr">isValid</span> = <span class="hljs-literal">false</span><br><br>function validate (user) &#123;<br>  if (user.username.length &gt; 4) &#123;<br>    <span class="hljs-attr">isValid</span> = <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，执行函数的时候会修改到 <em>isValid</em> 的值（注意：如果你的函数没有任何返回值，那么它很可能就具有副作用！）</p><p>那么我们如何移除这个副作用呢？其实不需要修改外部的 <em>isValid</em> 变量，我们只需要在函数中将验证的结果 <em>return</em> 出来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">php复制代码<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">user</span> = &#123;<br>  username: <span class="hljs-string">&#x27;savokiss&#x27;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate</span> (<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> user.username.length &gt; <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">isValid</span> = <span class="hljs-title function_ invoke__">validate</span>(user)<br></code></pre></td></tr></table></figure><p>这样 <em>validate</em> 函数就不会修改任何外部的状态了~</p></blockquote><h3 id="96-JS-模块化"><a href="#96-JS-模块化" class="headerlink" title="96. JS 模块化"></a>96. <em>JS</em> 模块化</h3><blockquote><p>参考答案：</p><p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p><p>模块化的整个发展历史如下：</p><p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">data</span>:[]<br> &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p><strong>AMD</strong>： 使用requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)&#123;<br><span class="hljs-comment">// code 就是index.js 返回的内容</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>CMD</strong>： 使用seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;  <br> <span class="hljs-keyword">var</span> indexCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini<br>复制代码var <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>UMD</strong>：兼容AMD，CommonJS 模块化语法。</p><p><strong>webpack(require.ensure)</strong> ：webpack 2.x 版本中的代码分割。</p><p><strong>ES Modules</strong>： ES6 引入的模块化，支持import 来引入另一个 js 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码import <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">from</span> &#x27;<span class="hljs-selector-tag">a</span>&#x27;;<br></code></pre></td></tr></table></figure></blockquote><h3 id="97-看过-jquery-源码吗？"><a href="#97-看过-jquery-源码吗？" class="headerlink" title="97. 看过 jquery 源码吗？"></a>97. 看过 <em>jquery</em> 源码吗？</h3><blockquote><p>参考答案：</p><p>开放题，但是需要注意的是，如果看过 <em>jquery</em> 源码，不要简单的回答一个“看过”就完了，应该继续乘胜追击，告诉面试官例如哪个哪个部分是怎么怎么实现的，并针对这部分的源码实现，可以发表一些自己的看法和感想。</p></blockquote><h3 id="98-说一下-js-中的-this"><a href="#98-说一下-js-中的-this" class="headerlink" title="98. 说一下 js 中的 this"></a>98. 说一下 <em>js</em> 中的 <em>this</em></h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>17</em> 题答案。</p></blockquote><h3 id="99-apply-call-bind-区别，手写"><a href="#99-apply-call-bind-区别，手写" class="headerlink" title="99. apply call bind 区别，手写"></a>99. <em>apply call bind</em> 区别，手写</h3><blockquote><p>参考答案：</p><p>apply call bind 区别 ？</p><p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p><ul><li><em>fn.call(obj, arg1, arg2, …)</em>  调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li><li><em>fn.apply(obj, [argsArray])</em>  调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li></ul><p><em>bind</em> 和 <em>call&#x2F;apply</em> 有一个很重要的区别，一个函数被 <em>call&#x2F;apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em>  的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><p>实现 <em>call</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>   <span class="hljs-comment">//没传参数或者为 null 是默认是 window</span><br>   <span class="hljs-keyword">var</span> context = context || (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-variable language_">window</span> : <span class="hljs-variable language_">global</span>)<br>   <span class="hljs-comment">// 首先要获取调用 call 的函数，用 this 可以获取</span><br>   context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span><br>   <span class="hljs-keyword">var</span> args = []<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>       args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>   &#125;<br>   <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>   <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>   <span class="hljs-attr">value</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>&#125;<br>bar.<span class="hljs-title function_">call2</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-comment">// 浏览器环境： 3 undefinde undefinde   </span><br><span class="hljs-comment">// Node环境：undefinde undefinde undefinde</span><br><br>bar.<span class="hljs-title function_">call2</span>(foo, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-number">18</span>) <span class="hljs-comment">// 2  cc 18</span><br></code></pre></td></tr></table></figure><p>实现 <em>apply</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) &#123;<br>   <span class="hljs-keyword">var</span> context = context || (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-variable language_">window</span> : <span class="hljs-variable language_">global</span>)<br>   context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>   <span class="hljs-keyword">var</span> result;<br>   <span class="hljs-keyword">if</span> (!arr) &#123;<br>       result = context.<span class="hljs-title function_">fn</span>();<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">var</span> args = [];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>           args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arr[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>       &#125;<br>       result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 测试：</span><br><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> foo = &#123;<br>   <span class="hljs-attr">value</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>&#125;<br>bar.<span class="hljs-title function_">apply2</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-comment">// 浏览器环境： 3 undefinde undefinde   </span><br><span class="hljs-comment">// Node环境：undefinde undefinde undefinde</span><br><br>bar.<span class="hljs-title function_">apply2</span>(foo, [<span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-number">18</span>]) <span class="hljs-comment">// 2  cc 18</span><br></code></pre></td></tr></table></figure><p>实现 <em>bind</em> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">oThis</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>       <span class="hljs-comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span><br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">var</span> aArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>),<br>       fToBind = <span class="hljs-variable language_">this</span>,<br>       fNOP = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;,<br>       fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">return</span> fToBind.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP &amp;&amp; oThis<br>               ? <span class="hljs-variable language_">this</span><br>               : oThis || <span class="hljs-variable language_">window</span>,<br>               aArgs.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)));<br>       &#125;;<br><br>   fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>   fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();<br><br>   <span class="hljs-keyword">return</span> fBound;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> test = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;jack&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> demo = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;rose&quot;</span>,<br>   <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(demo.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 rose  这里的 this 指向 demo</span><br><br><span class="hljs-comment">// 运用 bind 方法更改 this 指向</span><br><span class="hljs-keyword">var</span> another2 = demo.<span class="hljs-property">getName</span>.<span class="hljs-title function_">bind2</span>(test);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">another2</span>()); <span class="hljs-comment">// 输出 jack  这里 this 指向了 test 对象了</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="100-手写-reduce-flat"><a href="#100-手写-reduce-flat" class="headerlink" title="100. 手写 reduce flat"></a>100. 手写 <em>reduce flat</em></h3><blockquote><p>参考答案：</p><p><em>reduce</em> 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">my_reduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">this</span>) || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> || <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> []<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 判断是否有初始值</span><br>        <span class="hljs-keyword">let</span> hasInitialValue = initialValue !== <span class="hljs-literal">undefined</span>;<br>        <span class="hljs-keyword">let</span> value = hasInitialValue ? initialValue : tihs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = hasInitialValue ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; index++) &#123;<br>            <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">this</span>[index];<br>            value = <span class="hljs-title function_">callback</span>(value, element, index, <span class="hljs-variable language_">this</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> res = arr.<span class="hljs-title function_">my_reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur, i, arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pre, cur, i, arr)<br>    <span class="hljs-keyword">return</span> pre + cur<br>&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<span class="hljs-comment">//25</span><br></code></pre></td></tr></table></figure><p><em>flat</em> 实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript复制代码<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;zs&quot;</span>], <span class="hljs-number">7</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]]]]]];<br><br><span class="hljs-comment">//万能的类型检测方法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">checkType</span> = (<span class="hljs-params">arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//自定义flat方法，注意：不可以使用箭头函数，使用后内部的this会指向window</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myFlat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;<br>    <span class="hljs-comment">//判断第一层数组的类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span> = <span class="hljs-title function_">checkType</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">//创建一个新数组，用于保存拆分后的数组</span><br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-comment">//若当前对象非数组则返回undefined</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-keyword">type</span>, <span class="hljs-string">&quot;Array&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//遍历所有子元素并判断类型，若为数组则继续递归，若不为数组则直接加入新数组</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> cellType = <span class="hljs-title function_">checkType</span>(item);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(cellType, <span class="hljs-string">&quot;Array&quot;</span>)) &#123;<br>            <span class="hljs-comment">//形参num，表示当前需要拆分多少层数组，传入Infinity则将多维直接降为一维</span><br>            num--;<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">let</span> newArr = result.<span class="hljs-title function_">push</span>(item);<br>                <span class="hljs-keyword">return</span> newArr;<br>            &#125;<br>            <span class="hljs-comment">//使用三点运算符解构，递归函数返回的数组，并加入新数组</span><br>            result.<span class="hljs-title function_">push</span>(...item.<span class="hljs-title function_">myFlat</span>(num));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(item);<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)); <span class="hljs-comment">//[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">myFlat</span>(<span class="hljs-title class_">Infinity</span>)); <span class="hljs-comment">//[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];</span><br><span class="hljs-comment">//自定义方法和自带的flat返回结果一致!!!!</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>();<br></code></pre></td></tr></table></figure></blockquote><h3 id="101-x3D-x3D-隐试转换的原理？是怎么转换的"><a href="#101-x3D-x3D-隐试转换的原理？是怎么转换的" class="headerlink" title="101. &#x3D;&#x3D; 隐试转换的原理？是怎么转换的"></a>101. &#x3D;&#x3D; 隐试转换的原理？是怎么转换的</h3><blockquote><p>参考答案：</p><p><strong>两个与类型转换有关的函数：valueOf()和toString()</strong></p><ul><li>valueOf()的语义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li><li>toString()的语义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。</li></ul><p>valueOf()和toString()是定义在Object.prototype上的方法，也就是说，所有的对象都会继承到这两个方法。但是在Object.prototype上定义的这两个方法往往不能满足我们的需求（Object.prototype.valueOf()仅仅返回对象本身），因此js的许多内置对象都重写了这两个函数，以实现更适合自身的功能需要（比如说，String.prototype.valueOf就覆盖了在Object.prototype中定义的valueOf）。当我们自定义对象的时候，最好也重写这个方法。重写这个方法时要遵循上面所说的语义。</p><p><strong>js内部用于实现类型转换的4个函数</strong></p><p>这4个方法实际上是ECMAScript定义的4个抽象的操作，它们在js内部使用，进行类型转换。js的使用者不能直接调用这些函数。</p><ul><li>ToPrimitive ( input [ , PreferredType ] )</li><li>ToBoolean ( argument )</li><li>ToNumber ( argument )</li><li>ToString ( argument )</li></ul><p>需要区分这里的 ToString() 和上文谈到的 toString()，一个是 js 引擎内部使用的函数，另一个是定义在对象上的函数。</p><p>（1）ToPrimitive ( input [ , PreferredType ] )</p><p>将 input 转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p><ol><li>如果input本身就是原始类型，直接返回input。</li><li>调用<strong>input.valueOf()</strong> ，如果结果是原始类型，则返回这个结果。</li><li>调用<strong>input.toString()</strong> ，如果结果是原始类型，则返回这个结果。</li><li>抛出TypeError异常。</li></ol><p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p><ul><li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li><li>如果PreferredType参数没有传入<ul><li>如果input是内置的Date类型，PreferredType 视为String</li><li>否则PreferredType 视为 Number</li></ul></li></ul><p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong></p><p>（2）ToBoolean ( argument )</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/9fa45b887099455781de45fb9a76f327tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="image-20210819164742154"><p>只需要记忆 <em>0, null, undefined, NaN, “”</em>  返回 <em>false</em> 就可以了，其他一律返回 <em>true</em>。</p><p>（3）ToNumber ( argument )</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/9ad3882dfe664ca99d6aa14b4e28ad55tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="image-20210819164927980"><p>ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p><p>（4）ToString ( argument )</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/4627620de516406ea6273b0ccc8c964btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="image-20210819165004906"><p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p></blockquote><h3 id="102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）"><a href="#102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）" class="headerlink" title="102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）"></a>102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）</h3><blockquote><p>参考答案：</p><p>[1, NaN, NaN]</p></blockquote><blockquote><p>解析：</p><p>一、为什么会是这个结果？</p><ol><li><em>map</em> 函数</li></ol><p>将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 <em>[‘1’,’2’,’3’].map(parseInt)</em>  就是将字符串 <em>1，2，3</em> 作为元素；<em>0，1，2</em> 作为下标分别调用 <em>parseInt</em> 函数。即分别求出 <em>parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2)</em>  的结果。</p><ol><li><em>parseInt</em> 函数（重点）</li></ol><p>概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) &#x2F;&#x2F;结果为2</p><p>特点：接收两个参数 <em>parseInt(string,radix)</em></p><p><em>string</em>：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 ‘2’、’2w’、’2!’</p><p><em>radix</em>：解析字符串的基数，基数规则如下：</p><p>1） 区间范围介于 <em>2~36</em> 之间；</p><p>2 ） 当参数为 <em>0</em>，<em>parseInt( )</em>  会根据十进制来解析；</p><p>3 ） 如果忽略该参数，默认的基数规则：</p><p> 如果 <em>string</em> 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(“0xf”) &#x2F;&#x2F; 15<br> ​ 如果 <em>string</em> 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt(“08”) &#x2F;&#x2F; 8<br> ​ 如果 <em>string</em> 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt(“88.99f”) &#x2F;&#x2F; 88<br> ​ 只有字符串中的第一个数字会被返回。parseInt(“10.33”) &#x2F;&#x2F; 返回10；<br> ​ 开头和结尾的空格是允许的。parseInt(“ 69 10 “) &#x2F;&#x2F; 返回69<br> ​ 如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt(“f”) &#x2F;&#x2F; 返回 NaN 而 parseInt(“f”，16) &#x2F;&#x2F; 返回15</p><p>二、<em>parseInt</em> 方法解析的运算过程</p><p>parseInt(‘101.55’,10); &#x2F;&#x2F; 以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。</p><p>parseInt(‘101’,2); &#x2F;&#x2F; 以二进制解析，运算过程：1<em>2的2次方+0</em>2的1次方+1*2的0次方&#x3D;4+0+1&#x3D;5，结果为 5。</p><p>parseInt(‘101’,8); &#x2F;&#x2F; 以八进制解析，运算过程：1<em>8的2次方+0</em>8的1次方+1*8的0次方&#x3D;64+0+1&#x3D;65，结果为 65。</p><p>parseInt(‘101’,16); &#x2F;&#x2F; 以十六进制解析，运算过程：1<em>16的2次方+0</em>16的1次方+1*16的0次方&#x3D;256+0+1&#x3D;257，结果为 257。</p><p>三、再来分析一下结果</p><p><em>[‘1’,’2’,’3’].map(parseInt)</em>  即</p><p>parseInt(‘1’,0); radix 为 0，parseInt( ) 会根据十进制来解析，所以结果为 <em>1</em>；</p><p>parseInt(‘2’,1); radix 为 1，超出区间范围，所以结果为 <em>NaN</em>；</p><p>parseInt(‘3’,2); radix 为 2，用2进制来解析，应以 <em>0</em> 和 <em>1</em> 开头，所以结果为 <em>NaN</em>。</p></blockquote><h3 id="103-防抖，节流是什么，如何实现-（字节）"><a href="#103-防抖，节流是什么，如何实现-（字节）" class="headerlink" title="103. 防抖，节流是什么，如何实现 （字节）"></a>103. 防抖，节流是什么，如何实现 （字节）</h3><blockquote><p>参考答案：</p><p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p><p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p><p>具体实现：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数防抖</span><br><span class="hljs-comment"> * @param &#123;function&#125; func 一段时间后，要调用的函数</span><br><span class="hljs-comment"> * @param &#123;number&#125; wait 等待的时间，单位毫秒</span><br><span class="hljs-comment"> */</span><br>function <span class="hljs-built_in">debounce</span>(func, wait)&#123;<br>    <span class="hljs-comment">// 设置变量，记录 setTimeout 得到的 id</span><br>    let timerId = null;<br>    return <span class="hljs-built_in">function</span>(...args)&#123;<br>        <span class="hljs-built_in">if</span>(timerId)&#123;<br>            <span class="hljs-comment">// 如果有值，说明目前正在等待中，清除它</span><br>            <span class="hljs-built_in">clearTimeout</span>(timerId);<br>        &#125;<br>        <span class="hljs-comment">// 重新开始计时</span><br>        timerId = <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>            <span class="hljs-built_in">func</span>(...args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p><p>具体实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function throttle(func, wait) &#123;<br>    let context, args<span class="hljs-comment">;</span><br>    let <span class="hljs-attr">previous</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    return function () &#123;<br>        let <span class="hljs-attr">now</span> = +new Date()<span class="hljs-comment">;</span><br>        <span class="hljs-attr">context</span> = this<span class="hljs-comment">;</span><br>        <span class="hljs-attr">args</span> = arguments<span class="hljs-comment">;</span><br>        if (now - previous &gt; wait) &#123;<br>            func.apply(context, args)<span class="hljs-comment">;</span><br>            <span class="hljs-attr">previous</span> = now<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）"><a href="#104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）" class="headerlink" title="104. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别（字节）"></a>104. 介绍下 <em>Set、Map、WeakSet</em> 和 <em>WeakMap</em> 的区别（字节）</h3><blockquote><p>参考答案：</p><p><strong>Set</strong></p><ul><li>成员唯一、无序且不重复</li><li>键值与键名是一致的（或者说只有键值，没有键名）</li><li>可以遍历，方法有 <em>add, delete,has</em></li></ul><p><strong>WeakSet</strong></p><ul><li>成员都是对象</li><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 <em>DOM</em> 节点，不容易造成内存泄漏</li><li>不能遍历，方法有 <em>add, delete,has</em></li></ul><p><strong>Map</strong></p><ul><li>本质上是健值对的集合，类似集合</li><li>可以遍历，方法很多，可以跟各种数据格式转换</li></ul><p><strong>WeakMap</strong></p><ul><li>只接受对象作为健名（<em>null</em> 除外），不接受其他类型的值作为健名</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾机制回收，此时键名是无效的</li><li>不能遍历，方法有 <em>get、set、has、delete</em></li></ul></blockquote><h3 id="105-setTimeout、Promise、Async-x2F-Await-的区别（字节）"><a href="#105-setTimeout、Promise、Async-x2F-Await-的区别（字节）" class="headerlink" title="105. setTimeout、Promise、Async&#x2F;Await 的区别（字节）"></a>105. <em>setTimeout、Promise、Async&#x2F;Await</em> 的区别（字节）</h3><blockquote><p>参考答案：</p><p>事件循环中分为宏任务队列和微任务队列。</p><p>其中 <em>setTimeout</em> 的回调函数放到宏任务队列里，等到执行栈清空以后执行；</p><p><em>promise.then</em> 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；</p><p><em>async</em> 函数表示函数里面可能会有异步方法，<em>await</em> 后面跟一个表达式，<em>async</em> 方法执行时，遇到 <em>await</em> 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p></blockquote><h3 id="106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）"><a href="#106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）" class="headerlink" title="106. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？（字节）"></a>106. <em>Promise</em> 构造函数是同步执行还是异步执行，那么 <em>then</em> 方法呢？（字节）</h3><blockquote><p>参考答案：</p><p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p></blockquote><h3 id="107-情人节福利题，如何实现一个-new-（字节）"><a href="#107-情人节福利题，如何实现一个-new-（字节）" class="headerlink" title="107. 情人节福利题，如何实现一个 new （字节）"></a>107. 情人节福利题，如何实现一个 <em>new</em> （字节）</h3><blockquote><p>参考答案：<br> 首先我们需要明白 <em>new</em> 的原理。关于 <em>new</em> 的原理，主要分为以下几步：</p><ul><li>创建一个空对象 。</li><li>由 <em>this</em> 变量引用该对象 。</li><li>该对象继承该函数的原型(更改原型链的指向) 。</li><li>把属性和方法加入到 <em>this</em> 引用的对象中。</li><li>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em></li></ul><p>明白了这个原理后，我们就可以尝试来实现一个 <em>new</em> 方法，参考示例如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 构造器函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) &#123;  <br>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>](<span class="hljs-attr">http</span>:<span class="hljs-comment">//this.name) = name;  </span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <br>&#125;;  <br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>](<span class="hljs-attr">http</span>:<span class="hljs-comment">//this.name));  </span><br>&#125;;  <br><span class="hljs-comment">//自己定义的new方法  </span><br><span class="hljs-keyword">let</span> newMethod = <span class="hljs-keyword">function</span> (<span class="hljs-params">Parent, ...rest</span>) &#123;  <br><span class="hljs-comment">// 1.以构造器的prototype属性为原型，创建新对象；  </span><br><span class="hljs-keyword">let</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <br><span class="hljs-comment">// 2.将this和调用参数传给构造器执行  </span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">apply</span>(child, rest);  <br><span class="hljs-comment">// 3.如果构造器没有手动返回对象，则返回第一步的对象  </span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> ? result : child;  <br>&#125;;  <br><span class="hljs-comment">//创建实例，将构造函数Parent与形参作为参数传入  </span><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">newMethod</span>(<span class="hljs-title class_">Parent</span>, <span class="hljs-string">&#x27;echo&#x27;</span>, <span class="hljs-number">26</span>);  <br>child.<span class="hljs-title function_">sayName</span>() <span class="hljs-comment">//&#x27;echo&#x27;;  </span><br><span class="hljs-comment">//最后检验，与使用new的效果相同  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Parent</span>)<span class="hljs-comment">//true  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>))<span class="hljs-comment">//true  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;age&#x27;</span>))<span class="hljs-comment">//true  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;sayName&#x27;</span>))<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="108-实现一个-sleep-函数（字节）"><a href="#108-实现一个-sleep-函数（字节）" class="headerlink" title="108. 实现一个 sleep 函数（字节）"></a>108. 实现一个 <em>sleep</em> 函数（字节）</h3><blockquote><p>参考答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">delay</span>) &#123;<br>    <span class="hljs-keyword">var</span> start = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">getTime</span>();<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">getTime</span>() - start &lt; delay) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111&#x27;</span>);<br>    <span class="hljs-title function_">sleep</span>(<span class="hljs-number">2000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;222&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><p>这种实现方式是利用一个伪死循环阻塞主线程。因为 <em>JS</em> 是单线程的。所以通过这种方式可以实现真正意义上的 <em>sleep</em>。</p></blockquote><h3 id="109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）"><a href="#109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）" class="headerlink" title="109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）"></a>109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）</h3><blockquote><p>参考答案：</p><p><em>sort</em> 方法默认按照 <em>ASCII</em> 码来排序，如果要按照数字大小来排序，需要传入一个回调函数，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码<span class="hljs-selector-attr">[3, 15, 8, 29, 102, 22]</span><span class="hljs-selector-class">.sort</span>((<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>) =&gt; &#123;return <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span>&#125;);<br></code></pre></td></tr></table></figure></blockquote><h3 id="110-实现-5-add-3-sub-2-百度"><a href="#110-实现-5-add-3-sub-2-百度" class="headerlink" title="110. 实现 5.add(3).sub(2) (百度)"></a>110. 实现 5.add(3).sub(2) (百度)</h3><blockquote><p>参考答案：</p><p>这里想要实现的是链式操作，那么我们可以考虑在 <em>Number</em> 类型的原型上添加 <em>add</em> 和 <em>sub</em> 方法，这两个方法返回新的数</p><p>示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript复制代码<span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">number</span> !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入数字～&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>() + <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">minus</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">number</span> !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请输入数字～&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>() - <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">5</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">minus</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="111-给定两个数组，求交集"><a href="#111-给定两个数组，求交集" class="headerlink" title="111. 给定两个数组，求交集"></a>111. 给定两个数组，求交集</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function intersect(nums1, nums2) &#123;<br>    let <span class="hljs-attr">i</span> = j = <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">len1</span> = nums1.length,<br>        <span class="hljs-attr">len2</span> = nums2.length,<br>        <span class="hljs-attr">newArr</span> = []<span class="hljs-comment">;</span><br>    if (<span class="hljs-attr">len1</span> === <span class="hljs-number">0</span> || len2 === <span class="hljs-number">0</span>) &#123;<br>        return newArr<span class="hljs-comment">;</span><br>    &#125;<br>    nums1.sort(function (a, b) &#123;<br>        return a - b<span class="hljs-comment">;</span><br>    &#125;)<span class="hljs-comment">;</span><br>    nums2.sort(function (a, b) &#123;<br>        return a - b<span class="hljs-comment">;</span><br>    &#125;)<span class="hljs-comment">;</span><br>    while (i &lt; len1 || j &lt; len2) &#123;<br>        if (nums1<span class="hljs-section">[i]</span> &gt; nums2<span class="hljs-section">[j]</span>) &#123;<br>            j++<span class="hljs-comment">;</span><br>        &#125; else if (nums1<span class="hljs-section">[i]</span> &lt; nums2<span class="hljs-section">[j]</span>) &#123;<br>            i++<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            if (nums1<span class="hljs-section">[i]</span> === nums2<span class="hljs-section">[j]</span>) &#123;<br>                newArr.push(nums1<span class="hljs-section">[i]</span>)<span class="hljs-comment">;</span><br>            &#125;<br>            if (i &lt; len1 - 1) &#123;<br>                i++<span class="hljs-comment">;</span><br>            &#125; else &#123;<br>                break<span class="hljs-comment">;</span><br>            &#125;<br>            if (j &lt; len2 - 1) &#123;<br>                j++<span class="hljs-comment">;</span><br>            &#125; else &#123;<br>                break<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    return newArr<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>// 测试<br>console.log(intersect(<span class="hljs-section">[3, 5, 8, 1]</span>, <span class="hljs-section">[2, 3]</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。"><a href="#112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。" class="headerlink" title="112. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。"></a>112. 为什么普通 <em>for</em> 循环的性能远远高于 <em>forEach</em> 的性能，请解释其中的原因。</h3><blockquote><p>参考答案：</p><p><em>for</em> 循环按顺序遍历，<em>forEach</em> 使用 <em>iterator</em> 迭代器遍历</p><p>下面是一段性能测试的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> arrs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;for&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrs.<span class="hljs-property">length</span>; i++) &#123;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;for&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;forEach&#x27;</span>);<br>arrs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;forEach&#x27;</span>);<br><br><span class="hljs-attr">for</span>: <span class="hljs-number">2.</span>263ms<br><span class="hljs-attr">forEach</span>: <span class="hljs-number">0.</span>254ms<br></code></pre></td></tr></table></figure><p>在10万这个级别下，<code>forEach</code>的性能是<code>for</code>的十倍</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">makefile复制代码for: 2.263ms</span><br><span class="hljs-section">forEach: 0.254ms</span><br></code></pre></td></tr></table></figure><p>在100万这个量级下，<code>forEach</code>的性能是和<code>for</code>的一致</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">makefile复制代码for: 2.844ms</span><br><span class="hljs-section">forEach: 2.652ms</span><br></code></pre></td></tr></table></figure><p>在1000万级以上的量级上 ，<code>forEach</code>的性能远远低于<code>for</code>的性能</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">makefile复制代码for: 8.422ms</span><br><span class="hljs-section">forEach: 30.328m</span><br></code></pre></td></tr></table></figure><p>我们从语法上面来观察：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码arr<span class="hljs-selector-class">.forEach</span>(callback(currentValue <span class="hljs-selector-attr">[, index [, array]</span>])<span class="hljs-selector-attr">[, thisArg]</span>)<br></code></pre></td></tr></table></figure><p>可以看到 <em>forEach</em> 是有回调的，它会按升序为数组中含有效值的每一项执行一次 <em>callback</em>，且除了抛出异常以外，也没有办法中止或者跳出 <em>forEach</em> 循环。那这样的话执行就会额外的调用栈和函数内的上下文。</p><p>而 <em>for</em> 循环则是底层写法，不会产生额外的消耗。</p><p>在实际业务中没有很大的数组时，<em>for</em> 和 <em>forEach</em> 的性能差距其实很小，<em>forEach</em> 甚至会优于 <em>for</em> 的时间，且更加简洁，可读性也更高，一般也会优先使用 <em>forEach</em> 方法来进行数组的循环处理。</p></blockquote><h3 id="113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。"><a href="#113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。" class="headerlink" title="113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。"></a>113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</h3><blockquote><p>参考答案：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码// 完全不用 API<br>var <span class="hljs-attr">getIndexOf</span> = function (s, t) &#123;<br>    let <span class="hljs-attr">n</span> = s.length<span class="hljs-comment">;</span><br>    let <span class="hljs-attr">m</span> = t.length<span class="hljs-comment">;</span><br>    if (!n || !m || n &lt; m) return -1<span class="hljs-comment">;</span><br>    for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; n; i++) &#123;</span><br>        let <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        let <span class="hljs-attr">k</span> = i<span class="hljs-comment">;</span><br>        if (s<span class="hljs-section">[k]</span> === t<span class="hljs-section">[j]</span>) &#123;<br>            k++<span class="hljs-comment">; j++;</span><br>            while (k &lt; n &amp;&amp; j &lt; m) &#123;<br>                if (s<span class="hljs-section">[k]</span> !== t<span class="hljs-section">[j]</span>) break<span class="hljs-comment">;</span><br>                else &#123;<br>                    k++<span class="hljs-comment">; j++;</span><br>                &#125;<br>            &#125;<br>            if (<span class="hljs-attr">j</span> === m) return i<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    return -1<span class="hljs-comment">;</span><br>&#125;<br><br>// 测试<br>console.log(getIndexOf(&quot;Hello World&quot;, &quot;rl&quot;))<br></code></pre></td></tr></table></figure></blockquote><h3 id="114-使用-JavaScript-Proxy-实现简单的数据绑定"><a href="#114-使用-JavaScript-Proxy-实现简单的数据绑定" class="headerlink" title="114. 使用 JavaScript Proxy 实现简单的数据绑定"></a>114. 使用 <em>JavaScript Proxy</em> 实现简单的数据绑定</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  hello,world<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;model&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;word&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> model = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;model&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> word = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;word&quot;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> obj= &#123;&#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setting&#x27;</span>,target, key, value, receiver);</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;text&quot;</span>) &#123;</span><br><span class="language-javascript">          model.<span class="hljs-property">value</span> = value;</span><br><span class="language-javascript">          word.<span class="hljs-property">innerHTML</span> = value;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  model.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keyup&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;</span><br><span class="language-javascript">    newObj.<span class="hljs-property">text</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）"><a href="#115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）" class="headerlink" title="115. 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少（字节）"></a>115. 数组里面有 <em>10</em> 万个数据，取第一个元素和第 <em>10</em> 万个元素的时间相差多少（字节）</h3><blockquote><p>参考答案：</p><p>消耗时间几乎一致，差异可以忽略不计</p></blockquote><blockquote><p>解析：</p><ul><li>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</li><li><em>JavaScript</em> 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 <em>key</em>）来使用。所以无论是取第 <em>1</em> 个还是取第 <em>10</em> 万个元素，都是用 <em>key</em> 精确查找哈希表的过程，其消耗时间大致相同。</li></ul></blockquote><h3 id="116-打印出-1-10000-以内的对称数"><a href="#116-打印出-1-10000-以内的对称数" class="headerlink" title="116. 打印出 1~10000 以内的对称数"></a>116. 打印出 <em>1~10000</em> 以内的对称数</h3><blockquote><p>参考答案：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function isSymmetryNum(start, end) &#123;<br>    for (var <span class="hljs-attr">i</span> = start<span class="hljs-comment">; i &lt; end + 1; i++) &#123;</span><br>        var <span class="hljs-attr">iInversionNumber</span> = +(i.toString().split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>))<span class="hljs-comment">;</span><br><br>        if (<span class="hljs-attr">iInversionNumber</span> === i &amp;&amp; i &gt; <span class="hljs-number">10</span>) &#123;<br>            console.log(i)<span class="hljs-comment">;</span><br>        &#125;<br><br>    &#125;<br>&#125;<br>isSymmetryNum(1, 10000)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="117-简述同步和异步的区别"><a href="#117-简述同步和异步的区别" class="headerlink" title="117. 简述同步和异步的区别"></a>117. 简述同步和异步的区别</h3><blockquote><p>参考答案：</p><p>同步意味着每一个操作必须等待前一个操作完成后才能执行。<br> 异步意味着操作不需要等待其他操作完成后才开始执行。<br> 在 <em>JavaScript</em> 中，由于单线程的特性导致所有代码都是同步的。但是，有些异步操作（例如：<code>XMLHttpRequest</code> 或 <code>setTimeout</code>）并不是由主线程进行处理的，他们由本机代码（浏览器 API）所控制，并不属于程序的一部分。但程序中被执行的回调部分依旧是同步的。</p><p>加分回答：</p><ul><li><em>JavaScript</em> 中的同步任务是指在主线程上排队执行的任务，只有前一个任务执行完成后才能执行后一个任务；异步任务是指进入任务队列（<em>task queue</em>）而非主线程的任务，只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程中进行执行。</li><li><em>JavaScript</em> 的并发模型是基于 “<em>event loop</em>”。</li><li>像 <code>alert</code> 这样的方法回阻塞主线程，以致用户关闭他后才能继续进行后续的操作。</li><li><em>JavaScript</em> 主要用于和用户互动及操作 DOM，多线程的情况和异步操作带来的复杂性相比决定了他单线程的特性。</li><li><em>Web Worker</em> 虽然允许 <em>JavaScript</em> 创建多个线程，但子线程完全受主线程控制，且不能操作 <em>DOM</em>。因此他还是保持了单线程的特性。</li></ul></blockquote><h3 id="118-怎么添加、移除、复制、创建、和查找节点"><a href="#118-怎么添加、移除、复制、创建、和查找节点" class="headerlink" title="118. 怎么添加、移除、复制、创建、和查找节点"></a>118. 怎么添加、移除、复制、创建、和查找节点</h3><blockquote><p>参考答案：</p><p>1）创建新节点</p><p><em>createDocumentFragment</em>( ) &#x2F;&#x2F; 创建一个<em>DOM</em> 片段</p><p><em>createElement</em>( ) &#x2F;&#x2F; 创建一个具体的元素</p><p><em>createTextNode</em>( ) &#x2F;&#x2F; 创建一个文本节点</p><p>（2）添加、移除、替换、插入</p><p><em>appendChild</em>( )</p><p><em>removeChild</em>( )</p><p><em>replaceChild</em>( )</p><p><em>insertBefore</em>( ) &#x2F;&#x2F; 在已有的子节点前插入一个新的子节点</p><p>（3）查找</p><p><em>getElementsByTagName</em>( ) &#x2F;&#x2F;通过标签名称</p><p><em>getElementsByName</em>( ) &#x2F;&#x2F; 通过元素的 <em>Name</em> 属性的值</p><p><em>getElementById</em>( ) &#x2F;&#x2F; 通过元素 <em>Id</em>，唯一性</p><p><em>querySelector</em>( ) &#x2F;&#x2F; 用于接收一个 <em>CSS</em> 选择符，返回与该模式匹配的第一个元素</p><p><em>querySelectorAll</em>( ) &#x2F;&#x2F; 用于选择匹配到的所有元素</p></blockquote><h3 id="119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制"><a href="#119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制" class="headerlink" title="119. 实现一个函数 clone 可以对 Javascript 中的五种主要数据类型（Number、string、 Object、Array、Boolean）进行复制"></a>119. 实现一个函数 <em>clone</em> 可以对 <em>Javascript</em> 中的五种主要数据类型（<em>Number、string、 Object、Array、Boolean</em>）进行复制</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码/**<br>* 对象克隆<br>* 支持基本数据类型及对象<br>* 递归方法<br>*/<br>function clone(obj) &#123;<br>    var o<span class="hljs-comment">;</span><br>    switch (typeof obj) &#123;<br>        case &quot;undefined&quot;:<br>            break<span class="hljs-comment">;</span><br>        case &quot;string&quot;:<br>            <span class="hljs-attr">o</span> = obj + <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>            break<span class="hljs-comment">;</span><br>        case &quot;number&quot;:<br>            <span class="hljs-attr">o</span> = obj - <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>            break<span class="hljs-comment">;</span><br>        case &quot;boolean&quot;:<br>            <span class="hljs-attr">o</span> = obj<span class="hljs-comment">;</span><br>            break<span class="hljs-comment">;</span><br>        case &quot;object&quot;: // object 分为两种情况 对象（Object）或数组（Array）<br>            if (<span class="hljs-attr">obj</span> === null) &#123;<br>                <span class="hljs-attr">o</span> = null<span class="hljs-comment">;</span><br>            &#125; else &#123;<br>                if (Object.prototype.toString.call(obj).slice(8, -1) === &quot;Array&quot;) &#123;<br>                    <span class="hljs-attr">o</span> = []<span class="hljs-comment">;</span><br>                    for (var <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; obj.length; i++) &#123;</span><br>                        o.push(clone(obj<span class="hljs-section">[i]</span>))<span class="hljs-comment">;</span><br>                    &#125;<br>                &#125; else &#123;<br>                    <span class="hljs-attr">o</span> = &#123;&#125;<span class="hljs-comment">;</span><br>                    for (var k in obj) &#123;<br>                        o<span class="hljs-section">[k]</span> = clone(obj<span class="hljs-section">[k]</span>)<span class="hljs-comment">;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            break<span class="hljs-comment">;</span><br>        default:<br>            <span class="hljs-attr">o</span> = obj<span class="hljs-comment">;</span><br>            break<span class="hljs-comment">;</span><br>    &#125;<br>    return o<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="120-如何消除一个数组里面重复的元素"><a href="#120-如何消除一个数组里面重复的元素" class="headerlink" title="120. 如何消除一个数组里面重复的元素"></a>120. 如何消除一个数组里面重复的元素</h3><blockquote><p>参考答案：</p><p>请点击<a href="https://juejin.cn/post/7153593226526457887#heading-3">2022高频前端面试题合集之JavaScript篇（上）</a> 第<em>2</em> 题。</p></blockquote><h3 id="121-写一个返回闭包的函数"><a href="#121-写一个返回闭包的函数" class="headerlink" title="121. 写一个返回闭包的函数"></a>121. 写一个返回闭包的函数</h3><blockquote><p>参考答案：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码function <span class="hljs-built_in">foo</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>;<br>    return function () &#123;<br>        console<span class="hljs-selector-class">.log</span>(i++);<br>    &#125;<br>&#125;<br><span class="hljs-selector-tag">var</span> f1 = <span class="hljs-built_in">foo</span>();<br><span class="hljs-built_in">f1</span>(); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">f1</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">f1</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="122-使用递归完成-1-到-100-的累加"><a href="#122-使用递归完成-1-到-100-的累加" class="headerlink" title="122. 使用递归完成 1 到 100 的累加"></a>122. 使用递归完成 1 到 100 的累加</h3><blockquote><p>参考答案：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sql</span>复制代码<span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(x, y)&#123;<br>    if(x <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> y)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> y <span class="hljs-operator">+</span> <span class="hljs-keyword">add</span>(x, y<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></blockquote><h3 id="123-Javascript-有哪几种数据类型"><a href="#123-Javascript-有哪几种数据类型" class="headerlink" title="123. Javascript 有哪几种数据类型"></a>123. <em>Javascript</em> 有哪几种数据类型</h3><blockquote><p>参考答案：</p><p>请点击<a href="https://juejin.cn/post/7153593226526457887#heading-3">2022高频前端面试题合集之JavaScript篇（上）</a>第 <em>25</em> 题。</p></blockquote><h3 id="124-如何判断数据类型"><a href="#124-如何判断数据类型" class="headerlink" title="124. 如何判断数据类型"></a>124. 如何判断数据类型</h3><blockquote><p>参考答案：</p><p>请点击<a href="https://juejin.cn/post/7153593226526457887#heading-3">2022高频前端面试题合集之JavaScript篇（上）</a>第 <em>69</em> 题。</p></blockquote><h3 id="125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果"><a href="#125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果" class="headerlink" title="125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果"></a>125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果</h3><blockquote><p>参考答案：</p><p>第一个打印出 ‘12’，是一个 <em>string</em> 类型的值。</p><p>第二个打印出 -1，是一个 <em>number</em> 类型的值</p></blockquote><h3 id="126-JS-的事件委托是什么，原理是什么"><a href="#126-JS-的事件委托是什么，原理是什么" class="headerlink" title="126. JS 的事件委托是什么，原理是什么"></a>126. <em>JS</em> 的事件委托是什么，原理是什么</h3><blockquote><p>参考答案：</p><p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p><p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p><p>对事件处理程序过多问题的解决方案就是事件委托。</p><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p></blockquote><h3 id="127-如何改变函数内部的-this-指针的指向"><a href="#127-如何改变函数内部的-this-指针的指向" class="headerlink" title="127. 如何改变函数内部的 this 指针的指向"></a>127. 如何改变函数内部的 <em>this</em> 指针的指向</h3><blockquote><p>参考答案：</p><p>可以通过 <em>call、apply、bind</em> 方法来改变 <em>this</em> 的指向，关于 <em>call、apply、bind</em> 方法的具体使用，请参阅前面 <em>102</em> 题</p></blockquote><h3 id="128-JS-延迟加载的方式有哪些？"><a href="#128-JS-延迟加载的方式有哪些？" class="headerlink" title="128. JS 延迟加载的方式有哪些？"></a>128. <em>JS</em> 延迟加载的方式有哪些？</h3><blockquote><p>参考答案：</p><ul><li><em>defer</em> 属性</li><li><em>async</em> 属性</li><li>使用 <em>jQuery</em> 的 <em>getScript</em>( ) 方法</li><li>使用 <em>setTimeout</em> 延迟方法</li><li>把 <em>JS</em> 外部引入的文件放到页面底部，来让 <em>JS</em> 最后引入</li></ul></blockquote><h3 id="129-说说严格模式的限制"><a href="#129-说说严格模式的限制" class="headerlink" title="129. 说说严格模式的限制"></a>129. 说说严格模式的限制</h3><blockquote><p>参考答案：</p><p>什么是严格模式？</p><p>严格模式对 <em>JavaScript</em> 的语法和行为都做了一些更改，消除了语言中一些不合理、不确定、不安全之处；提供高效严谨的差错机制，保证代码安全运行；禁用在未来版本中可能使用的语法，为新版本做好铺垫。在脚本文件第一行或函数内第一行中引入”use strict”这条指令，就能触发严格模式，这是一条没有副作用的指令，老版的浏览器会将其作为一行字符串直接忽略。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-string">&quot;use strict&quot;</span>;<span class="hljs-comment">//脚本第一行</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a,b</span>)&#123;<br><span class="hljs-string">&quot;use strict&quot;</span>;<span class="hljs-comment">//函数内第一行</span><br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入严格模式后的限制</p><ul><li>变量必须声明后再赋值</li><li>不能有重复的参数名，函数的参数也不能有同名属性</li><li>不能使用<em>with</em>语句</li><li>不能对只读属性赋值</li><li>不能使用前缀 <em>0</em>表示八进制数</li><li>不能删除不可删除的属性</li><li><em>eval</em> 不会在它的外层作用域引入变量。</li><li><em>eval</em>和<em>arguments</em>不能被重新赋值</li><li><em>arguments</em> 不会自动反应函数的变化</li><li>不能使用 <em>arguments.callee</em></li><li>不能使用 <em>arguments.caller</em></li><li>禁止 <em>this</em> 指向全局对象</li><li>不能使用 <em>fn.caller</em> 和 <em>fn.arguments</em> 获取函数调用的堆栈</li><li>增加了保留字</li></ul></blockquote><h3 id="130-attribute-和-property-的区别是什么？"><a href="#130-attribute-和-property-的区别是什么？" class="headerlink" title="130. attribute 和 property 的区别是什么？"></a>130. <em>attribute</em> 和 <em>property</em> 的区别是什么？</h3><blockquote><p>参考答案：</p><p>property 和 attribute 非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。</p><ul><li>property是DOM中的属性，是JavaScript里的对象；</li><li>attribute是HTML标签上的特性，它的值只能够是字符串；</li></ul><p>简单理解，Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等。</p><p>而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p></blockquote><h3 id="131-ES6-能写-class-么，为什么会出现-class-这种东西"><a href="#131-ES6-能写-class-么，为什么会出现-class-这种东西" class="headerlink" title="131. ES6 能写 class 么，为什么会出现 class 这种东西?"></a>131. <em>ES6</em> 能写 <em>class</em> 么，为什么会出现 <em>class</em> 这种东西?</h3><blockquote><p>参考答案：</p><p>在 <em>ES6</em> 中，可以书写 <em>class</em>。因为在 <em>ES6</em> 规范中，引入了 <em>class</em> 的概念。使得 <em>JS</em> 开发者终于告别了直接使用原型对象模仿面向对象中的类和类继承时代。</p><p>但是 <em>JS</em> 中并没有一个真正的 <em>class</em> 原始类型， <em>class</em> 仅仅只是对原型对象运用语法糖。</p><p>之所以出现 <em>class</em> 关键字，是为了使 <em>JS</em> 更像面向对象，所以 <em>ES6</em> 才引入 <em>class</em> 的概念。</p></blockquote><h3 id="132-常见兼容性问题"><a href="#132-常见兼容性问题" class="headerlink" title="132. 常见兼容性问题"></a>132. 常见兼容性问题</h3><blockquote><p>参考答案：</p><p>常见的兼容性问题很多，这里列举一些：</p><ol><li>关于获取行外样式 <em>currentStyle</em> 和 <em>getComputedStyle</em> 出现的兼容问题</li></ol><p>我们都知道 <em>JS</em> 通过 <em>style</em> 不可以获取行外样式，如果我们需要获取行外样式就会使用这两种</p><ul><li>IE 下：<em>currentStyle</em></li><li>chrome、FF 下：<em>getComputedStyle</em> 第二个参数的作用是获取伪类元素的属性值</li></ul><ol><li>关于“索引”获取字符串每一项出现的兼容性的问题</li></ol><p>对于字符串也有类似于数组这样通过下标索引获取每一项的值</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">str</span> = <span class="hljs-string">&#x27;abcd&#x27;</span><span class="hljs-comment">;</span><br>console.log(str<span class="hljs-section">[2]</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但是低版本的浏览器 <em>IE6、7</em> 不兼容</p><ol><li>关于使用 <em>firstChild、lastChild</em> 等，获取第一个&#x2F;最后一个元素节点是产生的问题</li></ol><ul><li>IE6-8下： <em>firstChild,lastChild,nextSibling,previousSibling</em> 获取第一个元素节点</li><li>高版本浏览器IE9+、FF、Chrome：获取的空白文本节点</li></ul><ol><li>关于使用 <em>event</em> 对象，出现兼容性问题</li></ol><p>在 <em>IE8</em> 及之前的版本浏览器中，<em>event</em> 事件对象是作为 <em>window</em> 对象的一个属性。</p><p>所以兼容的写法如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">vbnet复制代码<span class="hljs-keyword">function</span>(<span class="hljs-keyword">event</span>)&#123;<br>    <span class="hljs-keyword">event</span> = <span class="hljs-keyword">event</span> || window.<span class="hljs-keyword">event</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>关于事件绑定的兼容性问题</li></ol><ul><li><em>IE8</em> 以下用: attachEvent(‘事件名’,fn);</li><li><em>FF、Chrome、IE9-10</em> 用: attachEventLister(‘事件名’,fn,false);</li></ul><ol><li>关于获取滚动条距离而出现的问题</li></ol><p>当我们获取滚动条滚动距离时:</p><ul><li><em>IE、Chrome: document.body.scrollTop</em></li><li><em>FF: document.documentElement.scrollTop</em></li></ul><p>兼容处理:</p><p><em>var scrollTop &#x3D; document.documentElement.scrollTop||document.body.scrollTop</em></p></blockquote><h3 id="133-函数防抖节流的原理"><a href="#133-函数防抖节流的原理" class="headerlink" title="133. 函数防抖节流的原理"></a>133. 函数防抖节流的原理</h3><blockquote><p>参考答案：</p><p>请参阅前面第 <em>49、106</em> 题。</p></blockquote><h3 id="134-原始类型有哪几种？null-是对象吗？"><a href="#134-原始类型有哪几种？null-是对象吗？" class="headerlink" title="134. 原始类型有哪几种？null 是对象吗？"></a>134. 原始类型有哪几种？<em>null</em> 是对象吗？</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p><p>基本数据类型，一共有 <em>6</em> 种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript">typescript<br>复制代码<span class="hljs-built_in">string</span>，<span class="hljs-built_in">symbol</span>，<span class="hljs-built_in">number</span>，<span class="hljs-built_in">boolean</span>，<span class="hljs-literal">undefined</span>，<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p><p>引用数据类型，就只有 <em>1</em> 种：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp<br>复制代码<span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p><p>关于原始类型和引用类型的区别，可以参阅第 <em>26</em> 题。</p><p><em>null</em> 表示空，但是当我们使用 <em>typeof</em> 来进行数据类型检测的时候，得到的值是 <em>object</em>。</p><p>具体原因可以参阅前面第 <em>68</em> 题。</p></blockquote><h3 id="135-为什么-console-log-0-2-0-1-x3D-x3D-0-3-x2F-x2F-false"><a href="#135-为什么-console-log-0-2-0-1-x3D-x3D-0-3-x2F-x2F-false" class="headerlink" title="135. 为什么 console.log(0.2+0.1&#x3D;&#x3D;0.3) &#x2F;&#x2F; false"></a>135. 为什么 <em>console.log(0.2+0.1&#x3D;&#x3D;0.3) &#x2F;&#x2F; false</em></h3><blockquote><p>参考答案：</p><p>因为浮点数的计算存在 <em>round-off</em> 问题，也就是浮点数不能够进行精确的计算。并且：</p><ul><li>不仅 <em>JavaScript</em>，所有遵循 <em>IEEE 754</em> 规范的语言都是如此；</li><li>在 <em>JavaScript</em> 中，所有的 <em>Number</em> 都是以 <em>64-bit</em> 的双精度浮点数存储的；</li><li>双精度的浮点数在这 <em>64</em> 位上划分为 <em>3</em> 段，而这 <em>3</em> 段也就确定了一个浮点数的值，<em>64bit</em> 的划分是“<em>1-11-52</em>”的模式，具体来说：<ul><li>就是 <em>1</em> 位最高位（最左边那一位）表示符号位，<em>0</em> 表示正，<em>1</em> 表示负；</li><li><em>11</em> 位表示指数部分；</li><li><em>52</em> 位表示尾数部分，也就是有效域部分</li></ul></li></ul></blockquote><h3 id="136-说一下-JS-中类型转换的规则？"><a href="#136-说一下-JS-中类型转换的规则？" class="headerlink" title="136. 说一下 JS 中类型转换的规则？"></a>136. 说一下 <em>JS</em> 中类型转换的规则？</h3><blockquote><p>参考答案：</p><p>类型转换可以分为两种，<strong>隐性转换</strong>和<strong>显性转换</strong>。</p><p><strong>1. 隐性转换</strong></p><p>当不同数据类型之间进行相互运算，或者当对非布尔类型的数据求布尔值的时候，会发生隐性转换。</p><p>预期为数字的时候：算术运算的时候，我们的结果和运算的数都是数字，数据会转换为数字来进行计算。</p><table><thead><tr><th>类型</th><th>转换前</th><th>转换后</th></tr></thead><tbody><tr><td>number</td><td>4</td><td>4</td></tr><tr><td>string</td><td>“1”</td><td>1</td></tr><tr><td>string</td><td>“abc”</td><td>NaN</td></tr><tr><td>string</td><td>“”</td><td>0</td></tr><tr><td>boolean</td><td>true</td><td>1</td></tr><tr><td>boolean</td><td>false</td><td>0</td></tr><tr><td>undefined</td><td>undefined</td><td>NaN</td></tr><tr><td>null</td><td>null</td><td>0</td></tr></tbody></table><p>预期为字符串的时候：如果有一个操作数为字符串时，使用<code>+</code>符号做相加运算时，会自动转换为字符串。</p><p>预期为布尔的时候：前面在介绍布尔类型时所提到的 9 个值会转为 false，其余转为 true</p><p><strong>2. 显性转换</strong></p><p>所谓显性转换，就是只程序员强制将一种类型转换为另外一种类型。显性转换往往会使用到一些转换方法。常见的转换方法如下：</p><ul><li>转换为数值类型：<code>Number()</code>，<code>parseInt()</code>，<code>parseFloat()</code></li><li>转换为布尔类型：<code>Boolean()</code></li><li>转换为字符串类型：<code>toString()</code>，<code>String()</code></li></ul><p>当然，除了使用上面的转换方法，我们也可以通过一些快捷方式来进行数据类型的显性转换，如下：</p><ul><li>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></li><li>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></li><li>转换数值：数据*1 或 &#x2F;1，例如：<code>&quot;Hello * 1&quot;</code></li></ul></blockquote><h3 id="137-深拷贝和浅拷贝的区别？如何实现"><a href="#137-深拷贝和浅拷贝的区别？如何实现" class="headerlink" title="137. 深拷贝和浅拷贝的区别？如何实现"></a>137. 深拷贝和浅拷贝的区别？如何实现</h3><blockquote><p>参考答案：</p><ul><li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p></li><li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p></li></ul><p><strong>浅拷贝方法</strong></p><ol><li>直接赋值</li><li><em>Object.assign</em> 方法：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。当拷贝的 <em>object</em> 只有一层的时候，是深拷贝，但是当拷贝的对象属性值又是一个引用时，换句话说有多层时，就是一个浅拷贝。</li><li><em>ES6</em> 扩展运算符，当 <em>object</em> 只有一层的时候，也是深拷贝。有多层时是浅拷贝。</li><li><em>Array.prototype.concat</em> 方法</li><li><em>Array.prototype.slice</em> 方法</li><li><em>jQuery</em> 中的 <em>.extend</em>：在 <em>jQuery</em> 中，*.extend∗：在∗jQuery∗中，∗.extend(deep,target,object1,objectN)*  方法可以进行深浅拷贝。<em>deep</em> 如过设为 <em>true</em> 为深拷贝，默认是 <em>false</em> 浅拷贝。</li></ol><p><strong>深拷贝方法</strong></p><ol><li><em>$.extend(deep,target,object1,objectN)</em> ，将 <em>deep</em> 设置为 <em>true</em></li><li><em>JSON.parse(JSON.stringify)</em> ：用 <em>JSON.stringify</em> 将对象转成 <em>JSON</em> 字符串，再用 <em>JSON.parse</em> 方法把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</li><li>手写递归</li></ol><p>示例代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码function <span class="hljs-built_in">deepCopy</span>(oldObj, newobj) &#123;<br>    for (var key in oldObj) &#123;<br>        <span class="hljs-selector-tag">var</span> item = oldObj<span class="hljs-selector-attr">[key]</span>;<br>        <span class="hljs-comment">// 判断是否是对象</span><br>        if (item instanceof Object) &#123;<br>            if (item instanceof Function) &#123;<br>                newobj<span class="hljs-selector-attr">[key]</span> = oldObj<span class="hljs-selector-attr">[key]</span>;<br>            &#125; else &#123;<br>                newobj<span class="hljs-selector-attr">[key]</span> = &#123;&#125;;  <span class="hljs-comment">//定义一个空的对象来接收拷贝的内容</span><br>                <span class="hljs-built_in">deepCopy</span>(item, newobj[key]); <span class="hljs-comment">//递归调用</span><br>            &#125;<br><br>            <span class="hljs-comment">// 判断是否是数组</span><br>        &#125; else if (item instanceof Array) &#123;<br>            newobj<span class="hljs-selector-attr">[key]</span> = <span class="hljs-selector-attr">[]</span>;  <span class="hljs-comment">//定义一个空的数组来接收拷贝的内容</span><br>            <span class="hljs-built_in">deepCopy</span>(item, newobj[key]); <span class="hljs-comment">//递归调用</span><br>        &#125; else &#123;<br>            newobj<span class="hljs-selector-attr">[key]</span> = oldObj<span class="hljs-selector-attr">[key]</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="140-为什么会出现-setTimeout-倒计时误差？如何减少"><a href="#140-为什么会出现-setTimeout-倒计时误差？如何减少" class="headerlink" title="140. 为什么会出现 setTimeout 倒计时误差？如何减少"></a>140. 为什么会出现 <em>setTimeout</em> 倒计时误差？如何减少</h3><blockquote><p>参考答案：</p><p>定时器是属于宏任务(<em>macrotask</em>) 。如果当前执行栈所花费的时间大于定时器时间，那么定时器的回调在宏任务(<em>macrotask</em>) 里，来不及去调用，所有这个时间会有误差。</p></blockquote><h3 id="141-谈谈你对-JS-执行上下文栈和作用域链的理解"><a href="#141-谈谈你对-JS-执行上下文栈和作用域链的理解" class="headerlink" title="141. 谈谈你对 JS 执行上下文栈和作用域链的理解"></a>141. 谈谈你对 <em>JS</em> 执行上下文栈和作用域链的理解</h3><blockquote><p>参考答案：</p><p><strong>什么是执行上下文？</strong></p><p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><p><strong>执行上下文的类型</strong></p><p>JavaScript 中有三种执行上下文类型。</p><ul><li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文。</li></ul><p><strong>调用栈</strong></p><p>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）</p><ul><li>当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。</li><li>任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。</li><li>当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。</li><li>如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。</li></ul><p><strong>作用域链</strong></p><p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p></blockquote><h3 id="142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？"><a href="#142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="142. new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？"></a>142. <em>new</em> 的原理是什么？通过 <em>new</em> 的方式创建对象和通过字面量创建有什么区别？</h3><blockquote><p>参考答案：</p><p>关于 <em>new</em> 的原理，主要分为以下几步：</p><ul><li>创建一个空对象 。</li><li>由 <em>this</em> 变量引用该对象 。</li><li>该对象继承该函数的原型(更改原型链的指向) 。</li><li>把属性和方法加入到 <em>this</em> 引用的对象中。</li><li>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em>，过程如下：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">obj</span> = &#123;&#125;<span class="hljs-comment">;</span><br><span class="hljs-attr">obj.__proto__</span> = Base.prototype<span class="hljs-comment">;</span><br>Base.call(obj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>通过 <em>new</em> 的方式创建对象和通过字面量创建的对象，区别在于 <em>new</em> 出来的对象的原型对象为<code>构造函数.prototype</code>，而字面量对象的原型对象为 <code>Object.prototype</code></p><p>示例代码如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function Computer() &#123;&#125;<br>var <span class="hljs-attr">c</span> = new Computer()<span class="hljs-comment">;</span><br>var <span class="hljs-attr">d</span> = &#123;&#125;<span class="hljs-comment">;</span><br>console.log(<span class="hljs-attr">c.__proto__</span> === Computer.prototype)<span class="hljs-comment">; // true</span><br>console.log(<span class="hljs-attr">d.__proto__</span> === Object.prototype)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="143-prototype-和-proto-区别是什么？"><a href="#143-prototype-和-proto-区别是什么？" class="headerlink" title="143. prototype 和 *proto* 区别是什么？"></a>143. <em>prototype</em> 和 *<strong>proto*</strong> 区别是什么？</h3><blockquote><p>参考答案：</p><p><em>prototype</em> 是构造函数上面的一个属性，指向实例化出来对象的原型对象。</p><p>*<strong>proto*</strong> 是对象上面的一个隐式属性，指向自己的原型对象。</p></blockquote><h3 id="145-取数组的最大值（ES5、ES6）"><a href="#145-取数组的最大值（ES5、ES6）" class="headerlink" title="145. 取数组的最大值（ES5、ES6）"></a>145. 取数组的最大值（<em>ES5、ES6</em>）</h3><blockquote><p>参考答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];<br><span class="hljs-comment">// ES5 方式</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, arr)); <span class="hljs-comment">// 8</span><br><span class="hljs-comment">// ES6 方式</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr)); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="147-Promise-有几种状态-Promise-有什么优缺点"><a href="#147-Promise-有几种状态-Promise-有什么优缺点" class="headerlink" title="147. Promise 有几种状态, Promise 有什么优缺点 ?"></a>147. <em>Promise</em> 有几种状态, <em>Promise</em> 有什么优缺点 ?</h3><blockquote><p>参考答案：</p><p><em>Promise</em> 有三种状态：</p><p><em>pending、fulfilled、rejected</em>(未决定，履行，拒绝)，同一时间只能存在一种状态，且状态一旦改变就不能再变。<em>Promise</em> 是一个构造函数，<em>promise</em> 对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。</p><ul><li>初始化状态：<em>pending</em></li><li>当调用 <em>resolve</em>(成功) 状态：<em>pengding&#x3D;&gt;fulfilled</em></li><li>当调用 <em>reject</em>(失败) 状态：<em>pending&#x3D;&gt;rejected</em></li></ul><p><em>Promise</em> 的优点是解决了回调地狱，缺点是代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。所以后面出现了 <em>async&#x2F;await</em> 的异步解决方案。</p></blockquote><h3 id="148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理"><a href="#148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理" class="headerlink" title="148. Promise 构造函数是同步还是异步执行，then 呢 ? Promise 如何实现 then 处理 ?"></a>148. <em>Promise</em> 构造函数是同步还是异步执行，<em>then</em> 呢 ? <em>Promise</em> 如何实现 <em>then</em> 处理 ?</h3><blockquote><p>参考答案：</p><p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p><p>接下来我们来看 <em>promise</em> 如何实现 <em>then</em> 的处理。</p><p>我们知道 <em>then</em> 是用来处理 <em>resolve</em> 和 <em>reject</em> 函数的回调。那么首先我们来定义 <em>then</em> 方法。</p><h5 id="1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。"><a href="#1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。" class="headerlink" title="1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。"></a>1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br>复制代码<span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)&#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected"><a href="#2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected" class="headerlink" title="2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected"></a>2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-title class_">Promise</span>.<span class="hljs-property">FULFILLED</span>) &#123;<br>        <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-title class_">Promise</span>.<span class="hljs-property">REJECTED</span>) &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值"><a href="#3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值" class="headerlink" title="3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值"></a>3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> onFulfilled !==<span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        onFulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> onRejected  !==<span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        onRejected = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-title class_">Promise</span>.<span class="hljs-property">FULFILLED</span>)&#123;<br>         <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-title class_">Promise</span>.<span class="hljs-property">REJECTED</span>)&#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误"><a href="#4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误" class="headerlink" title="4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误"></a>4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">then</span>(onFulfilled,onRejected)&#123;<br><span class="hljs-built_in">if</span>(typeof onFulfilled !==&#x27;function&#x27;)&#123;<br>        onFulfilled = value =&gt; value;<br>    &#125;   <br>    <span class="hljs-built_in">if</span>(typeof onRejected  !==&#x27;function&#x27;)&#123;<br>        onRejected = value =&gt; value;<br>    &#125;<br>    <span class="hljs-built_in">if</span>(this.status == Promise.FULFILLED)&#123;<br>        try&#123;<span class="hljs-built_in">onFulfilled</span>(this.value)&#125;<span class="hljs-built_in">catch</span>(error)&#123; <span class="hljs-built_in">onRejected</span>(error) &#125;<br>    &#125;<br>    <span class="hljs-built_in">if</span>(this.status == Promise.REJECTED)&#123;<br>        try&#123;<span class="hljs-built_in">onRejected</span>(this.value)&#125;<span class="hljs-built_in">catch</span>(error)&#123; <span class="hljs-built_in">onRejected</span>(error) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。"><a href="#5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。" class="headerlink" title="5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。"></a>5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">if</span>(this.status=Promise.FULFILLED)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(()=&gt;&#123;<br>        try&#123;<span class="hljs-built_in">onFulfilled</span>(this.value)&#125;<span class="hljs-built_in">catch</span>(error)&#123;<span class="hljs-built_in">onRejected</span>(error)&#125;<br>    &#125;)<br>&#125;<br><span class="hljs-built_in">if</span>(this.status=Promise.REJECTED)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(()=&gt;&#123;<br>        try&#123;<span class="hljs-built_in">onRejected</span>(this.value)&#125;<span class="hljs-built_in">catch</span>(error)&#123;<span class="hljs-built_in">onRejected</span>(error)&#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。"><a href="#现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。" class="headerlink" title="现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。"></a>现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。</h5><h5 id="6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用"><a href="#6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用" class="headerlink" title="6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用"></a>6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码constructor(executor) &#123;<br>...<br>  <span class="hljs-attr">this.callbacks</span> = []<span class="hljs-comment">;</span><br>  ...<br>&#125;    <br></code></pre></td></tr></table></figure><h5 id="7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。"><a href="#7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。" class="headerlink" title="7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。"></a>7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">then</span>(onFulfilled,onRejected)&#123;<br>    ...<br>    <span class="hljs-built_in">if</span>(this.status==Promise.PENDING)&#123;<br>        this<span class="hljs-selector-class">.callbacks</span><span class="hljs-selector-class">.push</span>(&#123;<br>            onFulfilled:value=&gt;&#123;<br>                try &#123;<br>                  onFulfilled(value);<br>                &#125; catch (error) &#123;<br>                  <span class="hljs-built_in">onRejected</span>(error);<br>                &#125;<br>            &#125;<br>            onRejected: value =&gt; &#123;<br>            try &#123;<br>              <span class="hljs-built_in">onRejected</span>(value);<br>            &#125; catch (error) &#123;<br>              <span class="hljs-built_in">onRejected</span>(error);<br>            &#125;<br>          &#125;<br>        &#125;)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8、当执行resolve和reject时，在堆callacks数组中的函数进行执行"><a href="#8、当执行resolve和reject时，在堆callacks数组中的函数进行执行" class="headerlink" title="8、当执行resolve和reject时，在堆callacks数组中的函数进行执行"></a>8、当执行resolve和reject时，在堆callacks数组中的函数进行执行</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码resolve(vale)&#123;<br>    if(<span class="hljs-attr">this.status</span>==Promise.PENDING)&#123;<br>        <span class="hljs-attr">this.status</span> = Promise.FULFILLED<span class="hljs-comment">;</span><br>        <span class="hljs-attr">this.value</span> = value<span class="hljs-comment">;</span><br>        this.callbacks.map(<span class="hljs-attr">callback</span> =&gt; &#123;<br>          callback.onFulfilled(value)<span class="hljs-comment">;</span><br>        &#125;)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br>reject(value)&#123;<br>    if(<span class="hljs-attr">this.status</span>==Promise.PENDING)&#123;<br>        <span class="hljs-attr">this.status</span> = Promise.REJECTED<span class="hljs-comment">;</span><br>        <span class="hljs-attr">this.value</span> = value<span class="hljs-comment">;</span><br>        this.callbacks.map(<span class="hljs-attr">callback</span> =&gt; &#123;<br>          callback.onRejected(value)<span class="hljs-comment">;</span><br>        &#125;)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务"><a href="#9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务" class="headerlink" title="9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务"></a>9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码resolve(value) &#123;<br>  if (<span class="hljs-attr">this.status</span> == Promise.PENDING) &#123;<br>   <span class="hljs-attr">this.status</span> = Promise.FULFILLED<span class="hljs-comment">;</span><br><span class="hljs-attr">this.value</span> = value<span class="hljs-comment">;</span><br>    setTimeout(() =&gt; &#123;<br>      this.callbacks.map(<span class="hljs-attr">callback</span> =&gt; &#123;<br>        callback.onFulfilled(value)<span class="hljs-comment">;</span><br>      &#125;)<span class="hljs-comment">;</span><br>    &#125;)<span class="hljs-comment">;</span><br>  &#125;<br>&#125;<br>reject(value) &#123;<br>  if (<span class="hljs-attr">this.status</span> == Promise.PENDING) &#123;<br>  <span class="hljs-attr">this.status</span> = Promise.REJECTED<span class="hljs-comment">;</span><br>    <span class="hljs-attr">this.value</span> = value<span class="hljs-comment">;</span><br>    setTimeout(() =&gt; &#123;<br>      this.callbacks.map(<span class="hljs-attr">callback</span> =&gt; &#123;<br>        callback.onRejected(value)<span class="hljs-comment">;</span><br>      &#125;)<span class="hljs-comment">;</span><br>    &#125;)<span class="hljs-comment">;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，promise的then方法的基本实现就结束了。</p></blockquote><h3 id="149-Promise-和-setTimeout-的区别"><a href="#149-Promise-和-setTimeout-的区别" class="headerlink" title="149. Promise 和 setTimeout 的区别 ?"></a>149. <em>Promise</em> 和 <em>setTimeout</em> 的区别 ?</h3><blockquote><p>参考答案：</p><p><em>JavaScript</em> 将异步任务分为 <em>MacroTask</em>（宏任务） 和 <em>MicroTask</em>（微任务），那么它们区别何在呢？</p><ol><li>依次执行同步代码直至执行完毕；</li><li>检查MacroTask 队列，若有触发的异步任务，则取第一个并调用其事件处理函数，然后跳至第三步，若没有需处理的异步任务，则直接跳至第三步；</li><li>检查MicroTask队列，然后执行所有已触发的异步任务，依次执行事件处理函数，直至执行完毕，然后跳至第二步，若没有需处理的异步任务中，则直接返回第二步，依次执行后续步骤；</li><li>最后返回第二步，继续检查MacroTask队列，依次执行后续步骤；</li><li>如此往复，若所有异步任务处理完成，则结束；</li></ol><p><em>Promise</em> 是一个微任务，主线程是一个宏任务，微任务队列会在宏任务后面执行</p><p><em>setTimeout</em> 返回的函数是一个新的宏任务，被放入到宏任务队列</p><p>所以 <em>Promise</em> 会先于新的宏任务执行</p></blockquote><h3 id="150-如何实现-Promise-all"><a href="#150-如何实现-Promise-all" class="headerlink" title="150. 如何实现 Promise.all ?"></a>150. 如何实现 <em>Promise.all</em> ?</h3><blockquote><p>参考答案：</p><p><code>Promise.all</code> 接收一个 <code>promise</code> 对象的数组作为参数，当这个数组里的所有 <code>promise</code> 对象全部变为<code>resolve</code>或 有 <code>reject</code> 状态出现的时候，它才会去调用 <code>.then</code> 方法,它们是并发执行的。</p><p>总结 <code>promise.all</code> 的特点</p><p>1、接收一个 <code>Promise</code> 实例的数组或具有 <code>Iterator</code> 接口的对象，</p><p>2、如果元素不是 <code>Promise</code> 对象，则使用 <code>Promise.resolve</code> 转成 <code>Promise</code> 对象</p><p>3、如果全部成功，状态变为 <code>resolved</code>，返回值将组成一个数组传给回调</p><p>4、只要有一个失败，状态就变为 <code>rejected</code>，返回值将直接传递给回调<br> <code>all()</code> 的返回值也是新的 <code>Promise</code> 对象</p><p>实现 <code>Promise.all</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isArray</span>(promises)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;arguments must be an array&#x27;</span>));<br>        &#125;<br>        <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">var</span> promiseNum = promises.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">var</span> resolvedValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseNum);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>            (<span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) &#123;<br>                <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>                    resolvedCounter++<br>                    resolvedValues[i] = value<br>                    <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(resolvedValues)<br>                    &#125;<br>                &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason)<br>                &#125;)<br>            &#125;)(i)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="151-如何实现-Promise-finally"><a href="#151-如何实现-Promise-finally" class="headerlink" title="151. 如何实现 Promise.finally ?"></a>151. 如何实现 <em>Promise.finally</em> ?</h3><blockquote><p>参考答案：</p><p><em>finally</em> 方法是 <em>ES2018</em> 的新特性</p><p><em>finally</em> 方法用于指定不管 <em>Promise</em> 对象最后状态如何，都会执行的操作，执行 <em>then</em> 和 <em>catch</em> 后，都会执行 <em>finally</em> 指定的回调函数。</p><p>方法一：借助 <em>promise.prototype.finally</em> 包</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">arduino<br>复制代码npm install promise-prototype-finally<br>ini复制代码<span class="hljs-type">const</span> promiseFinally = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;promise.prototype.finally&#x27;</span>);<br> <br><span class="hljs-comment">// 向 Promise.prototype 增加 finally()</span><br>promiseFinally.<span class="hljs-built_in">shim</span>();<br> <br><span class="hljs-comment">// 之后就可以按照上面的使用方法使用了</span><br></code></pre></td></tr></table></figure><p>方法二：实现 <em>Promise.finally</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">value</span>  =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> value),<br>    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h3 id="152-如何判断-img-加载完成"><a href="#152-如何判断-img-加载完成" class="headerlink" title="152. 如何判断 img 加载完成"></a>152. 如何判断 <em>img</em> 加载完成</h3><blockquote><p>参考答案：</p><ul><li>为 <em>img DOM</em> 节点绑定 <em>load</em> 事件</li><li><em>readystatechange</em> 事件：<em>readyState</em> 为 <em>complete</em> 和 <em>loaded</em> 则表明图片已经加载完毕。测试 <em>IE6-IE10</em> 支持该事件，其它浏览器不支持。</li><li><em>img</em> 的 <em>complete</em> 属性：轮询不断监测 <em>img</em> 的 <em>complete</em> 属性，如果为 <em>true</em> 则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持。</li></ul></blockquote><h3 id="153-如何阻止冒泡？"><a href="#153-如何阻止冒泡？" class="headerlink" title="153. 如何阻止冒泡？"></a>153. 如何阻止冒泡？</h3><blockquote><p>参考答案：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-comment">// 方法一：IE9+，其他主流浏览器</span><br><span class="hljs-keyword">event</span>.stopPropagation()<br><span class="hljs-comment">// 方法二：火狐未实现</span><br><span class="hljs-keyword">event</span>.cancelBubble = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="154-如何阻止默认事件？"><a href="#154-如何阻止默认事件？" class="headerlink" title="154. 如何阻止默认事件？"></a>154. 如何阻止默认事件？</h3><blockquote><p>参考答案：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-comment">// 方法一：全支持</span><br><span class="hljs-keyword">event</span>.preventDefault();<br><span class="hljs-comment">// 方法二：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</span><br><span class="hljs-keyword">event</span>.returnValue=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="155-如何用原生-js-给一个按钮绑定两个-onclick-事件？"><a href="#155-如何用原生-js-给一个按钮绑定两个-onclick-事件？" class="headerlink" title="155. 如何用原生 js 给一个按钮绑定两个 onclick 事件？"></a>155. 如何用原生 <em>js</em> 给一个按钮绑定两个 <em>onclick</em> 事件？</h3><blockquote><p>参考答案：</p><p>使用 <em>addEventListener</em> 方法来绑定事件，就可以绑定多个同种类型的事件。</p></blockquote><h3 id="156-拖拽会用到哪些事件"><a href="#156-拖拽会用到哪些事件" class="headerlink" title="156. 拖拽会用到哪些事件"></a>156. 拖拽会用到哪些事件</h3><blockquote><p>参考答案：</p><p>在以前，书写一个拖拽需要用到 <em>mousedown、mousemove、mouseup</em> 这 <em>3</em> 个事件。</p><p><em>HTML5</em> 推出后，新推出了一组拖拽相关的 <em>API</em>，涉及到的事件有 <em>dragstart、dragover、drop</em> 这 <em>3</em> 个事件。</p></blockquote><h3 id="157-document-write-和-innerHTML-的区别"><a href="#157-document-write-和-innerHTML-的区别" class="headerlink" title="157. document.write 和 innerHTML 的区别"></a>157. <em>document.write</em> 和 <em>innerHTML</em> 的区别</h3><blockquote><p>参考答案：</p><p><em>document.write</em> 是直接写入到页面的内容流，如果在写之前没有调用 <em>document.open</em>, 浏览器会自动调用 <em>open</em>。每次写完关闭之后重新调用该函数，会导致页面全部重绘。</p><p><em>innerHTML</em> 则是 <em>DOM</em> 页面元素的一个属性，代表该元素的 <em>html</em> 内容。你可以精确到某一个具体的元素来进行更改。如果想修改 <em>document</em> 的内容，则需要修改 <em>document.documentElement.innerElement</em>。</p><p><em>innerHTML</em> 很多情况下都优于 <em>document.write</em>，其原因在于不会导致页面全部重绘。</p></blockquote><h3 id="158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？"><a href="#158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？" class="headerlink" title="158. jQuery 的事件委托方法 bind 、live、delegate、one、on 之间有什么区别？"></a>158. <em>jQuery</em> 的事件委托方法 <em>bind 、live、delegate、one、on</em> 之间有什么区别？</h3><blockquote><p>参考答案：</p><p>这几个方法都可以实现事件处理。其中 <em>on</em> 集成了事件处理的所有功能，也是目前推荐使用的方法。</p><p><em>one</em> 是指添加的是一次性事件，意味着只要触发一次该事件，相应的处理方法执行后就自动被删除。</p><p><em>bind</em> 是较早版本的绑定事件的方法，现在已被 <em>on</em> 替代。</p><p><em>live</em> 和 <em>delegate</em> 主要用来做事件委托。<em>live</em> 的版本较早，现在已被废弃。<em>delegate</em> 目前仍然可用，不过也可用 <em>on</em> 来替代它。</p></blockquote><h3 id="159-document-ready-方法和-window-onload-有什么区别？"><a href="#159-document-ready-方法和-window-onload-有什么区别？" class="headerlink" title="159. $(document).ready 方法和 window.onload 有什么区别？"></a>159. <em>$(document).ready</em> 方法和 <em>window.onload</em> 有什么区别？</h3><blockquote><p>参考答案：</p><p>主要有两点区别：</p><ol><li>执行时机</li></ol><p><em>window.onload</em> 方法是在网页中的所有的元素（包括元素的所有关联文件）都完全加载到浏览器之后才执行。而通过 <em>jQuery</em> 中的<code>$(document).ready</code>方法注册的事件处理程序，只要在 <em>DOM</em> 完全就绪时，就可以调用了，比如一张图片只要<code>&lt;img&gt;</code>标签完成，不用等这个图片加载完成，就可以设置图片的宽高的属性或样式等。</p><p>其实从二者的英文字母可以大概理解上面的话，<em>onload</em> 即加载完成，<em>ready</em> 即 <em>DOM</em> 准备就绪。</p><ol><li>注册事件</li></ol><p><code>$(document).ready</code>方法可以多次使用而注册不同的事件处理程序，而 <em>window.onload</em> 一次只能保存对一个函数的引用，多次绑定函数只会覆盖前面的函数。</p></blockquote><h3 id="160-jquery-中-get-提交和-get-提交和-post-提交有区别吗？"><a href="#160-jquery-中-get-提交和-get-提交和-post-提交有区别吗？" class="headerlink" title="160. jquery 中.get()提交和.get()提交和.post()提交有区别吗？"></a>160. jquery 中.get()提交和.get()提交和.post()提交有区别吗？</h3><blockquote><p>参考答案：</p><p>相同点：都是异步请求的方式来获取服务端的数据</p><p>不同点：</p><ul><li>请求方式不同：<code>$.get()</code> 方法使用 <em>GET</em> 方法来进行异步请求的。<code>$.post()</code> 方法使用 <em>POST</em> 方法来进行异步请求的。</li><li>参数传递方式不同： <em>GET</em> 请求会将参数跟在 <em>URL</em> 后进行传递，而 <em>POST</em> 请求则是作为 <em>HTTP</em> 消息的实体内容发送给 <em>Web</em> 服务器 的，这种传递是对用户不可见的。</li><li>数据传输大小不同： <em>GET</em> 方式传输的数据大小不能超过 <em>2KB</em> 而 <em>POST</em> 要大的多</li><li>安全问题： <em>GET</em> 方式请求的数据会被浏览器缓存起来，因此有安全问题。</li></ul></blockquote><h3 id="161-await-async-如何实现-（阿里）"><a href="#161-await-async-如何实现-（阿里）" class="headerlink" title="161. await async 如何实现 （阿里）"></a>161. <em>await async</em> 如何实现 （阿里）</h3><blockquote><p>参考答案：</p><p>async 函数只是 promise 的语法糖，它的底层实际使用的是 generator，而 generator 又是基于 promise 的。实际上，在 babel 编译 async 函数的时候，也会转化成 generatora 函数，并使用自动执行器来执行它。</p><p>实现代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncToGenerator</span>(<span class="hljs-params">generatorFunc</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> gen = generatorFunc.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">key, arg</span>) &#123;<br>          <span class="hljs-keyword">let</span> generatorResult<br>          <span class="hljs-keyword">try</span> &#123;<br>            generatorResult = gen[key](arg)<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(error)<br>          &#125;<br>          <span class="hljs-keyword">const</span> &#123; value, done &#125; = generatorResult<br>          <span class="hljs-keyword">if</span> (done) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-title function_">step</span>(<span class="hljs-string">&#x27;next&#x27;</span>, val), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">step</span>(<span class="hljs-string">&#x27;throw&#x27;</span>, err))<br>          &#125;<br>        &#125;<br>        <span class="hljs-title function_">step</span>(<span class="hljs-string">&quot;next&quot;</span>)<br>      &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于代码的解析，可以参阅：*<a href="https://link.juejin.cn/?target=https://blog.csdn.net/xgangzai/article/details/106536325">blog.csdn.net&#x2F;xgangzai&#x2F;ar…</a>*</p></blockquote><h3 id="162-clientWidth-offsetWidth-scrollWidth-的区别"><a href="#162-clientWidth-offsetWidth-scrollWidth-的区别" class="headerlink" title="162. clientWidth,offsetWidth,scrollWidth 的区别"></a>162. <em>clientWidth,offsetWidth,scrollWidth</em> 的区别</h3><blockquote><p>参考答案：</p><p><em>clientWidth</em> &#x3D; <em>width</em>+左右 <em>padding</em></p><p><em>offsetWidth</em> &#x3D; <em>width</em> + 左右 <em>padding</em> + 左右 <em>boder</em></p><p><em>scrollWidth</em>：获取指定标签内容层的真实宽度(可视区域宽度+被隐藏区域宽度)。</p></blockquote><h3 id="163-产生一个不重复的随机数组"><a href="#163-产生一个不重复的随机数组" class="headerlink" title="163. 产生一个不重复的随机数组"></a>163. 产生一个不重复的随机数组</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 生成随机数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomNumBoth</span>(<span class="hljs-params">Min, Max</span>) &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Range</span> = <span class="hljs-title class_">Max</span> - <span class="hljs-title class_">Min</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Rand</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-title class_">Min</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Rand</span> * <span class="hljs-title class_">Range</span>); <span class="hljs-comment">//四舍五入</span><br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><span class="hljs-comment">// 生成数组</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomArr</span>(<span class="hljs-params">len, min, max</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((max - min) &lt; len) &#123; <span class="hljs-comment">//可生成数的范围小于数组长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> hash = [];<br><br>    <span class="hljs-keyword">while</span> (hash.<span class="hljs-property">length</span> &lt; len) &#123;<br>        <span class="hljs-keyword">var</span> num = <span class="hljs-title function_">randomNumBoth</span>(min, max);<br><br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">indexOf</span>(num) == -<span class="hljs-number">1</span>) &#123;<br>            hash.<span class="hljs-title function_">push</span>(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomArr</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们封装了一个 <em>randomArr</em> 方法来生成这个不重复的随机数组，该方法接收三个参数，<em>len、min</em> 和 <em>max</em>，分别表示数组的长度、最小值和最大值。<em>randomNumBoth</em> 方法用来生成随机数。</p></blockquote><h3 id="164-continue-和-break-的区别"><a href="#164-continue-和-break-的区别" class="headerlink" title="164. continue 和 break 的区别"></a>164. <em>continue</em> 和 <em>break</em> 的区别</h3><blockquote><p>参考答案：</p><ul><li><em>break</em>：用于永久终止循环。即不执行本次循环中 <em>break</em> 后面的语句，直接跳出循环。</li><li><em>continue</em>：用于终止本次循环。即本次循环中 <em>continue</em> 后面的代码不执行，进行下一次循环的入口判断。</li></ul></blockquote><h3 id="165-如何在-jquery-上扩展插件，以及内部原理（腾讯）"><a href="#165-如何在-jquery-上扩展插件，以及内部原理（腾讯）" class="headerlink" title="165. 如何在 jquery 上扩展插件，以及内部原理（腾讯）"></a>165. 如何在 <em>jquery</em> 上扩展插件，以及内部原理（腾讯）</h3><blockquote><p>参考答案：</p><p>通过 <em>$.extend(object);</em>  为整个 <em>jQuery</em> 类添加新的方法。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码$.<span class="hljs-title function_">extend</span>(&#123;<br>   <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello,&#x27;</span> + (name ? name : <span class="hljs-string">&#x27;World&#x27;</span>) + <span class="hljs-string">&#x27;!&#x27;</span>);<br>     &#125;,<br>     <span class="hljs-title function_">showAge</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">18</span>);<br>     &#125;<br>&#125;)<br><br><span class="hljs-comment">// 外部使用</span><br>$.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello,World!  无参调用</span><br>$.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>); <span class="hljs-comment">// Hello,zhangsan! 带参调用  </span><br></code></pre></td></tr></table></figure><p>通过 <em>$.fn.extend(object);</em>  给 <em>jQuery</em> 对象添加方法。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码$.fn.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">swiper</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Swiper</span>(options, <span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 实例化 Swiper 对象</span><br>        obj.<span class="hljs-title function_">init</span>(); <span class="hljs-comment">// 调用对象的 init 方法</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 外部使用</span><br>$(<span class="hljs-string">&#x27;#id&#x27;</span>).<span class="hljs-title function_">swiper</span>();<br></code></pre></td></tr></table></figure><p>*<strong>extend* 方法内部原理</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码jQuery<span class="hljs-selector-class">.extend</span>( target <span class="hljs-selector-attr">[, object1 ]</span> <span class="hljs-selector-attr">[, objectN ]</span> )<br></code></pre></td></tr></table></figure><p>对后一个参数进行循环，然后把后面参数上所有的字段都给了第一个字段，若第一个参数里有相同的字段，则进行覆盖操作，否则就添加一个新的字段。</p><p>解析如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-comment">// 为与源码的下标对应上，我们把第一个参数称为第0个参数，依次类推</span><br>jQuery<span class="hljs-selector-class">.extend</span> = jQuery<span class="hljs-selector-class">.fn</span><span class="hljs-selector-class">.extend</span> = <span class="hljs-built_in">function</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> options, name, <span class="hljs-attribute">src</span>, copy, copyIsArray, clone,<br>        target = arguments<span class="hljs-selector-attr">[0]</span> || &#123;&#125;, <span class="hljs-comment">// 默认第0个参数为目标参数</span><br>        <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span>,    <span class="hljs-comment">// i表示从第几个参数凯斯想目标参数进行合并，默认从第1个参数开始向第0个参数进行合并</span><br>        length = arguments<span class="hljs-selector-class">.length</span>,<br>        deep = false;  <span class="hljs-comment">// 默认为浅度拷贝</span><br><br>    <span class="hljs-comment">// 判断第0个参数的类型，若第0个参数是boolean类型，则获取其为true还是false</span><br>    <span class="hljs-comment">// 同时将第1个参数作为目标参数，i从当前目标参数的下一个</span><br>    <span class="hljs-comment">// Handle a deep copy situation</span><br>    if ( typeof target === &quot;boolean&quot; ) &#123;<br>        deep = target;<br><br>        <span class="hljs-comment">// Skip the boolean and the target</span><br>        target = arguments<span class="hljs-selector-attr">[ i ]</span> || &#123;&#125;;<br>        <span class="hljs-selector-tag">i</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">//  判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值 </span><br>    <span class="hljs-comment">// Handle case when target is a string or something (possible in deep copy)</span><br>    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123;<br>        target = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 若目标参数后面没有参数了，如$.extend(&#123;_name:&#x27;wenzi&#x27;&#125;), $.extend(true, &#123;_name:&#x27;wenzi&#x27;&#125;)</span><br>    <span class="hljs-comment">// 则目标参数即为jQuery本身，而target表示的参数不再为目标参数</span><br>    <span class="hljs-comment">// Extend jQuery itself if only one argument is passed</span><br>    if ( i === length ) &#123;<br>        target = this;<br>        <span class="hljs-selector-tag">i</span>--;<br>    &#125;<br><br>    <span class="hljs-comment">// 从第i个参数开始</span><br>    for ( ; i &lt; length; i++ ) &#123;<br>        <span class="hljs-comment">// 获取第i个参数，且该参数不为null，</span><br>        <span class="hljs-comment">// 比如$.extend(target, &#123;&#125;, null);中的第2个参数null是不参与合并的</span><br>        <span class="hljs-comment">// Only deal with non-null/undefined values</span><br>        if ( (options = arguments[ i ]) != null ) &#123;<br><br>            <span class="hljs-comment">// 使用for~in获取该参数中所有的字段</span><br>            <span class="hljs-comment">// Extend the base object</span><br>            for ( name in options ) &#123;<br>                <span class="hljs-attribute">src</span> = target<span class="hljs-selector-attr">[ name ]</span>;   <span class="hljs-comment">// 目标参数中name字段的值</span><br>                copy = options<span class="hljs-selector-attr">[ name ]</span>; <span class="hljs-comment">// 当前参数中name字段的值</span><br><br>                <span class="hljs-comment">// 若参数中字段的值就是目标参数，停止赋值，进行下一个字段的赋值</span><br>                <span class="hljs-comment">// 这是为了防止无限的循环嵌套，我们把这个称为，在下面进行比较详细的讲解</span><br>                <span class="hljs-comment">// Prevent never-ending loop</span><br>                if ( target === copy ) &#123;<br>                    continue;<br>                &#125;<br><br>                <span class="hljs-comment">// 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深度赋值</span><br>                <span class="hljs-comment">// Recurse if we&#x27;re merging plain objects or arrays</span><br>                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;<br>                    <span class="hljs-comment">// 若当前参数中name字段的值为Array类型</span><br>                    <span class="hljs-comment">// 判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化</span><br>                    if ( copyIsArray ) &#123;<br>                        copyIsArray = false;<br>                        clone = <span class="hljs-attribute">src</span> &amp;&amp; jQuery<span class="hljs-selector-class">.isArray</span>(src) ? <span class="hljs-attribute">src</span> : [];<br><br>                    &#125; else &#123;<br>                        <span class="hljs-comment">// 若原对象存在，则直接进行使用，而不是创建</span><br>                        clone = <span class="hljs-attribute">src</span> &amp;&amp; jQuery<span class="hljs-selector-class">.isPlainObject</span>(src) ? <span class="hljs-attribute">src</span> : &#123;&#125;;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 递归处理，此处为2.2</span><br>                    <span class="hljs-comment">// Never move original objects, clone them                      </span><br>                    target<span class="hljs-selector-attr">[ name ]</span> = jQuery<span class="hljs-selector-class">.extend</span>( deep, clone, copy );<br><br>                <span class="hljs-comment">// deep为false，则表示浅度拷贝，直接进行赋值</span><br>                <span class="hljs-comment">// 若copy是简单的类型且存在值，则直接进行赋值</span><br>                <span class="hljs-comment">// Don&#x27;t bring in undefined values</span><br>                &#125; else if ( copy !== undefined ) &#123;<br>                    <span class="hljs-comment">// 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性</span><br>                    target<span class="hljs-selector-attr">[ name ]</span> = copy;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回修改后的目标参数</span><br>    <span class="hljs-comment">// Return the modified object</span><br>    return target;<br>&#125;; <br></code></pre></td></tr></table></figure></blockquote><h3 id="166-async-x2F-await-如何捕获错误"><a href="#166-async-x2F-await-如何捕获错误" class="headerlink" title="166. async&#x2F;await 如何捕获错误"></a>166. <em>async&#x2F;await</em> 如何捕获错误</h3><blockquote><p>参考答案：</p><p>可以使用 <em>try…catch</em> 来进行错误的捕获</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">test1</span>()<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="167-Proxy-对比-Object-defineProperty-的优势"><a href="#167-Proxy-对比-Object-defineProperty-的优势" class="headerlink" title="167. Proxy 对比 Object.defineProperty 的优势"></a>167. <em>Proxy</em> 对比 <em>Object.defineProperty</em> 的优势</h3><blockquote><p>参考答案：</p><p><strong>Proxy 的优势如下:</strong></p><ul><li><em>Object.defineProperty</em> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，而 <em>Proxy</em> 可以直接监听对象而非属性；</li><li><em>Object.defineProperty</em> 无法监控到数组下标的变化，而 <em>Proxy</em> 可以直接监听数组的变化；</li><li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法；</li><li><em>Proxy</em> 作为新标准将受到浏览器厂商重点持续的性能优化；</li></ul></blockquote><h3 id="168-原型链，可以改变原型链的规则吗"><a href="#168-原型链，可以改变原型链的规则吗" class="headerlink" title="168. 原型链，可以改变原型链的规则吗?"></a>168. 原型链，可以改变原型链的规则吗?</h3><blockquote><p>参考答案：</p><p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p><p>我们可以通过手动赋值的方式来改变原型链所对应的原型对象。</p></blockquote><h3 id="170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）"><a href="#170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）" class="headerlink" title="170. JS 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）"></a>170. <em>JS</em> 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）</h3><blockquote><p>参考答案：</p><p>关于 <em>JS</em> 基本数据类型有哪些这个问题，可以参阅前面 <em>26</em> 题。</p><p>栈和堆的区别在于堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。</p><p>在 <em>js</em> 中，基本数据都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p><p><em>js</em> 中其他类型的数据被称为引用类型的数据（如对象、数组、函数等），它们是通过拷贝和 <em>new</em> 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p></blockquote><h3 id="171-setTimeout-x3D-gt-0-什么时候执行"><a href="#171-setTimeout-x3D-gt-0-什么时候执行" class="headerlink" title="171. setTimeout(() &#x3D;&gt; {}, 0)  什么时候执行"></a>171. <em>setTimeout(() &#x3D;&gt; {}, 0)</em>  什么时候执行</h3><blockquote><p>参考答案：</p><p>因为 <em>setTimeout</em> 是异步代码，所以即使后面的时间为 <em>0</em>，也要等到同步代码执行完毕后才会执行。</p></blockquote><h3 id="172-js-有函数重载吗（网易）"><a href="#172-js-有函数重载吗（网易）" class="headerlink" title="172. js 有函数重载吗（网易）"></a>172. <em>js</em> 有函数重载吗（网易）</h3><blockquote><p>参考答案：</p><p>所谓函数重载，是方法名称进行重用的一种技术形式，其主要特点是“方法名相同，参数的类型或个数不相同”，在调用时会根据传递的参数类型和个数的不同来执行不同的方法体。</p><p>在 <em>JS</em> 中，可以通过在函数内容判断形参的类型或个数来执行不同的代码块，从而达到模拟函数重载的效果。</p></blockquote><h3 id="173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase"><a href="#173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase" class="headerlink" title="173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回 true 相反则返回的 flase"></a>173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回 <em>true</em> 相反则返回的 <em>flase</em></h3><blockquote><p>参考答案：</p><p>输入：arr &#x3D; [1,2,2,1,1,3]</p><p>输出：true</p><p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p><p>代码示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function uniqueOccurrences(arr) &#123;<br>    let <span class="hljs-attr">uniqueArr</span> = [...new Set(arr)]<br>    let <span class="hljs-attr">countArr</span> = []<br>    for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; uniqueArr.length; i++) &#123;</span><br>        countArr.push(arr.filter(<span class="hljs-attr">item</span> =&gt; item == uniqueArr[i]).length)<br>    &#125;<br>    return <span class="hljs-attr">countArr.length</span> == new Set(countArr).size<br>&#125;<span class="hljs-comment">;</span><br><br>// 测试<br>console.log(uniqueOccurrences(<span class="hljs-section">[1, 2, 2, 1, 1, 3]</span>))<span class="hljs-comment">; // true</span><br>console.log(uniqueOccurrences(<span class="hljs-section">[1, 2, 2, 1, 1, 3, 2]</span>))<span class="hljs-comment">; // false</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f"><a href="#174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f" class="headerlink" title="174. 封装一个能够统计重复的字符的函数，例如 aaabbbdddddfff 转化为 3a3b5d3f"></a>174. 封装一个能够统计重复的字符的函数，例如 <em>aaabbbdddddfff</em> 转化为 <em>3a3b5d3f</em></h3><blockquote><p>参考答案：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function compression(str) &#123;<br>    if (<span class="hljs-attr">str.length</span> == <span class="hljs-number">0</span>) &#123;<br>        return 0<span class="hljs-comment">;</span><br>    &#125;<br>    var <span class="hljs-attr">len</span> = str.length<span class="hljs-comment">;</span><br>    var <span class="hljs-attr">str2</span> = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">;</span><br>    var <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    var <span class="hljs-attr">num</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    while (i &lt; len) &#123;<br>        if (str.charAt(i) == str.charAt(i + 1)) &#123;<br>            num++<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            str2 += num<span class="hljs-comment">;</span><br>            str2 += str.charAt(i)<span class="hljs-comment">;</span><br>            <span class="hljs-attr">num</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>        &#125;<br>        i++<span class="hljs-comment">;</span><br>    &#125;<br>    return str2<span class="hljs-comment">;</span><br>&#125;<br>// 测试：<br>console.log(compression(&#x27;aaabbbdddddfff&#x27;))<span class="hljs-comment">; // 3a3b5d3f</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="175-写出代码的执行结果，并解释为什么？"><a href="#175-写出代码的执行结果，并解释为什么？" class="headerlink" title="175. 写出代码的执行结果，并解释为什么？"></a>175. 写出代码的执行结果，并解释为什么？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a); <br>    <span class="hljs-title function_">a</span>(); <br>&#125;)()<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>会报错，<em>a is not a function</em>。</p><p>因为立即执行函数里面有函数 <em>a</em>，<em>a</em> 会被提升到该函数作用域的最顶端，但是由于判断条件是 <em>false</em>，所以不会进入到条件语句里面， <em>a</em> 也就没有值。所以 <em>typeof</em> 打印出来是 <em>undefined</em>。而后面在尝试调用方法，自然就会报错。</p></blockquote><h3 id="176-写出代码的执行结果，并解释为什么？"><a href="#176-写出代码的执行结果，并解释为什么？" class="headerlink" title="176. 写出代码的执行结果，并解释为什么？"></a>176. 写出代码的执行结果，并解释为什么？</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码alert(a)<span class="hljs-comment">;</span><br>a()<span class="hljs-comment">;</span><br>var <span class="hljs-attr">a</span> = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>function a() &#123;<br>  alert(10)<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>alert(a)<span class="hljs-comment">;</span><br><span class="hljs-attr">a</span> = <span class="hljs-number">6</span><span class="hljs-comment">;</span><br>a()<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>首先打印 function a() {alert(10);};</p><p>然后打印 10</p><p>最后打印 3</p></blockquote><blockquote><p>解析：</p><p>首先 a 变量会被提升到该全局作用域的最顶端，然后值为对应的函数，所以第一次打印出来的是函数。</p><p>接下来调用这个 a 函数，所以打印出 10</p><p>最后给这个 a 赋值为 3，然后又 alert，所以打印出 3。</p><p>之后 a 的值还会发生改变，但是由于没有 alert，说明不会再打印出其他值了。</p></blockquote><h3 id="177-写出下面程序的打印顺序，并简要说明原因"><a href="#177-写出下面程序的打印顺序，并简要说明原因" class="headerlink" title="177. 写出下面程序的打印顺序，并简要说明原因"></a>177. 写出下面程序的打印顺序，并简要说明原因</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set1&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then4&quot;</span>);<br>        &#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then2&#x27;</span>);<br>    &#125;)<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;pr1&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then1&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set2&quot;</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then3&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>打印结果为：</p><p>pr1<br> 2<br> then1<br> then3<br> set1<br> then2<br> then4<br> set2</p></blockquote><h3 id="178-javascript-中什么是伪数组？如何将伪数组转换为标准数组"><a href="#178-javascript-中什么是伪数组？如何将伪数组转换为标准数组" class="headerlink" title="178. javascript 中什么是伪数组？如何将伪数组转换为标准数组"></a>178. <em>javascript</em> 中什么是伪数组？如何将伪数组转换为标准数组</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 中，<em>arguments</em> 就是一个伪数组对象。关于 <em>arguments</em> 具体可以参阅后面 <em>250</em> 题。</p><p>可以使用 <em>ES6</em> 的扩展运算符来将伪数组转换为标准数组</p><p>例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini<br>复制代码var <span class="hljs-attr">arr</span> = [...arguments]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="179-array-和-object-的区别"><a href="#179-array-和-object-的区别" class="headerlink" title="179. array 和 object 的区别"></a>179. <em>array</em> 和 <em>object</em> 的区别</h3><blockquote><p>参考答案：</p><p>数组表示有序数据的集合，对象表示无序数据的集合。如果数据顺序很重要的话，就用数组，否则就用对象。</p></blockquote><h3 id="180-jquery-事件委托"><a href="#180-jquery-事件委托" class="headerlink" title="180. jquery 事件委托"></a>180. <em>jquery</em> 事件委托</h3><blockquote><p>参考答案：</p><p>在 <em>jquery</em> 中使用 <em>on</em> 来绑定事件的时候，传入第二个参数即可。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码$(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-string">&quot;li&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2"><a href="#182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2" class="headerlink" title="182. 请实现一个模块 math，支持链式调用math.add(2,4).minus(3).times(2);"></a>182. 请实现一个模块 <em>math</em>，支持链式调用<code>math.add(2,4).minus(3).times(2);</code></h3><blockquote><p>参考答案：</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">let</span> hasInitValue = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span>) &#123;<br>            value = <span class="hljs-title class_">NaN</span>;<br>            hasInitValue = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(<span class="hljs-variable language_">this</span>, &#123;<br>            <span class="hljs-attr">value</span>: &#123;<br>                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">value</span>: value,<br>            &#125;,<br>            <span class="hljs-attr">hasInitValue</span>: &#123;<br>                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>                <span class="hljs-attr">value</span>: hasInitValue,<br>            &#125;,<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> init = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasInitValue</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> : args.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">const</span> value = args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pv, cv</span>) =&gt;</span> pv + cv, init);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>(value);<br>    &#125;<br><br>    <span class="hljs-title function_">minus</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> init = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasInitValue</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> : args.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">const</span> value = args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pv, cv</span>) =&gt;</span> pv - cv, init);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>(value);<br>    &#125;<br><br>    <span class="hljs-title function_">times</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> init = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasInitValue</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> : args.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">const</span> value = args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pv, cv</span>) =&gt;</span> pv * cv, init);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>(value);<br>    &#125;<br><br>    <span class="hljs-title function_">divide</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">const</span> init = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasInitValue</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> : args.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">const</span> value = args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pv, cv</span>) =&gt;</span> pv / cv, init);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>(value);<br>    &#125;<br><br>    <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>());<br>    &#125;<br><br>    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>        <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>        <span class="hljs-keyword">if</span> (hint === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>(value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>();<br></code></pre></td></tr></table></figure></blockquote><h3 id="183-请简述-ES6-代码转成-ES5-代码的实现思路。"><a href="#183-请简述-ES6-代码转成-ES5-代码的实现思路。" class="headerlink" title="183. 请简述 ES6 代码转成 ES5 代码的实现思路。"></a>183. 请简述 <em>ES6</em> 代码转成 <em>ES5</em> 代码的实现思路。</h3><blockquote><p>参考答案：</p><p>说到 <em>ES6</em> 代码转成 <em>ES5</em> 代码，我们肯定会想到 <em>Babel</em>。所以，我们可以参考 <em>Babel</em> 的实现方式。</p><p>那么 <em>Babel</em> 是如何把 <em>ES6</em> 转成 <em>ES5</em> 呢，其大致分为三步：</p><ul><li>将代码字符串解析成抽象语法树，即所谓的 <em>AST</em></li><li>对 <em>AST</em> 进行处理，在这个阶段可以对 <em>ES6</em> 代码进行相应转换，即转成 <em>ES5</em> 代码</li><li>根据处理后的 <em>AST</em> 再生成代码字符串</li></ul></blockquote><h3 id="184-下列代码的执行结果"><a href="#184-下列代码的执行结果" class="headerlink" title="184. 下列代码的执行结果"></a>184. 下列代码的执行结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>script start<br> async1 start<br> async2<br> promise1<br> script end<br> async1 end<br> promise2<br> setTimeout</p></blockquote><blockquote><p>解析：</p><p>在此之前我们需要知道以下几点：</p><ul><li>setTimeout 属于宏任务</li><li>Promise 本身是同步的立即执行函数，Promise.then 属于微任务</li><li>async 方法执行时，遇到 await 会立即执行表达式，表达式之后的代码放到微任务执行</li></ul><p><strong>第一次执行</strong>：执行同步代码</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">Tasks</span>(宏任务)：run script、 setTimeout callback<br><span class="hljs-built_in">Microtasks</span>(微任务)：await、Promise then<br>JS <span class="hljs-built_in">stack</span>(执行栈): script<br>Log: script start、async1 start、async2、promise1、script end<br></code></pre></td></tr></table></figure><p><strong>第二次执行</strong>：执行宏任务后，检测到<strong>微任务</strong>队列中不为空、一次性执行完所有微任务</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">Tasks</span>(宏任务)：run script、 setTimeout callback<br><span class="hljs-built_in">Microtasks</span>(微任务)：Promise then<br>JS <span class="hljs-built_in">stack</span>(执行栈): await<br>Log: script start、async1 start、async2、promise1、script end、async1 end、promise2<br></code></pre></td></tr></table></figure><p><strong>第三次执行</strong>：当<strong>微任务</strong>队列中为空时，执行<strong>宏任务</strong>，执行<code>setTimeout callback</code>，打印日志。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-built_in">Tasks</span>(宏任务)：null<br><span class="hljs-built_in">Microtasks</span>(微任务)：null<br>JS <span class="hljs-built_in">stack</span>(执行栈):setTimeout callback<br>Log: script start、async1 start、async2、promise1、script end、async1 end、promise2、setTimeout<br></code></pre></td></tr></table></figure></blockquote><h3 id="185-JS-有哪些内置对象？"><a href="#185-JS-有哪些内置对象？" class="headerlink" title="185. JS 有哪些内置对象？"></a>185. <em>JS</em> 有哪些内置对象？</h3><blockquote><p>参考答案：</p><p>数据封装类对象：<em>String，Boolean，Number，Array</em> 和 <em>Object</em></p><p>其他对象：<em>Function，Arguments，Math，Date，RegExp，Error</em></p></blockquote><h3 id="187-eval-是做什么的？"><a href="#187-eval-是做什么的？" class="headerlink" title="187. eval 是做什么的？"></a>187. <em>eval</em> 是做什么的？</h3><blockquote><p>参考答案：</p><p>此函数可以接受一个字符串 <em>str</em> 作为参数，并把此 <em>str</em> 当做一段 <em>javascript</em> 代码去执行，如果 <em>str</em> 执行结果是一个值则返回此值，否则返回 <em>undefined</em>。如果参数不是一个字符串，则直接返回该参数。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;var a=1&quot;</span>);<span class="hljs-comment">//声明一个变量a并赋值1。</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;2+3&quot;</span>);<span class="hljs-comment">//5执行加运算，并返回运算值。</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;mytest()&quot;</span>);<span class="hljs-comment">//执行mytest()函数。</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;&#123;b:2&#125;&quot;</span>);<span class="hljs-comment">//声明一个对象。</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="189-new-操作符具体干了什么呢？"><a href="#189-new-操作符具体干了什么呢？" class="headerlink" title="189. new 操作符具体干了什么呢？"></a>189. <em>new</em> 操作符具体干了什么呢？</h3><blockquote><p>参考答案：</p><ul><li>创建一个空对象 。</li><li>由 this 变量引用该对象 。</li><li>该对象继承该函数的原型(更改原型链的指向) 。</li><li>把属性和方法加入到 this 引用的对象中。</li><li>新创建的对象由 this 引用 ，最后隐式地返回 this，过程如下：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">obj</span> = &#123;&#125;<span class="hljs-comment">;</span><br><span class="hljs-attr">obj.__proto__</span> = Base.prototype<span class="hljs-comment">;</span><br>Base.call(obj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="190-去除字符串中的空格"><a href="#190-去除字符串中的空格" class="headerlink" title="190. 去除字符串中的空格"></a>190. 去除字符串中的空格</h3><blockquote><p>参考答案：</p><p>方法一：<em>replace</em>正则匹配方法</p><p>代码示例：</p><ul><li>去除字符串内所有的空格：<code>str = str.replace(/\s*/g,&quot;&quot;);</code></li><li>去除字符串内两头的空格：<code>str = str.replace(/^\s*|\s*$/g,&quot;&quot;);</code></li><li>去除字符串内左侧的空格：<code>str = str.replace(/^\s*/,&quot;&quot;);</code></li><li>去除字符串内右侧的空格：<code>str = str.replace(/(\s*$)/g,&quot;&quot;);</code></li></ul><p>方法二：字符串原生 <em>trim</em> 方法</p><p><em>trim</em> 方法能够去掉两侧空格返回新的字符串，不能去掉中间的空格</p></blockquote><h3 id="191-常见的内存泄露，以及解决方案"><a href="#191-常见的内存泄露，以及解决方案" class="headerlink" title="191. 常见的内存泄露，以及解决方案"></a>191. 常见的内存泄露，以及解决方案</h3><blockquote><p>参考答案：</p><p><strong>内存泄露概念</strong></p><p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>内存泄漏通常情况下只能由获得程序源代码和程序员才能分析出来。然而，有不少人习惯于把任何不需要的内存使用的增加描述为内存泄漏，即使严格意义上来说这是不准确的。</p><p>*<strong>JS* 垃圾收集机制</strong></p><p><em>JS</em> 具有自动回收垃圾的机制，即执行环境会负责管理程序执行中使用的内存。在C和C++等其他语言中，开发者的需要手动跟踪管理内存的使用情况。在编写 <em>JS</em> 代码的时候，开发人员不用再关心内存使用的问题，所需内存的分配 以及无用的回收完全实现了自动管理。</p><p>Js中最常用的垃圾收集方式是标记清除(mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。</p><p><strong>常见内存泄漏以及解决方案</strong></p><ol><li>意外的全局变量</li></ol><p>Js处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是window。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function foo(arg) &#123; <br>    <span class="hljs-attr">bar</span> = <span class="hljs-string">&quot;this is a hidden global variable&quot;</span><span class="hljs-comment">; //等同于window.bar=&quot;this is a hidden global variable&quot;</span><br>    <span class="hljs-attr">this.bar2</span>= <span class="hljs-string">&quot;potential accidental global&quot;</span><span class="hljs-comment">;//这里的this 指向了全局对象（window）,等同于window.bar2=&quot;potential accidental global&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法：在 JavaScript 程序中添加，开启严格模式’use strict’，可以有效地避免上述问题。</p><p>注意：那些用来临时存储大量数据的全局变量，确保在处理完这些数据后将其设置为null或重新赋值。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。</p><ol><li>循环引用</li></ol><p>在js的内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收 。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码let <span class="hljs-attr">obj1</span> = &#123; a: <span class="hljs-number">1</span> &#125;<span class="hljs-comment">; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1   </span><br>let <span class="hljs-attr">obj2</span> = obj1<span class="hljs-comment">; // A 的引用个数变为 2  </span><br><br><span class="hljs-attr">obj1</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // A 的引用个数变为 1  </span><br><span class="hljs-attr">obj2</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span><br></code></pre></td></tr></table></figure><p>但是引用计数有个最大的问题： 循环引用。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function func() &#123;  <br>    let <span class="hljs-attr">obj1</span> = &#123;&#125;<span class="hljs-comment">;  </span><br>    let <span class="hljs-attr">obj2</span> = &#123;&#125;<span class="hljs-comment">;  </span><br><br>    <span class="hljs-attr">obj1.a</span> = obj2<span class="hljs-comment">; // obj1 引用 obj2  </span><br>    <span class="hljs-attr">obj2.a</span> = obj1<span class="hljs-comment">; // obj2 引用 obj1  </span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码<span class="hljs-attr">obj1</span> = null<span class="hljs-comment">;  </span><br><span class="hljs-attr">obj2</span> = null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol><li>被遗忘的计时器和回调函数</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码let <span class="hljs-attr">someResource</span> = getData()<span class="hljs-comment">;  </span><br>setInterval(() =&gt; &#123;  <br>    const <span class="hljs-attr">node</span> = document.getElementById(<span class="hljs-string">&#x27;Node&#x27;</span>)<span class="hljs-comment">;  </span><br>    if(node) &#123;  <br>        <span class="hljs-attr">node.innerhtml</span> = JSON.stringify(someResource))<span class="hljs-comment">;  </span><br>    &#125;  <br>&#125;, 1000)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。</p><p>但在 <em>setInterval</em> 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？</p><p>就是调用了 <em>clearInterval</em>。如果回调函数内没有做什么事情，并且也没有被 <em>clear</em> 掉的话，就会造成内存泄漏。</p><p>不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，<em>someResource</em> 就没法被回收。同样的，<em>setTiemout</em> 也会有同样的问题。所以，当不需要 <em>interval</em> 或者 <em>timeout</em> 时，最好调用 <em>clearInterval</em> 或者 <em>clearTimeout</em>。</p><ol><li><em>DOM</em> 泄漏</li></ol><p>在 <em>JS</em> 中对<em>DOM</em>操作是非常耗时的。因为<em>JavaScript&#x2F;ECMAScript</em>引擎独立于渲染引擎，而<em>DOM</em>是位于渲染引擎，相互访问需要消耗一定的资源。 而 <em>IE</em> 的 <em>DOM</em> 回收机制便是采用引用计数的，以下主要针对 <em>IE</em> 而言的。</p><p><strong>a. 没有清理的 DOM 元素引用</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">refA</span> = document.getElementById(<span class="hljs-string">&#x27;refA&#x27;</span>)<span class="hljs-comment">;</span><br>document.body.removeChild(refA)<span class="hljs-comment">;</span><br>// refA 不能回收，因为存在变量 refA 对它的引用。将其对 refA 引用释放，但还是无法回收 refA。<br></code></pre></td></tr></table></figure><p>解决办法：<em>refA &#x3D; null;</em></p><p><strong>b. 给 DOM 对象添加的属性是一个对象的引用</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">MyObject</span> = &#123;&#125;<span class="hljs-comment">; </span><br>document.getElementById(&#x27;mydiv&#x27;).<span class="hljs-attr">myProp</span> = MyObject<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>解决方法：<br> 在 <em>window.onunload</em> 事件中写上: <em>document.getElementById(‘mydiv’).myProp &#x3D; null;</em></p><p><strong>c. DOM 对象与 JS 对象相互引用</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function Encapsulator(element) &#123; <br><span class="hljs-attr">this.elementReference</span> = element<span class="hljs-comment">; </span><br><span class="hljs-attr">element.myProp</span> = this<span class="hljs-comment">; </span><br>&#125; <br>new Encapsulator(document.getElementById(&#x27;myDiv&#x27;))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>解决方法： 在 onunload 事件中写上: document.getElementById(‘myDiv’).myProp &#x3D; null;</p><p><strong>d. 给 DOM 对象用 attachEvent 绑定事件</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp复制代码<span class="hljs-function">function <span class="hljs-title">doClick</span>()</span> &#123;&#125; <br>element.attachEvent(<span class="hljs-string">&quot;onclick&quot;</span>, doClick);<br></code></pre></td></tr></table></figure><p>解决方法： 在onunload事件中写上: element.detachEvent(‘onclick’, doClick);</p><p><strong>e. 从外到内执行 appendChild。这时即使调用 removeChild 也无法释放</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">parentDiv</span> = document.createElement(<span class="hljs-string">&quot;div&quot;</span>)<span class="hljs-comment">; </span><br>var <span class="hljs-attr">childDiv</span> = document.createElement(<span class="hljs-string">&quot;div&quot;</span>)<span class="hljs-comment">; </span><br>document.body.appendChild(parentDiv)<span class="hljs-comment">; </span><br>parentDiv.appendChild(childDiv)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>解决方法： 从内到外执行 appendChild:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码var <span class="hljs-attr">parentDiv</span> = document.createElement(<span class="hljs-string">&quot;div&quot;</span>)<span class="hljs-comment">; </span><br>var <span class="hljs-attr">childDiv</span> = document.createElement(<span class="hljs-string">&quot;div&quot;</span>)<span class="hljs-comment">; </span><br>parentDiv.appendChild(childDiv)<span class="hljs-comment">; </span><br>document.body.appendChild(parentDiv)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol><li><em>JS</em> 的闭包</li></ol><p>闭包在 <em>IE6</em> 下会造成内存泄漏，但是现在已经无须考虑了。值得注意的是闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏。闭包会造成对象引用的生命周期脱离当前函数的上下文，如果闭包如果使用不当，可以导致环形引用（<em>circular reference</em>），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露。</p><ol><li><em>console</em></li></ol><p>控制台日志记录对总体内存配置文件的影响可能是许多开发人员都未想到的极其重大的问题。记录错误的对象可以将大量数据保留在内存中。注意，这也适用于：</p><p>(1) 在用户键入 JavaScript 时，在控制台中的一个交互式会话期间记录的对象。<br> (2) 由 console.log 和 console.dir 方法记录的对象。</p></blockquote><h3 id="193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂"><a href="#193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂" class="headerlink" title="193. 设计⼀个⽅法(isPalindrom)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)"></a>193. 设计⼀个⽅法(<em>isPalindrom</em>)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) === str<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isPalindrome</span>(<span class="hljs-string">&#x27;HelleH&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isPalindrome</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符"><a href="#194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符" class="headerlink" title="194. 设计⼀个⽅法(findMaxDuplicateChar)以统计字符串中出现最多次数的字符"></a>194. 设计⼀个⽅法(<em>findMaxDuplicateChar</em>)以统计字符串中出现最多次数的字符</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function findMaxDuplicateChar(str) &#123;<br>    let <span class="hljs-attr">cnt</span> = &#123;&#125;,//用来记录所有的字符的出现频次<br>        <span class="hljs-attr">c</span> = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">;//用来记录最大频次的字符</span><br>    for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; str.length; i++) &#123;</span><br>        let <span class="hljs-attr">ci</span> = str[i]<span class="hljs-comment">;</span><br>        if (!cnt<span class="hljs-section">[ci]</span>) &#123;<br>            cnt<span class="hljs-section">[ci]</span> = 1<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            cnt<span class="hljs-section">[ci]</span>++<span class="hljs-comment">;</span><br>        &#125;<br>        if (<span class="hljs-attr">c</span> == <span class="hljs-string">&#x27;&#x27;</span> || cnt[ci] &gt; cnt[c]) &#123;<br>            <span class="hljs-attr">c</span> = ci<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>    console.log(cnt)<span class="hljs-comment">; // &#123; H: 1, e: 1, l: 3, o: 2, &#x27; &#x27;: 1, W: 1, r: 1, d: 1 &#125;</span><br>    return c<span class="hljs-comment">;</span><br>&#125;<br><br>// 测试<br>console.log(findMaxDuplicateChar(&#x27;Hello World&#x27;))<span class="hljs-comment">; // l</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值"><a href="#195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值" class="headerlink" title="195. 设计⼀段代码，使得通过点击按钮可以在 span 中显示⽂本框中输⼊的值"></a>195. 设计⼀段代码，使得通过点击按钮可以在 <em>span</em> 中显示⽂本框中输⼊的值</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">xml复制代码<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;showContent&quot;</span>&gt;</span>在右侧输入框中输入内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>更新内容<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;content&#x27;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(content)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;showContent&#x27;</span>).<span class="hljs-property">innerHTML</span> = content;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="196-map-和-forEach-的区别？"><a href="#196-map-和-forEach-的区别？" class="headerlink" title="196. map 和 forEach 的区别？"></a>196. <em>map</em> 和 <em>forEach</em> 的区别？</h3><blockquote><p>参考答案：</p><p><strong>两者区别</strong></p><p><code>forEach()</code>方法不会返回执行结果，而是<code>undefined</code>。</p><p>也就是说，<code>forEach()</code>会修改原来的数组。而<code>map()</code>方法会得到一个新的数组并返回。</p><p><strong>适用场景</strong></p><p><code>forEach</code>适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。</p><p><code>map()</code>适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(<em>composition</em>)(<em>map, filter, reduce</em> 等组合使用)来玩出更多的花样。</p></blockquote><h3 id="197-Array-的常用方法"><a href="#197-Array-的常用方法" class="headerlink" title="197. Array 的常用方法"></a>197. <em>Array</em> 的常用方法</h3><blockquote><p>参考答案：</p><p><em>Array</em> 的常用方法很多，挑选几个自己在实际开发中用的比较多的方法回答即可。</p><img src="/2022/11/24/%E6%8E%98%E9%87%91-JavaScript/11/24/%E6%8E%98%E9%87%91-JavaScript/2c66c11f3fe14000b1ed56b4d40f5f20tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="image-20210817231325109"><p>更多 <em>Array</em> 相关用法可以参阅：*<a href="https://link.juejin.cn/?target=https://www.w3school.com.cn/jsref/jsref_obj_array.asp">www.w3school.com.cn/jsref/jsref…</a>*</p></blockquote><h3 id="199-什么是预解析（预编译）"><a href="#199-什么是预解析（预编译）" class="headerlink" title="199. 什么是预解析（预编译）"></a>199. 什么是预解析（预编译）</h3><blockquote><p>参考答案：</p><p>所谓的预解析（预编译）就是：在当前作用域中，<em>JavaScript</em> 代码执行之前，浏览器首先会默认的把所有带 <em>var</em> 和 <em>function</em> 声明的变量进行提前的声明或者定义。</p><p>另外，<em>var</em> 声明的变量和 <em>function</em> 声明的函数在预解析的时候有区别，<em>var</em> 声明的变量在预解析的时候只是提前的声明，<em>function</em> 声明的函数在预解析的时候会提前声明并且会同时定义。也就是说 <em>var</em> 声明的变量和 <em>function</em> 声明的函数的区别是在声明的同时有没有同时进行定义。</p></blockquote><h3 id="201-冒泡排序的思路，不用-sort"><a href="#201-冒泡排序的思路，不用-sort" class="headerlink" title="201. 冒泡排序的思路，不用 sort"></a>201. 冒泡排序的思路，不用 <em>sort</em></h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> examplearr = [<span class="hljs-number">8</span>, <span class="hljs-number">94</span>, <span class="hljs-number">15</span>, <span class="hljs-number">88</span>, <span class="hljs-number">55</span>, <span class="hljs-number">76</span>, <span class="hljs-number">21</span>, <span class="hljs-number">39</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sortarr</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">var</span> temp = arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-title function_">sortarr</span>(examplearr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(examplearr); <span class="hljs-comment">// [8, 15, 21, 39, 55, 76, 88, 94]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="202-symbol-用途"><a href="#202-symbol-用途" class="headerlink" title="202. symbol 用途"></a>202. <em>symbol</em> 用途</h3><blockquote><p>参考答案：</p><p>可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗?我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法(除了 Object.getOwnPropertySymbols 外)遍历到，所以可以用来模拟私有变量。</p><p>主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</p><p>Symbol.for() 可以在全局访问 symbol</p></blockquote><h3 id="203-什么是函数式编程，应用场景是什么"><a href="#203-什么是函数式编程，应用场景是什么" class="headerlink" title="203. 什么是函数式编程，应用场景是什么"></a>203. 什么是函数式编程，应用场景是什么</h3><blockquote><p>参考答案：</p><p>函数式编程和面向对象编程一样，是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。 它主要有以下几个特点：</p><ol><li>函数是”一等公民”：函数优先，和其他数据类型一样。</li><li>只用”表达式”，不用”语句”：通过表达式（<em>expression</em>）计算过程得到一个返回值，而不是通过一个语句（<em>statement</em>）修改某一个状态。</li><li>无副作用：不污染变量，同一个输入永远得到同一个数据。</li><li>不可变性：前面一提到，不修改变量，返回一个新的值。</li></ol><p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 <em>Haskell</em>，以及一些语言开始逐渐成为多范式编程语言，比如 <em>Swift</em>，还有 <em>Kotlin，Java，Js</em> 等都开始具备函数式编程的特性。</p><p><strong>函数式编程在前端的应用场景</strong></p><ul><li><em>Stateless components</em>：<em>React</em> 在 <em>0.14</em> 之后推出的无状态组件</li><li><em>Redux</em></li></ul><p><strong>函数式编程在后端的应用场景</strong></p><ul><li><em>Lambda</em> 架构</li></ul></blockquote><h3 id="204-事件以及事件相关的兼容性问题"><a href="#204-事件以及事件相关的兼容性问题" class="headerlink" title="204. 事件以及事件相关的兼容性问题"></a>204. 事件以及事件相关的兼容性问题</h3><blockquote><p>参考答案：</p><p>事件最早是在 <em>IE3</em> 和  <em>Navigator2</em> 中出现的，当时是作为分担服务器运算负担的一种手段。要实现和网页的互动，就需要通过 <em>JavaScript</em> 里面的事件来实现。</p><p>每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测这些事件，然后对此作出响应。从而形成一种交互。</p><p>当我们绑定事件时，需要遵循事件三要素</p><ul><li>事件源：是指那个元素引发的事件。比如当你点击图标的时候，会跳转到百度首页。那么这个图标就是事件源。</li><li>事件：事件是指执行的动作。例如，点击，鼠标划过，按下键盘，获得焦点。</li><li>事件驱动程序：事件驱动程序即执行的结果。例如，当你点击图标的时候，会跳转到百度首页。那么跳转到百度首页就是事件的处理结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码事件源.事件 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    事件处理函数<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="205-JS-小数不精准，如何计算"><a href="#205-JS-小数不精准，如何计算" class="headerlink" title="205. JS 小数不精准，如何计算"></a>205. <em>JS</em> 小数不精准，如何计算</h3><blockquote><p>参考答案：</p><p>方法一：指定要保留的小数位数(0.1+0.2).toFixed(1) &#x3D; 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不同浏览器对toFixed的计算结果也存在差异。</p><p>方法二：把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。</p></blockquote><h3 id="206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal"><a href="#206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal" class="headerlink" title="206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal"></a>206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 <em>a,a+b,a+2b</em> 的时间，然后写一个 <em>myClear</em>，停止上面的 <em>mySetInterVal</em></h3><blockquote><p>参考答案：</p><p>该题的思路就是每一次在定时器中重启定时器并且在时间每一次都加 <em>b</em>，并且要把定时器返回回来，可以作为<em>myClear</em>的参数。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> mySetInterVal = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, a, b</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">var</span> settimer = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, a, b</span>) &#123;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      <span class="hljs-title function_">settimer</span>(fn, a + b, b);<br>    &#125;, a);<br>  &#125;<br>  <span class="hljs-title function_">settimer</span>(fn, a, b);<br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br><br><span class="hljs-keyword">var</span> timer = <span class="hljs-title function_">mySetInterVal</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer&#x27;</span>) &#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">var</span> myClear = <span class="hljs-keyword">function</span> (<span class="hljs-params">timer</span>) &#123;<br>  timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="207-合并二维有序数组成一维有序数组，归并排序的思路"><a href="#207-合并二维有序数组成一维有序数组，归并排序的思路" class="headerlink" title="207. 合并二维有序数组成一维有序数组，归并排序的思路"></a>207. 合并二维有序数组成一维有序数组，归并排序的思路</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">while</span> (left.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; right.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt; right[<span class="hljs-number">0</span>]) &#123;<br>            result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>())<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left).<span class="hljs-title function_">concat</span>(right)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> arrayItem1 = arr.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">let</span> arrayItem2 = arr.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">let</span> mergeArr = <span class="hljs-title function_">merge</span>(arrayItem1, arrayItem2);<br>        arr.<span class="hljs-title function_">push</span>(mergeArr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-keyword">let</span> arr1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br><span class="hljs-keyword">let</span> arr2 = [[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">13</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>]];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeSort</span>(arr1))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeSort</span>(arr2))<br></code></pre></td></tr></table></figure></blockquote><h3 id="208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。"><a href="#208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。" class="headerlink" title="208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。"></a>208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</h3><blockquote><p>参考答案：</p><p>首先，我们肯定需要封装一个函数，而这个函数接收一个字符串作为参数，返回不含有重复字符的子串长度。来看下面的示例：</p><p>示例 1:</p><p>输入: “abcabcbb” 输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:</p><p>输入: “bbbbb” 输出: 1 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:</p><p>输入: “pwwkew” 输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">var</span> y = [];<br>    <span class="hljs-keyword">var</span> temp = [];<br>    <span class="hljs-keyword">var</span> maxs = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-title function_">includes</span>(s[i])) &#123;<br><br>            y.<span class="hljs-title function_">push</span>(temp.<span class="hljs-property">length</span>);<br>            temp.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp.<span class="hljs-title function_">push</span>(s[i])<br>            y.<span class="hljs-title function_">push</span>(temp.<span class="hljs-property">length</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; y.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (maxs &lt;= y[j]) &#123;<br>            maxs = y[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxs;<br>&#125;;<br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-string">&#x27;abcabcbb&#x27;</span>)); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-string">&#x27;bbbbb&#x27;</span>)); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-string">&#x27;pwwkew&#x27;</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020"><a href="#209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020" class="headerlink" title="209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 2020)"></a>209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 <em>2020</em>)</h3><blockquote><p>参考答案：</p><p>本道题目是一道考察算法的题目，主要是考察编程基本功和一定的想像力。</p><p>具体的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">total, n</span>) &#123;<br>    <span class="hljs-comment">//先对整个数组进行排序</span><br>    total.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br>    <span class="hljs-comment">//求和</span><br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; total.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += total[i];<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> avg = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(sum / n);<br><br>    <span class="hljs-comment">//结果数组</span><br>    <span class="hljs-keyword">var</span> result = []; <span class="hljs-comment">//长度为n</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        result[i] = [total.<span class="hljs-title function_">pop</span>()];<br>        result[i].<span class="hljs-property">sum</span> = result[i][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">//组成一个分数组</span><br>        <span class="hljs-keyword">while</span> (result[i].<span class="hljs-property">sum</span> &lt; avg &amp;&amp; total.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; total.<span class="hljs-property">length</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (result[i].<span class="hljs-property">sum</span> + total[j] &gt;= avg) &#123;<br>                    result[i].<span class="hljs-title function_">push</span>(total[j]);<br>                    result[i].<span class="hljs-property">sum</span> += total[j];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (j == total.<span class="hljs-property">length</span>) &#123;<br>                result[i].<span class="hljs-title function_">push</span>(total.<span class="hljs-title function_">pop</span>());<br>                result[i].<span class="hljs-property">sum</span> += result[i][result[i].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//从数组中移除此元素</span><br>                total.<span class="hljs-title function_">splice</span>(j, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        sum -= result[i].<span class="hljs-property">sum</span>;<br>        avg = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(sum / (n - <span class="hljs-number">1</span> - i));<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">11</span>, <span class="hljs-number">42</span>, <span class="hljs-number">23</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>, <span class="hljs-number">90</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fun</span>(arr, <span class="hljs-number">3</span>));<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//     [ 90, 56, sum: 146 ],</span><br><span class="hljs-comment">//     [ 78, 42, 11, sum: 131 ],</span><br><span class="hljs-comment">//     [ 42, 23, 23, 11, 6, 6, 5, 5, 4, 4, sum: 129 ]</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="210-手写发布订阅（头条2020）"><a href="#210-手写发布订阅（头条2020）" class="headerlink" title="210. 手写发布订阅（头条2020）"></a>210. 手写发布订阅（头条2020）</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is a test<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        &#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            el : <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">            data : &#123;</span><br><span class="language-javascript">                msg : <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>js复制代码/*<br>    1. 创建 Vue 构造函数<br>        在 Vue 构造函数中，调用了 observer 函数，该函数的作用就是对数据进行劫持<br>        劫持具体要做的事儿：复制一份数据，但是不是单纯的复制，而是增加了 getter、setter<br>    2. 书写 compile 函数。该函数主要作用于模板，从模板里面要提取信息<br>        提取的东西主要有两个：&#123;&#123;&#125;&#125;  和 v-model<br>    3. 创建发布者 Dep 的构造函数，如果数据发生变化，发布者就会遍历内部的数组（花名册），通知订阅者修改数据<br>    4. 创建订阅者 Watcher 的构造函数，如果有数据的变化，发布者就会通知订阅者，订阅者上面存在 update 方法，会进行修改<br> */<br><br>function Vue(options)&#123;<br>    // this 代表 Vue 的实例对象，本例中就是 vm<br>    // options.data 这就是实际的数据 &#123;msg : &#x27;xiejie&#x27;&#125;<br>    observer(this,options.data);<br>    this.$el = options.el;<br>    compile(this);<br>&#125;<br><br>// 用于对模板进行信息提取，主要提取 &#123;&#123;&#125;&#125;  和 v-model，然后进行一些操作<br>// &#123;&#123; &#125;&#125; 会成为观察者，v-model 所对应的控件来绑定事件<br>function compile(vm)&#123;<br>    var el = document.querySelector(vm.$el); // el 所对应的值为 <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    var documentFragment = document.createDocumentFragment(); // 创建了一个空的文档碎片<br>    var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 创建正则表达式 匹配 &#123;&#123; &#125;&#125;<br>    while(el.childNodes[0])&#123;<br>        var child = el.childNodes[0]; // 将第一个子节点存储到 child<br>        if(child.nodeType == 1)&#123;<br>            // 如果能够进入此 if，说明该节点是一个元素节点<br>            for(var key in child.attributes)&#123;<br>                // 遍历该元素节点的每一个属性，拿到的就是 type=&quot;text&quot; v-model=&quot;msg&quot;<br>                var attrName = child.attributes[key].nodeName; // 获取属性名  type、v-model<br>                if(attrName === &#x27;v-model&#x27;)&#123;<br>                    var vmKey = child.attributes[key].nodeValue; // 先获取属性值，也就是 msg<br>                    // 为该节点，也就是 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span> 绑定一个 input 事件<br>                    child.addEventListener(&#x27;input&#x27;, function (event) &#123;<br>                        vm[vmKey] = event.target.value; // 获取用户输入的值，然后改变 vm 里面的 msg 属性对应的值，注意这里会触发 setter<br>                    &#125;)<br>                &#125;<br>            &#125;<br>        &#125;<br>        if(child.nodeType == 3)&#123;<br>            // 如果能进入此 if，说明该节点是一个文本节点<br>            if(reg.test(child.nodeValue))&#123;<br>                // 如果能够进入到此 if，说明是 &#123;&#123; &#125;&#125;，然后我们要让其成为订阅者<br>                var vmKey = RegExp.$1; // 获取正则里面的捕获值，也就是 msg<br>                // 实例化一个 Watcher（订阅者），接收 3 个参数：Vue 实例，该文本节点，捕获值 msg<br>                new Watcher(vm, child, vmKey);<br>            &#125;<br>        &#125;<br>        documentFragment.appendChild(el.childNodes[0]); // 将第一个子节点添加到文档碎片里面<br>    &#125;<br>    // 将文档碎片中节点重新添加到 el，也就是 <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 下面<br>    el.appendChild(documentFragment);<br>&#125;<br><br>// 新建发布者构造函数<br>function Dep() &#123;<br>    // 将观察者添加到发布者内部的数组里面<br>    // 这样以便于通知所有的观察者去更新数据<br>    this.subs = [];<br>&#125;<br><br>Dep.prototype = &#123;<br>    // 将 watcher 添加到发布者内置的数组里面<br>    addSub: function (sub) &#123;<br>        this.subs.push(sub);<br><br>    &#125;,<br>    // 遍历数组里面所有的 watcher，通知它们去更新数据<br>    notify: function () &#123;<br>        this.subs.forEach(function (sub) &#123;<br>            sub.update();<br>        &#125;)<br>    &#125;<br>&#125;<br><br>// 新建观察者 Watcher 构造函数<br>// 接收 3 个参数：Vue 实例，文本节点 &#123;&#123; msg &#125;&#125; 以及捕获内容 msg<br>function Watcher(vm, child, vmKey) &#123;<br>    this.vm = vm; // vm <br>    this.child = child; // &#123;&#123; msg &#125;&#125;<br>    this.vmKey = vmKey; // msg<br>    Dep.target = this; // 将该观察者实例对象添加给 Dep.target<br>    this.update(); // 执行节点更新方法<br>    Dep.target = null; // 最后清空 Dep.target<br>&#125;<br>Watcher.prototype = &#123;<br>    // 节点更新方法<br>    update: function () &#123;<br>        // 相当于：&#123;&#123; msg &#125;&#125;.nodeValue = this.vm[&#x27;msg&#x27;]<br>        // 这样就更新了文本节点的值，由于这里在获取 vm.msg，所以会触发 getter<br>        this.child.nodeValue = this.vm[this.vmKey];<br>    &#125;<br>&#125;<br><br>// 该函数的作用是用于数据侦听<br>function observer(vm,obj)&#123;<br>    var dep = new Dep(); // 新增一个发布者:发布者的作用是告诉订阅者数据已经更改<br>    // 遍历数据<br>    for(var key in obj)&#123;<br>        // 将数据的每一项添加到 vm 里面，至此，vm 也有了每一项数据<br>        // 但是不是单纯的添加，而是设置了 getter 和 setter<br>        // 在获取数据时触发 getter，在设置数据时触发 setter<br>        Object.defineProperty(vm, key, &#123;<br>            get() &#123;<br>                console.log(&quot;触发get了&quot;);<br>                // 触发 getter 时，将该 watcher 添加到发布者维护的数组里面<br>                if (Dep.target) &#123;<br>                    dep.addSub(Dep.target); // 往发布者的数组里面添加订阅者<br>                &#125;<br>                console.log(dep.subs);<br>                return obj[key];<br>            &#125;,<br>            set(newVal) &#123;<br>                console.log(&quot;触发set了&quot;);<br>                obj[key] = newVal;<br>                dep.notify(); // 发布者发出消息，通知订阅者修改数据<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）"><a href="#211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）" class="headerlink" title="211. 手写用 ES6proxy 如何实现 arr[-1] 的访问（滴滴2020）"></a>211. 手写用 <em>ES6proxy</em> 如何实现 <em>arr[-1]</em> 的访问（滴滴2020）</h3><blockquote><p>参考答案：</p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> <span class="hljs-title function_">proxyArray</span> = arr =&gt; &#123;<br>    <span class="hljs-keyword">const</span> length = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(arr, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>            key = +key;<br>            <span class="hljs-keyword">while</span> (key &lt; <span class="hljs-number">0</span>) &#123;<br>                key += length;<br>            &#125;<br>            <span class="hljs-keyword">return</span> target[key];<br>        &#125;<br>    &#125;)<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">proxyArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[-<span class="hljs-number">10</span>]);  <span class="hljs-comment">// 9</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[-<span class="hljs-number">20</span>]);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="212-下列代码执行结果"><a href="#212-下列代码执行结果" class="headerlink" title="212. 下列代码执行结果"></a>212. 下列代码执行结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>    &#125;);<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>);<br>&#125;);<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>);<br>    &#125;);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">11</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">12</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>1 7 6 8 2 4 3 5 9 11 10 12</p></blockquote><h3 id="213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"><a href="#213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办" class="headerlink" title="213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办"></a>213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办</h3><blockquote><p>参考答案：</p><p>Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。</p></blockquote><h3 id="214-事件是如何实现的？-字节2020"><a href="#214-事件是如何实现的？-字节2020" class="headerlink" title="214. 事件是如何实现的？(字节2020)"></a>214. 事件是如何实现的？(字节2020)</h3><blockquote><p>参考答案：</p><p>基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</p><p>比如点击按钮，这是个事件(Event)，而负责处理事件的代码段通常被称为事件处理程序(Event Handler)，也就是「启动对话框的显示」这个动作。</p><p>在 Web 端，我们常见的就是 DOM 事件：</p><ul><li>DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick &#x3D; null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</li><li>DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件</li><li>DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</li></ul></blockquote><h3 id="215-下列代码执行结果"><a href="#215-下列代码执行结果" class="headerlink" title="215. 下列代码执行结果"></a>215. 下列代码执行结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>0 1 2 3 4 5 6</p></blockquote><blockquote><p>解析：</p><p>照着代码，我们先来看初始任务。</p><ul><li>（初始任务）第一部分 Promise.resolve() 返回 「Promise { undefined }」。</li><li>（同任务，下同）继续调用 then，then 发现「Promise { undefined }」已解决，直接 enqueue 包含 console.log(0);return Promise.resolve(4) 的任务，之后返回新的「Promise { <pending> }」（设为 promise0）。被 enqueue 的任务之后会引发 promise0 的 resolve&#x2F;reject，详见 追加任务一 的 2. 3. 。</pending></li><li>继续调用 promise0 上的 then，第二个 then 发现 promise0 还在 pending，因此不能直接 enqueue 新任务，而是将包含 console.log(res) 回调追加到 promise0 的 PromiseFulfillReactions 列表尾部，并返回新的「Promise {  }」（设为 promiseRes）（该返回值在代码中被丢弃，但不影响整个过程）。</li><li>第二部分 Promise.resolve().then… 同理，只有包含 console.log(1) 的任务被 enqueue。中间结果分别设为 promise1（&#x3D;Promise.resolve().then(() &#x3D;&gt; {console.log(1);})）, promise2, promise3, promise5, promise6。当前任务执行完毕。</li></ul><p>此时，任务列队上有两个新任务，分别包含有 console.log(0);return Promise.resolve(4) 和 console.log(1) 。我们用 「Job { ??? }」来指代。</p><p>接下来，「Job { console.log(0);return Promise.resolve(4) }」先被 enqueue，所以先运行「Job { console.log(0);return Promise.resolve(4) }」。</p><ul><li>（追加任务一）此时「0」被 console.log(0) 输出。Promise.resolve(4) 返回已解决的「Promise { 4 }」，然后 return Promise.resolve(4) 将这个「Promise { 4 }」作为最开始的 Promise.resolve().then（对应 promise0）的 onfulfill 处理程序（即 then(onfulfill, onreject) 的参数 onfulfill）的返回值返回。</li><li>（同任务，下同）onfulfill 处理程序返回，触发了 promise0 的 Promise Resolve Function（以下简称某 promise（实例）的 resolve）。所谓触发，其实是和别的东西一起打包到「Job { console.log(0);return Promise.resolve(4) }」当中，按流程执行，onfulfill 返回后自然就到它了。（onfulfill 抛异常的话会被捕获并触发 reject，正常返回就是 resolve。）</li><li>promise0 的 resolve 检查 onfulfill 的返回值，发现该值包含<strong>可调用的</strong>「then」属性。这是当然的，因为是「Promise { 4 }」。无论该 Promise 实例是否解决，都将 enqueue 一个新任务包含调用该返回值的 then 的任务（即规范中的 NewPromiseResolveThenableJob(promiseToResolve, thenable, then)）。而这个任务才会触发后续操作，在本例中，最终会将 promise0 的 PromiseFulfillReactions （其中有包含 console.log(res) 回调）再打包成任务 enqueue 到任务列队上。当前任务执行完毕。</li></ul><p>此时，任务列队上还是有两个任务（一进一出），「Job { console.log(1) }」和「NewPromiseResolveThenableJob(promise0, 「Promise { 4 }」, 「Promise { 4 }」.then)」。接下来执行「Job { console.log(1) }」。</p><ul><li>（追加任务二）「1」被输出。</li><li>（同任务，下同）onfulfill 处理程序返回 undefined。（JavaScript 的函数默认就是返回 undefined。）</li><li>promise1 的 resolve 发现 undefined 连 Object 都不是，自然不会有 then，所以将 undefined 作为 promise1 的解决结果。即 promise1 从「Promise { <pending> }」变为 「Promise { undefined }」（fulfill）。</pending></li><li>resolve 继续查看 promise1 的 PromiseFulfillReactions。（reject 则会查看 PromiseRejectReactions。）有一个之前被 promise1.then 调用追加上的包含 console.log(2) 的回调。打包成任务入列。（如有多个则依次序分别打包入列。）当前任务执行完毕。</li></ul><p>此时，任务列队上仍然有两个任务（一进一出）。「NewPromiseResolveThenableJob(…)」和 「Job { console.log(2) }」。执行「NewPromiseResolveThenableJob(…)」。</p><ul><li>（追加任务三）调用 「Promise { 4 }」的 then。这个调用的参数（处理程序 onfulfill 和 onreject） 用的正是 promise0 的 resolve 和 reject。</li><li>由于「Promise { 4 }」的 then 是标准的，行为和其他的 then 一致。（可参见初始任务的步骤 2. 。）它发现「Promise { 4 }」已解决，结果是 4。于是直接 enqueue 包含 promise0 的 resolve 的任务，参数是 4。理论上同样返回一个「Promise {  }」，由于是在内部，不被外部观察，也不产生别的影响。）当前任务执行完毕。</li></ul><p>此时，任务列队上依旧有两个任务（一进一出）。「Job { console.log(2) }」和 「Job { promise0 的 resolve }」。执行「Job { console.log(2) }」。</p><ul><li>（追加任务四）过程类似「Job { console.log(1) }」的执行。「2」被输出。「Job { console.log(3) }」入列。其余不再赘述。当前任务执行完毕。</li></ul><p>此时，任务列队上依然有两个任务（一进一出）。「Job { promise0 的 resolve }」和「Job { console.log(3) }」。执行「Job { promise0 的 resolve }」。</p><ul><li>（追加任务五）promise0 的 resolve 查看 PromiseFulfillReactions 发现有被 promise0.then 追加的回调。打包成任务入列。该任务包含 console.log(res)，其中传递 promise0 解决结果 4 给参数 res。当前任务执行完毕。</li></ul><p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(3) }」和「Job { console.log(res) }」。</p><ul><li>（追加任务六）输出「3」。「Job { console.log(5) }」入列。</li></ul><p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(res) }」和「Job { console.log(5) }」。</p><ul><li>（追加任务七）输出「4」。由于 promiseRes 没有被 then 追加回调。就此打住。</li></ul><p>此时，任务列队上终于不再是两个任务了。下剩「Job { console.log(5) }」。</p><ul><li>（追加任务八）输出「5」。「Job { console.log(6) }」入列。</li></ul><p>最后一个任务（追加任务九）输出「6」。任务列队清空。</p><p>因此，输出的顺序是「0 1 2 3 4 5 6」。</p><p>总结一下，除去初始任务，总共 enqueue 了 9 个任务。其中，第一串 Promise + then… enqueue 了 4 个。第二串 Promise + then… enqueue 了 5 个。分析可知，每增加一个 then 就会增加一个任务入列。</p><p>而且，第一串的 return Promise.resolve(4) 的写法额外 enqueue 了 2 个任务，分别在 promise0 的 resolve 时（追加任务一 3.）和调用「Promise { 4 }」的 then 本身时（追加任务三 2.）。</p><p>根据规范，它就该这样。说不上什么巧合，可以算是有意为之。处理程序里返回 thenable 对象就会导致增加两个任务入列。</p></blockquote><h3 id="216-判断数组的方法，请分别介绍它们之间的区别和优劣"><a href="#216-判断数组的方法，请分别介绍它们之间的区别和优劣" class="headerlink" title="216. 判断数组的方法，请分别介绍它们之间的区别和优劣"></a>216. 判断数组的方法，请分别介绍它们之间的区别和优劣</h3><blockquote><p>参考答案：</p><p>方法一：<strong>instanceof 操作符判断</strong></p><p><strong>用法：arr instanceof Array</strong></p><p><strong>instanceof 主要是用来判断某个实例是否属于某个对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>缺点：instanceof是判断类型的prototype是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。并且也不能判断对象和数组的区别</p><p>方法二：<strong>对象构造函数的 constructor判断</strong></p><p><strong>用法：arr.constructor &#x3D;&#x3D;&#x3D; Array</strong></p><p><strong>Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>方法三：<strong>Array 原型链上的 isPrototypeOf</strong></p><p><strong>用法：Array.prototype.isPrototypeOf(arr</strong>)</p><p><strong>Array.prototype  属性表示 Array 构造函数的原型</strong></p><p>其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(arr)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>方法四：<strong>Object.getPrototypeOf</strong></p><p><strong>用法：Object.getPrototypeOf(arr) &#x3D;&#x3D;&#x3D; Array.prototype</strong></p><p><strong>Object.getPrototypeOf() 方法返回指定对象的原型</strong></p><p>所以只要跟Array的原型比较即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(arr) === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>方法五：<strong>Object.prototype.toString</strong></p><p><strong>用法：Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; ‘[object Array]’</strong></p><p>虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]</p><p>方法六：<strong>Array.isArray</strong></p><p><strong>用法：Array.isArray(arr)</strong></p><p><strong>ES5中新增了Array.isArray方法,IE8及以下不支持</strong></p><p>Array.isArray ( arg ) isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 “Array”, 返回布尔值 true；否则它返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>缺点：Array.isArray是ES 5.1推出的，<strong>不支持IE6~8</strong>，所以在使用的时候需要注意兼容性问题。</p></blockquote><h3 id="217-JavaScript-中的数组和函数在内存中是如何存储的？"><a href="#217-JavaScript-中的数组和函数在内存中是如何存储的？" class="headerlink" title="217. JavaScript 中的数组和函数在内存中是如何存储的？"></a>217. JavaScript 中的数组和函数在内存中是如何存储的？</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 中，数组不是以一段连续的区域存储在内存中，而是一种哈希映射的形式存储在堆内容里面。它可以通过多种数据结构实现，其中一种是链表。如下图所示：</p><p>JavaScript 中的函数是存储在堆内存中的，具体的步骤如下：</p><ol><li>开辟堆内存（<em>16</em> 进制得到内存地址）</li><li>声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）</li><li>把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）</li><li>将函数堆的地址，放在栈中供变量调用（函数名）</li></ol></blockquote><h3 id="218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？"><a href="#218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？" class="headerlink" title="218. JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？"></a>218. <em>JavaScript</em> 是如何运行的？解释型语言和编译型语言的差异是什么？</h3><blockquote><p>参考答案：</p><p>关于第一个问题，这不是三言两语或者几行文字就能够讲清楚的，这里放上一篇博文地址：</p><p><em><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000019530109">segmentfault.com&#x2F;a&#x2F;119000001…</a></em></p><p>第二个问题：解释型语言和编译型语言的差异是什么？</p><p>电脑能认得的是二进制数，不能够识别高级语言。所有高级语言在电脑上执行都需要先转变为机器语言。但是高级语言有两种类型：编译型语言和解释型语言。常见的编译型语言语言有C&#x2F;C++、Pascal&#x2F;Object 等等。常见的解释性语言有python、JavaScript等等。</p><p>编译型语言先要进行编译，然后转为特定的可执行文件，这个可执行文件是针对平台的（CPU类型），可以这么理解你在PC上编译一个C源文件，需要经过预处理，编译，汇编等等过程生成一个可执行的二进制文件。当你需要再次运行改代码时，不需要重新编译代码，只需要运行该可执行的二进制文件。优点，编译一次，永久执行。还有一个优点是，你不需要提供你的源代码，你只需要发布你的可执行文件就可以为客户提供服务，从而保证了你的源代码的安全性。但是，如果你的代码需要迁移到linux、ARM下时，这时你的可执行文件就不起作用了，需要根据新的平台编译出一个可执行的文件。这也就是多个平台需要软件的多个版本。缺点是，跨平台能力差。</p><p>解释型语言需要一个解释器，在源代码执行的时候被解释器翻译为一个与平台无关的中间代码，解释器会把这些代码翻译为及其语言。打个比方，编译型中的编译相当于一个翻译官，它只能翻译英语，而且中文文章翻译一次就不需要重新对文章进行二次翻译了，但是如果需要叫这个翻译官翻译德语就不行了。而解释型语言中的解释器相当于一个会各种语言的机器人，而且这个机器人回一句一句的翻译你的语句。对于不同的国家，翻译成不同的语言，所以，你只需要带着这个机器人就可以。解释型语言的有点是，跨平台，缺点是运行时需要源代码，知识产权保护性差，运行效率低。</p></blockquote><h3 id="219-列举你所了解的编程范式？"><a href="#219-列举你所了解的编程范式？" class="headerlink" title="219. 列举你所了解的编程范式？"></a>219. 列举你所了解的编程范式？</h3><blockquote><p>参考答案：</p><p>编程范式 <em>Programming paradigm</em> 是指计算机中编程的典范模式或方法。</p><p>常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程等。</p><p>不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的，如 <em>Smalltalk</em> 和 <em>Java</em> 支持面向对象编程。而 <em>Haskell</em> 和 <em>Scheme</em> 则支持函数式编程。现代编程语言的发展趋势是支持多种范型，例如 <em>ES</em> 支持函数式编程的同时也支持面向对象编程。</p></blockquote><h3 id="220-什么是面向切面（AOP）的编程？"><a href="#220-什么是面向切面（AOP）的编程？" class="headerlink" title="220. 什么是面向切面（AOP）的编程？"></a>220. 什么是面向切面（AOP）的编程？</h3><blockquote><p>参考答案：</p><p><strong>什么是AOP？</strong></p><p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。</p><p><strong>AOP能给我们带来什么好处？</strong></p><p>AOP的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。</p><p><strong>JavaScript实现AOP的思路？</strong></p><p>通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面我用扩展 Function.prototype 来做到这一点。</p><p>主要就是两个函数，在Function的原型上加上before与after，作用就是字面的意思，在函数的前面或后面执行，相当于<strong>无侵入</strong>把一个函数插入到另一个函数的前面或后面，应用得当可以很好的实现代码的解耦，js中的代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">//Aop构造器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Aop</span>(<span class="hljs-params">options</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options<br>&#125;<br><span class="hljs-comment">//业务方法执行前钩子</span><br><span class="hljs-title class_">Aop</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">before</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>    cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-comment">//业务方法执行后钩子</span><br><span class="hljs-title class_">Aop</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">after</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>    cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-comment">//业务方法执行器</span><br><span class="hljs-title class_">Aop</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">execute</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">beforeCb,runner,afterCb</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">before</span>(beforeCb)<br>    runner.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">after</span>(afterCb)<br>&#125;<br><br><span class="hljs-keyword">var</span> aop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aop</span>(&#123;<br>    <span class="hljs-attr">afterInfo</span>:<span class="hljs-string">&#x27;执行后&#x27;</span>,<br>    <span class="hljs-attr">runnerInfo</span>:<span class="hljs-string">&#x27;执行中&#x27;</span>,<br>    <span class="hljs-attr">beforeInfo</span>:<span class="hljs-string">&#x27;执行前&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">var</span> beforeCb = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">beforeInfo</span>)<br>&#125;<br><span class="hljs-keyword">var</span> afterCb = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">afterInfo</span>)<br>&#125;<br><span class="hljs-keyword">var</span> runnerCb = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">runnerInfo</span>)<br>&#125;<br><br>aop.<span class="hljs-title function_">execute</span>(beforeCb,runnerCb,afterCb)<br></code></pre></td></tr></table></figure><p>应用的一些例子：</p><ol><li>为 <em>window.onload</em> 添加方法，防止 <em>window.onload</em> 被二次覆盖</li><li>无侵入统计某个函数的执行时间</li><li>表单校验</li><li>统计埋点</li><li>防止 <em>csrf</em> 攻击</li></ol></blockquote><h3 id="221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？"><a href="#221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？" class="headerlink" title="221. JavaScript 中的 const 数组可以进行 push 操作吗？为什么？"></a>221. <em>JavaScript</em> 中的 <em>const</em> 数组可以进行 <em>push</em> 操作吗？为什么？</h3><blockquote><p>参考答案：</p><p>可以进行 <em>push</em> 操作。虽然 <em>const</em> 表示常量，但是当我们把一个数组赋值给 <em>const</em> 声明的变量时，实际上是把这个数组的地址赋值给该变量。而 <em>push</em> 操作是在数组地址所指向的堆区添加元素，地址本身并没有发生改变。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>];<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？"><a href="#222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？" class="headerlink" title="222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？"></a>222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？</h3><blockquote><p>参考答案：</p><p>从<em>ES5</em>开始，添加了对对象<strong>属性描述符</strong>的支持。现在<em>JavaScript</em>中支持 <em>4</em> 种属性描述符:</p><ul><li><strong>configurable:</strong> 当且仅当该属性的<em>configurable</em>键值为<em>true</em>时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</li><li><strong>enumerable:</strong> 当且仅当该属性的<em>enumerable</em>键值为<em>true</em>时，该属性才会出现在对象的枚举属性中。</li><li><strong>value:</strong> 该属性对应的值。可以是任何有效的 <em>JavaScript</em> 值（数值，对象，函数等）。</li><li><strong>writable:</strong> 当且仅当该属性的<em>writable</em>键值为<em>true</em>时，属性的值，也就是上面的value，才能被赋值运算符改变。</li></ul></blockquote><h3 id="223-JavaScript-中-console-有哪些-api"><a href="#223-JavaScript-中-console-有哪些-api" class="headerlink" title="223. JavaScript 中 console 有哪些 api ?"></a>223. <em>JavaScript</em> 中 <em>console</em> 有哪些 <em>api</em> ?</h3><blockquote><p>参考答案：</p><p><strong>console.assert(expression, object[, object…])</strong></p><p>接收至少两个参数，第一个参数的值或返回值为<code>false</code>的时候，将会在控制台上输出后续参数的值。</p><p><strong>console.count([label])</strong></p><p>输出执行到该行的次数，可选参数 label 可以输出在次数之前。</p><p><strong>console.dir(object)</strong></p><p>将传入对象的属性，包括子对象的属性以列表形式输出。</p><p><strong>console.error(object[, object…])</strong></p><p>用于输出错误信息，用法和常见的<code>console.log</code>一样，不同点在于输出内容会标记为错误的样式，便于分辨。</p><p><strong>console.group</strong></p><p>这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个<code>console.group()</code>会增加一层嵌套，相反要减少一层嵌套可以使用<code>console.groupEnd()</code>方法。</p><p><strong>console.info(object[, object…])</strong></p><p>此方法与之前说到的<code>console.error</code>一样，用于输出信息，没有什么特别之处。</p><p><strong>console.table()</strong></p><p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p><p><strong>console.log(object[, object…])</strong></p><p>输入一段 <em>log</em> 信息。</p><p><strong>console.profile([profileLabel])</strong></p><p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及<code>console.profile()</code>方法我们可以很方便地监控运行性能。</p><p><strong>console.time(name)</strong> 计时器，可以将成对的<code>console.time()</code>和<code>console.timeEnd()</code>之间代码的运行时间输出到控制台上，<code>name</code>参数可作为标签名。</p><p><strong>console.trace()</strong></p><p><code>console.trace()</code>用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p><p><strong>console.warn(object[, object…])</strong></p><p>输出参数的内容，作为警告提示。</p></blockquote><h3 id="225-Object-defineProperty-有哪几个参数？各自都有什么作用"><a href="#225-Object-defineProperty-有哪几个参数？各自都有什么作用" class="headerlink" title="225. Object.defineProperty 有哪几个参数？各自都有什么作用"></a>225. <em>Object.defineProperty</em> 有哪几个参数？各自都有什么作用</h3><blockquote><p>参考答案：</p><p>在 <em>JavaScript</em> 中，通过 <em>Object.defineProperty</em> 方法可以设置对象属性的特性，选项如下：</p><ul><li><em>get</em>：一旦目标属性被访问时，就会调用相应的方法</li><li><em>set</em>：一旦目标属性被设置时，就会调用相应的方法</li><li><em>value</em>：这是属性的值，默认是 <em>undefined</em></li><li><em>writable</em>：这是一个布尔值，表示一个属性是否可以被修改，默认是 <em>true</em></li><li><em>enumerable</em>：这是一个布尔值，表示在用 <em>for-in</em> 循环遍历对象的属性时，该属性是否可以显示出来，默认值为 <em>true</em></li><li><em>configurable</em>：这是一个布尔值，表示我们是否能够删除一个属性或者修改属性的特性，默认值为 <em>true</em></li></ul></blockquote><h3 id="226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？"><a href="#226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？" class="headerlink" title="226. Object.defineProperty 和 ES6 的 Proxy 有什么区别？"></a>226. <em>Object.defineProperty</em> 和 <em>ES6</em> 的 <em>Proxy</em> 有什么区别？</h3><blockquote><p>参考答案：</p><h5 id="1、Object-defineproperty"><a href="#1、Object-defineproperty" class="headerlink" title="1、Object.defineproperty"></a>1、<em>Object.defineproperty</em></h5><p>可以用于监听对象的数据变化</p><p>语法： <em><strong>Object.defineproperty(obj, key, descriptor)</strong></em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">11</span><br>&#125;<br><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;xiaoxiao&#x27;</span>;<br><span class="hljs-comment">//defineproperty 有 gettter 和 setter</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineproperty</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>        value = newValue<br>    &#125;<br>&#125;)<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;pengpeng&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此外 还有以下配置项 ：</p><ul><li><em>configurable</em></li><li><em>enumerable</em></li><li><em>value</em></li></ul><p>缺点：</p><ol><li>无法监听数组变化</li><li>只能劫持对象的属性，属性值也是对象那么需要深度遍历</li></ol><h5 id="2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截"><a href="#2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截" class="headerlink" title="2、proxy ：可以理解为在被劫持的对象之前 加了一层拦截"></a>2、<em>proxy</em> ：可以理解为在被劫持的对象之前 加了一层拦截</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">obj, prop</span>) &#123;<br>        <span class="hljs-keyword">return</span> obj[prop]<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">obj, prop, val</span>) &#123;<br>        obj[prop] = val<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><em>proxy</em> 返回的是一个新对象， 可以通过操作返回的新的对象达到目的</li><li><em>proxy</em> 有多达 <em>13</em> 种拦截方法</li></ul><p><strong>总结：</strong></p><ul><li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li><li><em>Object.defineProperty</em> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<em>Proxy</em> 可以劫持整个对象，并返回一个新的对象。</li><li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ul></blockquote><h3 id="227-intanceof-操作符的实现原理及实现"><a href="#227-intanceof-操作符的实现原理及实现" class="headerlink" title="227. intanceof 操作符的实现原理及实现"></a>227. <em>intanceof</em> 操作符的实现原理及实现</h3><blockquote><p>参考答案：</p><p><em>instanceof</em> 主要作用就是判断一个实例是否属于某种类型</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> <span class="hljs-title class_">Dog</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">let</span> tidy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br>tidy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><em>intanceof</em> 操作符实现原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">wonderFulInstanceOf</span>(<span class="hljs-params">instance, constructorFn</span>) &#123; <br>    <span class="hljs-keyword">let</span> constructorFnProto = constructorFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 取右表达式的 prototype 值，函数构造器指向的function </span><br>    instanceProto = instance.<span class="hljs-property">__proto__</span>; <span class="hljs-comment">// 取左表达式的__proto__值，实例的__proto__</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (instanceProto === <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (instanceProto === constructorFnProto) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        instanceProto = instanceProto.<span class="hljs-property">__proto__</span> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <em>instanceof</em> 主要的实现原理就是只要 <em>constructorFn</em> 的 <em>prototype</em> 在<em>instance</em>的原型链上即可。</p><p>因此，<em>instanceof</em> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <em>prototype</em>，如果查找失败，则会返回 <em>false</em>，告诉我们左边变量并非是右边变量的实例。</p></blockquote><h3 id="228-强制类型转换规则？"><a href="#228-强制类型转换规则？" class="headerlink" title="228. 强制类型转换规则？"></a>228. 强制类型转换规则？</h3><blockquote><p>参考答案：</p><p>首先需要了解隐式转换所调用的函数。</p><p>当程序员显式调用 Boolean(value)、Number(value)、String(value) 完成的类型转换，叫做显示类型转换。</p><p>当通过 new Boolean(value)、new Number(value)、new String(value) 传入各自对应的原始类型的值，可以实现“装箱”，将原始类型封装成一个对象。</p><p>其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;sdfsd&#x27;</span>);  <span class="hljs-comment">//  true</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;23&quot;</span>);  <span class="hljs-comment">//  23</span><br><span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">24</span>&#125;);  <span class="hljs-comment">//  &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>其实这三个函数用于类型转换的时候，调用的就是 js 内部的 <em>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</em> 方法，从而达到显式转换的效果。</p></blockquote><h3 id="229-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别"><a href="#229-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别" class="headerlink" title="229. Object.is( ) 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别"></a>229. <em>Object.is</em>( ) 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别</h3><blockquote><p>参考答案：</p><p>&#x3D;&#x3D; (或者 !&#x3D;) 操作在需要的情况下自动进行了类型转换。&#x3D;&#x3D;&#x3D; (或 !&#x3D;&#x3D;)操作不会执行任何转换。</p><p>&#x3D;&#x3D;&#x3D;在比较值和类型时，可以说比&#x3D;&#x3D;更快。</p><p>而在<em>ES6</em>中，<em>Object.is</em>( ) 类似于 &#x3D;&#x3D;&#x3D;，但在三等号判等的基础上特别处理了 <em>NaN</em> 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 <em>Object.is(NaN, NaN)</em> 会返回 <em>true</em>。</p></blockquote><h3 id="230-操作符什么时候用于字符串的拼接？"><a href="#230-操作符什么时候用于字符串的拼接？" class="headerlink" title="230. + 操作符什么时候用于字符串的拼接？"></a>230. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><blockquote><p>参考答案：</p><p>在有一边操作数是字符串时会进行字符串拼接。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span> + <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-keyword">typeof</span> (<span class="hljs-number">5</span> + <span class="hljs-string">&#x27;5&#x27;</span>)); <span class="hljs-comment">// 55  string</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="231-object-assign-和扩展运算法是深拷贝还是浅拷贝"><a href="#231-object-assign-和扩展运算法是深拷贝还是浅拷贝" class="headerlink" title="231. object.assign 和扩展运算法是深拷贝还是浅拷贝"></a>231. <em>object.assign</em> 和扩展运算法是深拷贝还是浅拷贝</h3><blockquote><p>参考答案：</p><p>这两个方式都是浅拷贝。</p><p>在拷贝的对象只有一层时是深拷贝，但是一旦对象的属性值又是一个对象，也就是有两层或者两层以上时，就会发现这两种方式都是浅拷贝。</p></blockquote><h3 id="233-如果-new-一个箭头函数的会怎么样"><a href="#233-如果-new-一个箭头函数的会怎么样" class="headerlink" title="233. 如果 new 一个箭头函数的会怎么样"></a>233. 如果 <em>new</em> 一个箭头函数的会怎么样</h3><blockquote><p>参考答案：</p><p>会报错，因为箭头函数无法作为构造函数。</p></blockquote><h3 id="234-扩展运算符的作用及使用场景"><a href="#234-扩展运算符的作用及使用场景" class="headerlink" title="234. 扩展运算符的作用及使用场景"></a>234. 扩展运算符的作用及使用场景</h3><blockquote><p>参考答案：</p><p>扩展运算符是三个点(…)，主要用于展开数组，将一个数组转为参数序列。</p><p>扩展运算符使用场景：</p><ul><li>代替数组的 <em>apply</em> 方法</li><li>合并数组</li><li>复制数组</li><li>把 <em>arguments</em> 或 <em>NodeList</em> 转为数组</li><li>与解构赋值结合使用</li><li>将字符串转为数组</li></ul></blockquote><h3 id="235-Proxy-可以实现什么功能？"><a href="#235-Proxy-可以实现什么功能？" class="headerlink" title="235. Proxy 可以实现什么功能？"></a>235. <em>Proxy</em> 可以实现什么功能？</h3><blockquote><p>参考答案：</p><p><em>Proxy</em> 是 <em>ES6</em> 中新增的一个特性。<em>Proxy</em> 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p><p><em>Proxy</em> 在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。</p><p>使用 <em>Proxy</em> 的好处是对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 <em>Proxy</em> 来做。从而达到关注点分离，降级对象复杂度的目的。</p><p><em>Proxy</em> 的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript<br>复制代码<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><p>通过构造函数来生成 <em>Proxy</em> 实例，构造函数接收两个参数。<em>target</em> 参数是要拦截的目标对象，<em>handler</em> 参数也是一个对象，用来定制拦截行为。</p><p><em>Vue 3.0</em> 主要就采用的 <em>Proxy</em> 特性来实现响应式，相比以前的 <em>Object.defineProperty</em> 有以下优点：</p><ul><li>可以劫持整个对象，并返回一个新的对象</li><li>有 <em>13</em> 种劫持操作</li></ul></blockquote><h3 id="236-对象与数组的解构的理解"><a href="#236-对象与数组的解构的理解" class="headerlink" title="236. 对象与数组的解构的理解"></a>236. 对象与数组的解构的理解</h3><blockquote><p>参考答案：</p><p>解构是 <em>ES6</em> 的一种语法规则，可以将一个对象或数组的某个属性提取到某个变量中。</p><p>解构对象示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">//  var/let/const&#123;属性名&#125;=被解构的对象</span><br><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;abc&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">province</span>: <span class="hljs-string">&quot;重庆&quot;</span>,<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;重庆&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> &#123; name, age, sex, address&#125; = user;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age, sex, address);<br></code></pre></td></tr></table></figure><p>解构数组示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure></blockquote><h3 id="237-如何提取高度嵌套的对象里的指定属性？"><a href="#237-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="237. 如何提取高度嵌套的对象里的指定属性？"></a>237. 如何提取高度嵌套的对象里的指定属性？</h3><blockquote><p>参考答案：</p><p>一般会使用递归的方式来进行查找。下面是一段示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">findKey</span>(<span class="hljs-params">data, field</span>) &#123;<br>    <span class="hljs-keyword">let</span> finding = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;<br>        <span class="hljs-keyword">if</span> (key === field) &#123;<br>            finding = data[key];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (data[key]) === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>            finding = <span class="hljs-title function_">findKey</span>(data[key], field);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (finding) &#123;<br>            <span class="hljs-keyword">return</span> finding;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 测试</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findKey</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">stuInfo</span>: &#123;<br>        <span class="hljs-attr">stuNo</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">classNo</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">score</span>: &#123;<br>            <span class="hljs-attr">htmlScore</span>: <span class="hljs-number">100</span>,<br>            <span class="hljs-attr">cssScore</span>: <span class="hljs-number">90</span>,<br>            <span class="hljs-attr">jsScore</span>: <span class="hljs-number">95</span><br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&#x27;cssScore&#x27;</span>)); <span class="hljs-comment">// 90</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="238-Unicode、UTF-8、UTF-16、UTF-32-的区别？"><a href="#238-Unicode、UTF-8、UTF-16、UTF-32-的区别？" class="headerlink" title="238. Unicode、UTF-8、UTF-16、UTF-32 的区别？"></a>238. <em>Unicode、UTF-8、UTF-16、UTF-32</em> 的区别？</h3><blockquote><p>参考答案：</p><p><em>Unicode</em> <strong>为世界上所有字符都分配了一个唯一的数字编号</strong>，这个编号范围从 <em>0x000000</em> 到 <em>0x10FFFF</em> (十六进制)，有 <em>110</em> 多万，每个字符都有一个唯一的 <em>Unicode</em> 编号，这个编号一般写成 <em>16</em> 进制，在前面加上 U+。例如：“马”的 <em>Unicode</em> 是 <em>U+9A6C</em>。 <em>Unicode</em> 就相当于一张表，建立了字符与编号之间的联系。</p><p>*<strong>Unicode* 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</strong></p><p>那我们可以直接把 <em>Unicode</em> 编号直接转换成二进制进行存储，怎么对应到二进制表示呢？</p><p><em>Unicode</em> 可以使用的编码有三种，分别是：</p><ul><li><em>UFT-8</em>：一种变长的编码方案，使用 <em>1~6</em> 个字节来存储；</li><li><em>UFT-32</em>：一种固定长度的编码方案，不管字符编号大小，始终使用 <em>4</em> 个字节来存储；</li><li><em>UTF-16</em>：介于 <em>UTF-8</em> 和 <em>UTF-32</em> 之间，使用 <em>2</em> 个或者 <em>4</em> 个字节来存储，长度既固定又可变。</li></ul></blockquote><h3 id="239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="239. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>239. 为什么函数的 <em>arguments</em> 参数是类数组而不是数组？如何遍历类数组?</h3><blockquote><p>参考答案：</p><p>首先了解一下什么是数组对象和类数组对象。</p><p>数组对象：使用单独的变量名来存储一系列的值。从 <em>Array</em> 构造函数中继承了一些用于进行数组操作的方法。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> mycars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>mycars[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>mycars[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;lisi&quot;</span>;<br>mycars[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;wangwu&quot;</span>;<br></code></pre></td></tr></table></figure><p>类数组对象：<strong>对于一个普通的对象来说，如果它的所有 property 名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。</strong></p><p><strong>两者区别</strong></p><ul><li>一个是对象，一个是数组</li><li>数组的<em>length</em>属性，当新的元素添加到列表中的时候，其值会自动更新。类数组对象的不会。</li><li>设置数组的<em>length</em>属性可以扩展或截断数组。</li><li>数组也是<em>Array</em>的实例可以调用<em>Array</em>的方法，比如<em>push、pop</em>等等</li></ul><p>所以说<em>arguments</em>对象不是一个 <em>Array</em> 。它类似于<em>Array</em>，但除了<em>length</em>属性和索引元素之外没有任何<em>Array</em>属性。</p><p>可以使用 <em>for…in</em> 来遍历 <em>arguments</em> 这个类数组对象。</p></blockquote><h3 id="240-escape、encodeURI、encodeURIComponent-的区别"><a href="#240-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="240. escape、encodeURI、encodeURIComponent 的区别"></a>240. <em>escape、encodeURI、encodeURIComponent</em> 的区别</h3><blockquote><p>参考答案：</p><p><em>escape</em> 除了 <em>ASCII</em> 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对 <em>URL</em> 编码，最好不要使用此方法。</p><p><em>encodeURI</em> 用于编码整个 <em>URI</em>，因为 <em>URI</em> 中的合法字符都不会被编码转换。</p><p><em>encodeURIComponent</em> 方法在编码单个<em>URIComponent</em>（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个 <em>URL</em>。</p></blockquote><h3 id="241-use-strict-是什么意思-使用它区别是什么？"><a href="#241-use-strict-是什么意思-使用它区别是什么？" class="headerlink" title="241. use strict 是什么意思 ? 使用它区别是什么？"></a>241. <em>use strict</em> 是什么意思 ? 使用它区别是什么？</h3><blockquote><p>参考答案：</p><p><em>use strict</em> 代表开启严格模式，这种模式使得 <em>Javascript</em> 在更严格的条件下运行，实行更严格解析和错误处理。</p><p>开启“严格模式”的优点：</p><ul><li>消除 <em>Javascript</em> 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 <em>Javascript</em> 做好铺垫。</li></ul></blockquote><h3 id="242-for…in-和-for…of-的区别"><a href="#242-for…in-和-for…of-的区别" class="headerlink" title="242. for…in 和 for…of 的区别"></a>242. <em>for…in</em> 和 <em>for…of</em> 的区别</h3><blockquote><p>参考答案：</p><p><em>JavaScript</em> 原有的 <em>for…in</em> 循环，只能获得对象的键名，不能直接获取键值。<em>ES6</em> 提供 <em>for…of</em> 循环，允许遍历获得键值。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">in</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 0 1 2 3</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// a b c d</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="243-ajax、axios、fetch-的区别"><a href="#243-ajax、axios、fetch-的区别" class="headerlink" title="243. ajax、axios、fetch 的区别"></a>243. <em>ajax、axios、fetch</em> 的区别</h3><blockquote><p>参考答案：</p><p><em>ajax</em> 是指一种创建交互式网页应用的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。</p><p>使用 <em>ajax</em> 发送请求是依靠于一个对象，叫 <em>XmlHttpRequest</em> 对象，通过这个对象我们可以从服务器获取到数据，然后再渲染到我们的页面上。现在几乎所有的浏览器都有这个对象，只有 <em>IE7</em> 以下的没有，而是通过 <em>ActiveXObject</em> 这个对象来创建的。</p><p><em>Fetch</em> 是 <em>ajax</em> 非常好的一个替代品，基于 <em>Promise</em> 设计，使用 <em>Fetch</em> 来获取数据时，会返回给我们一个 <em>Pormise</em> 对象，但是 <em>Fetch</em> 是一个低层次的 <em>API</em>，想要很好的使用 <em>Fetch</em>，需要做一些封装处理。</p><p>下面是 <em>Fetch</em> 的一些缺点</p><ul><li><em>Fetch</em> 只对网络请求报错，对 <em>400，500</em> 都当做成功的请求，需要封装去处理</li><li><em>Fetch</em> 默认不会带 <em>cookie</em>，需要添加配置项。</li><li><em>Fetch</em> 不支持 <em>abort</em>，不支持超时控制，使用 <em>setTimeout</em> 及 <em>Promise.reject</em> 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。</li><li><em>Fetch</em> 没有办法原生监测请求的进度，而 <em>XHR</em> 可以。</li></ul><p><em>Vue2.0</em> 之后，<em>axios</em> 开始受到更多的欢迎了。其实 <em>axios</em> 也是对原生 <em>XHR</em> 的一种封装，不过是 <em>Promise</em> 实现版本。它可以用于浏览器和 <em>nodejs</em> 的 <em>HTTP</em> 客户端，符合最新的 <em>ES</em> 规范。</p></blockquote><h3 id="244-下面代码的输出是什么？（-D-）"><a href="#244-下面代码的输出是什么？（-D-）" class="headerlink" title="244. 下面代码的输出是什么？（ D ）"></a>244. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Lydia&quot;</span>;<br>  <span class="hljs-keyword">let</span> age = <span class="hljs-number">21</span>;<br>&#125;<br><br><span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>Lydia</em> 和 <em>undefined</em></li><li>B: <em>Lydia</em> 和 <em>ReferenceError</em></li><li>C: <em>ReferenceError</em> 和 <em>21</em></li><li>D: <em>undefined</em> 和 <em>ReferenceError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>在 <em>sayHi</em> 函数内部，通过 <em>var</em> 声明的变量 <em>name</em> 会发生变量提升，<em>var name</em> 会提升到函数作用域的顶部，其默认值为 <em>undefined</em>。因此输出 <em>name</em> 时得到的值为 <em>undefined</em>；</p><p><em>let</em> 声明的 <em>age</em> 不会发生变量提升，在输出 <em>age</em> 时该变量还未声明，因此会抛出 <em>ReferenceError</em> 的报错。</p></blockquote><h3 id="245-下面代码的输出是什么？（-C-）"><a href="#245-下面代码的输出是什么？（-C-）" class="headerlink" title="245. 下面代码的输出是什么？（ C ）"></a>245. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i), <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i), <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A: <em>0 1 2</em> 和 <em>0 1 2</em></li><li>B: <em>0 1 2</em> 和 <em>3 3 3</em></li><li>C: <em>3 3 3</em> 和 <em>0 1 2</em></li></ul><blockquote><p>分析：</p><p><em>JavaScript</em> 中的执行机制，<em>setTimeout</em> 为异步代码，因此在 <em>setTimeout</em> 执行时，<em>for</em> 循环已经执行完毕。</p><p>第一个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>var</em> 声明， 为全局变量，因此每一次的 <em>i++</em> 都会将全局变量 <em>i</em> 的值加 <em>1</em>，当第一个 <em>for</em> 执行完成后 <em>i</em> 的值为 <em>3</em>。所以再执行 <em>setTimeout</em> 时，输出 <em>i</em> 的值都为 <em>3</em>；</p><p>第二个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>let</em> 声明，为局部变量，因此每一次 <em>for</em> 循环时都会产生一个块级作用域，用来存储本次循环中新产生的 <em>i</em> 的值。当循环结束后，<em>setTimeout</em> 会沿着作用域链去对应的块级作用域中寻找对应的 <em>i</em> 值。</p></blockquote><h3 id="246-下面代码的输出是什么？（-B-）"><a href="#246-下面代码的输出是什么？（-B-）" class="headerlink" title="246. 下面代码的输出是什么？（ B ）"></a>246. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> shape = &#123;<br>  <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-title function_">diameter</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>;<br>  &#125;,<br>  <span class="hljs-attr">perimeter</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span><br>&#125;;<br><br>shape.<span class="hljs-title function_">diameter</span>();<br>shape.<span class="hljs-title function_">perimeter</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>20</em> 和 <em>62.83185307179586</em></li><li>B: <em>20</em> 和 <em>NaN</em></li><li>C: <em>20</em> 和 <em>63</em></li><li>D: <em>NaN</em> 和 <em>63</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>diameter</em> 作为对象的方法，其内部的 <em>this</em> 指向调用该方法的对象，因此 <em>this.raduus</em> 获取到的是 <em>shape.radius</em> 的值 <em>10</em>，再乘以 <em>2</em> 输出的值即为 <em>20</em>；</p><p><em>perimeter</em> 是一个箭头函数，其内部的 <em>this</em> 应该继承声明时所在上下文中的 <em>this</em>，在这里即继承全局的 <em>this</em>，因此 <em>this.radius</em> 值的为 <em>undefined</em>，<em>undefined</em> 与数值相乘后值为 <em>NaN</em>。</p></blockquote><h3 id="247-下面代码的输出是什么？（-A-）"><a href="#247-下面代码的输出是什么？（-A-）" class="headerlink" title="247. 下面代码的输出是什么？（ A ）"></a>247. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">arduino复制代码+<span class="hljs-literal">true</span>;<br>!<span class="hljs-string">&quot;Lydia&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>A: <em>1</em> 和 <em>false</em></li><li>B: <em>false</em> 和 <em>NaN</em></li><li>C: <em>false</em> 和 <em>false</em></li></ul><blockquote><p><strong>分析：</strong></p><p>一元加号会将数据隐式转换为 <em>number</em> 类型，<em>true</em> 转换为数值为 <em>1</em>；</p><p>非运算符 <em>!</em> 会将数据隐式转换为 <em>boolean</em> 类型后进行取反，*”Lydia”* 转换为布尔值为 <em>true</em>，取反后为 <em>false</em>。</p></blockquote><h3 id="248-哪个选项是不正确的？（-A-）"><a href="#248-哪个选项是不正确的？（-A-）" class="headerlink" title="248. 哪个选项是不正确的？（ A ）"></a>248. 哪个选项是不正确的？（ <em>A</em> ）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> bird = &#123;<br>  <span class="hljs-attr">size</span>: <span class="hljs-string">&quot;small&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> mouse = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mickey&quot;</span>,<br>  <span class="hljs-attr">small</span>: <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>A: <em>mouse.bird.size</em></li><li>B: <em>mouse[bird.size]</em></li><li>C: <em>mouse[bird[“size”]]</em></li><li>D: 以上选项都对</li></ul><blockquote><p><strong>分析：</strong></p><p><em>mouse</em> 对象中没有 <em>bird</em> 属性，当访问一个对象不存在的属性时值为 <em>undefined</em>，因此 <em>mouse.bird</em> 的值为 <em>undefined</em>，而 <em>undefined</em> 作为原始数据类型没有 <em>size</em> 属性，因此再访问 <em>undefined.size</em> 时会报错。</p></blockquote><h3 id="249-下面代码的输出是什么？（-A-）"><a href="#249-下面代码的输出是什么？（-A-）" class="headerlink" title="249. 下面代码的输出是什么？（ A ）"></a>249. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> c = &#123; <span class="hljs-attr">greeting</span>: <span class="hljs-string">&quot;Hey!&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> d;<br><br>d = c;<br>c.<span class="hljs-property">greeting</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d.<span class="hljs-property">greeting</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>Hello</em></li><li>B: <em>undefined</em></li><li>C: <em>ReferenceError</em></li><li>D: <em>TypeError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>在 <em>JavaScript</em> 中，复杂类型数据在进行赋值操作时，进行的是「引用传递」，因此变量 <em>d</em> 和 <em>c</em> 指向的是同一个引用。当 <em>c</em> 通过引用去修改了数据后，<em>d</em> 再通过引用去访问数据，获取到的实际就是 <em>c</em> 修改后的数据。</p></blockquote><h3 id="250-下面代码的输出是什么？（-C-）"><a href="#250-下面代码的输出是什么？（-C-）" class="headerlink" title="250. 下面代码的输出是什么？（ C ）"></a>250. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a === b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b === c);<br></code></pre></td></tr></table></figure><ul><li>A: <em>true</em>  <em>false</em>  <em>true</em></li><li>B: <em>false</em>  <em>false</em>  <em>true</em></li><li>C: <em>true</em>  <em>false</em>  <em>false</em></li><li>D: <em>false</em>  <em>true</em>  <em>true</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>new Number()</em> 是 <em>JavaScript</em> 中一个内置的构造函数。变量 <em>b</em> 虽然看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。</p><p>&#x3D;&#x3D; 会触发隐式类型转换，右侧的对象类型会自动转换为 <em>Number</em> 类型，因此最终返回 <em>true</em>。</p><p>&#x3D;&#x3D;&#x3D; 不会触发隐式类型转换，因此在比较时由于数据类型不相等而返回 <em>false</em>。</p></blockquote><h3 id="251-下面代码的输出是什么？（-D-）"><a href="#251-下面代码的输出是什么？（-D-）" class="headerlink" title="251. 下面代码的输出是什么？（ D ）"></a>251. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Chameleon</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">colorChange</span>(<span class="hljs-params">newColor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newColor</span> = newColor;<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">&#123; newColor = <span class="hljs-string">&quot;green&quot;</span> &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newColor</span> = newColor;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> freddie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chameleon</span>(&#123; <span class="hljs-attr">newColor</span>: <span class="hljs-string">&quot;purple&quot;</span> &#125;);<br>freddie.<span class="hljs-title function_">colorChange</span>(<span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>orange</em></li><li>B: <em>purple</em></li><li>C: <em>green</em></li><li>D: <em>TypeError</em></li></ul><blockquote><p><strong>分析</strong>：</p><p><em>colorChange</em> 方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于 <em>freddie</em> 是一个子级对象，函数不会传递，所以在 <em>freddie</em> 实例上不存在 <em>colorChange</em> 方法：抛出<em>TypeError</em>。</p></blockquote><h3 id="252-下面代码的输出是什么？（-A-）"><a href="#252-下面代码的输出是什么？（-A-）" class="headerlink" title="252. 下面代码的输出是什么？（ A ）"></a>252. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> greeting;<br>greetign = &#123;&#125;; <span class="hljs-comment">// Typo!</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greetign);<br></code></pre></td></tr></table></figure><ul><li>A: <em>{}</em></li><li>B: <em>ReferenceError: greetign is not defined</em></li><li>C: <em>undefined</em></li></ul><blockquote><p><strong>分析：</strong></p><p>控制台会输出空对象，因为我们刚刚在全局对象上创建了一个空对象！</p><p>当我们错误地将 <em>greeting</em> 输入为 <em>greetign</em> 时，<em>JS</em> 解释器实际上在浏览器中将其视为 *window.greetign &#x3D; {}*。</p></blockquote><h3 id="253-当我们执行以下代码时会发生什么？（-A-）"><a href="#253-当我们执行以下代码时会发生什么？（-A-）" class="headerlink" title="253. 当我们执行以下代码时会发生什么？（ A ）"></a>253. 当我们执行以下代码时会发生什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>&#125;<br><br>bark.<span class="hljs-property">animal</span> = <span class="hljs-string">&quot;dog&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>A 什么都不会发生</li><li>B: <em>SyntaxError. You cannot add properties to a function this way.</em></li><li>C: <em>undefined</em></li><li>D: <em>ReferenceError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>因为函数也是对象！（原始类型之外的所有东西都是对象）</p><p>函数是一种特殊类型的对象，我们可以给函数添加属性，且此属性是可调用的。</p></blockquote><h3 id="254-下面代码的输出是什么？（-A-）"><a href="#254-下面代码的输出是什么？（-A-）" class="headerlink" title="254. 下面代码的输出是什么？（ A ）"></a>254. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName;<br>&#125;<br><br><span class="hljs-keyword">const</span> member = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lydia&quot;</span>, <span class="hljs-string">&quot;Hallie&quot;</span>);<br><span class="hljs-title class_">Person</span>.<span class="hljs-property">getFullName</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(member.<span class="hljs-title function_">getFullName</span>());<br></code></pre></td></tr></table></figure><ul><li>A: <em>TypeError</em></li><li>B: <em>SyntaxError</em></li><li>C: <em>Lydia Hallie</em></li><li>D: <em>undefined</em>  <em>undefined</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>Person.getFullName</em> 是将方法添加到了函数身上，因此当我们通过实例对象 <em>member</em> 去调用该方法时并不能找到该方法。</p></blockquote><h3 id="255-下面代码的输出是什么？（-A-）"><a href="#255-下面代码的输出是什么？（-A-）" class="headerlink" title="255. 下面代码的输出是什么？（ A ）"></a>255. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName;<br>&#125;<br><br><span class="hljs-keyword">const</span> lydia = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Lydia&quot;</span>, <span class="hljs-string">&quot;Hallie&quot;</span>);<br><span class="hljs-keyword">const</span> sarah = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sarah&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lydia);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sarah);<br></code></pre></td></tr></table></figure><ul><li>A: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>undefined</em></li><li>B: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>Person { firstName: “Sarah”, lastName: “Smith” }</em></li><li>C: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>{}</em></li><li>D: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>ReferenceError</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>lydia</em> 是调用构造函数后得到的实例对象，拥有 <em>firstName</em> 和 <em>lastName</em> 属性；</p><p><em>sarah</em> 是调用普通函数后得到的返回值，而 <em>Person</em> 作为普通函数没有返回值；</p></blockquote><h3 id="256-事件传播的三个阶段是什么？（-D-）"><a href="#256-事件传播的三个阶段是什么？（-D-）" class="headerlink" title="256. 事件传播的三个阶段是什么？（ D ）"></a>256. 事件传播的三个阶段是什么？（ <em>D</em> ）</h3><ul><li>A: 目标 &gt; 捕获 &gt; 冒泡</li><li>B: 冒泡 &gt; 目标 &gt; 捕获</li><li>C: 目标 &gt; 冒泡 &gt; 捕获</li><li>D: 捕获 &gt; 目标 &gt; 冒泡</li></ul><h3 id="257-下面代码的输出是什么？（-C-）"><a href="#257-下面代码的输出是什么？（-C-）" class="headerlink" title="257. 下面代码的输出是什么？（ C ）"></a>257. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>NaN</em></li><li>B: <em>TypeError</em></li><li>C: <em>“12”</em></li><li>D: <em>3</em></li></ul><blockquote><p><strong>分析：</strong></p><p>任意数据类型在跟 <em>String</em> 做 + 运算时，都会隐式转换为 <em>String</em> 类型。</p><p>即 <em>a</em> 所对应的 <em>Number</em> 值 <em>1</em>，被隐式转换为了 <em>String</em> 值 “1”，最终字符串拼接的到 “12”。</p></blockquote><h3 id="258-下面代码的输出是什么？（-C-）"><a href="#258-下面代码的输出是什么？（-C-）" class="headerlink" title="258. 下面代码的输出是什么？（ C ）"></a>258. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number++);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++number);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number);<br></code></pre></td></tr></table></figure><ul><li>A: <em>1  1  2</em></li><li>B: <em>1  2  2</em></li><li>C: <em>0  2  2</em></li><li>D: <em>0  1  2</em></li></ul><blockquote><p><strong>分析：</strong></p><p>++ 后置时，先输出，后加 <em>1</em>；++ 前置时，先加 <em>1</em>，后输出；</p><p>第一次输出的值为 0，输出完成后 <em>number</em> 加 <em>1</em> 变为 <em>1</em>。</p><p>第二次输出，<em>number</em> 先加 <em>1</em> 变为 <em>2</em>，然后输出值 <em>2</em>。</p><p>第三次输出，<em>number</em> 值没有变化，还是 <em>2</em>。</p></blockquote><h3 id="259-下面代码的输出是什么？（-B-）"><a href="#259-下面代码的输出是什么？（-B-）" class="headerlink" title="259. 下面代码的输出是什么？（ B ）"></a>259. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">getPersonInfo</span>(<span class="hljs-params">one, two, three</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(two);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(three);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-string">&quot;Lydia&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">21</span>;<br><br>getPersonInfo<span class="hljs-string">`<span class="hljs-subst">$&#123;person&#125;</span> is <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>;<br></code></pre></td></tr></table></figure><ul><li>A: <em>Lydia</em>   <em>21</em>   <em>[“”, “is”, “years old”]</em></li><li>B:  <em>[“”, “is”, “years old”]</em>  <em>Lydia</em>   <em>21</em></li><li>C:  <em>Lydia</em>  <em>[“”, “is”, “years old”]</em>    <em>21</em></li></ul><blockquote><p><strong>分析：</strong></p><p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！</p></blockquote><h3 id="260-下面代码的输出是什么？（-C-）"><a href="#260-下面代码的输出是什么？（-C-）" class="headerlink" title="260. 下面代码的输出是什么？（ C ）"></a>260. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">if</span> (data === &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;You are an adult!&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data == &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;You are still an adult.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hmm.. You don&#x27;t have an age I guess`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">checkAge</span>(&#123; <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;);<br></code></pre></td></tr></table></figure><ul><li>A: <em>You are an adult!</em></li><li>B: <em>You are still an adult.</em></li><li>C: <em>Hmm.. You don’t have an age I guess</em></li></ul><blockquote><p><strong>分析：</strong></p><p>在比较相等性时，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。</p><p><em>data</em> 和条件中的 <em>{ age: 18 }</em> 两个不同引用的对象，因此永远都不相等。</p></blockquote><h3 id="261-下面代码的输出是什么？（-C-）"><a href="#261-下面代码的输出是什么？（-C-）" class="headerlink" title="261. 下面代码的输出是什么？（ C ）"></a>261. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> args);<br>&#125;<br><br><span class="hljs-title function_">getAge</span>(<span class="hljs-number">21</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>“number”</em></li><li>B: <em>“array”</em></li><li>C: <em>“object”</em></li><li>D: <em>“NaN”</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>ES6</em> 中的不定参数（…<em>args</em>）返回的是一个数组。</p><p><em>typeof</em> 检查数组的类型返回的值是 <em>object</em>。</p></blockquote><h3 id="262-下面代码的输出是什么？（-C-）"><a href="#262-下面代码的输出是什么？（-C-）" class="headerlink" title="262. 下面代码的输出是什么？（ C ）"></a>262. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-string">&quot;use strict&quot;</span>;<br>  age = <span class="hljs-number">21</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<br>&#125;<br><br><span class="hljs-title function_">getAge</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>21</em></li><li>B: <em>undefined</em></li><li>C: <em>ReferenceError</em></li><li>D: <em>TypeError</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>“use strict”</em> 严格模式中，使用未声明的变量会引发报错。</p></blockquote><h3 id="263-下面代码的输出是什么？（-A-）"><a href="#263-下面代码的输出是什么？（-A-）" class="headerlink" title="263. 下面代码的输出是什么？（ A ）"></a>263. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;10*10+5&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>105</em></li><li>B: <em>“105”</em></li><li>C: <em>TypeError</em></li><li>D: <em>“10*10+5”</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>eval</em> 方法会将字符串当作 <em>JavaScript</em> 代码进行解析。</p></blockquote><h3 id="264-cool-secret-可以访问多长时间？（-B-）"><a href="#264-cool-secret-可以访问多长时间？（-B-）" class="headerlink" title="264. cool_secret 可以访问多长时间？（ B ）"></a>264. <em>cool_secret</em> 可以访问多长时间？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;cool_secret&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><ul><li>A：永远，数据不会丢失。</li><li>B：用户关闭选项卡时。</li><li>C：当用户关闭整个浏览器时，不仅是选项卡。</li><li>D：用户关闭计算机时。</li></ul><blockquote><p><strong>分析：</strong></p><p><em>sessionStorage</em> 是会话级别的本地存储，当窗口关闭，则会话结束，数据删除。</p></blockquote><h3 id="265-下面代码的输出是什么？（-B-）"><a href="#265-下面代码的输出是什么？（-B-）" class="headerlink" title="265. 下面代码的输出是什么？（ B ）"></a>265. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> num = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br></code></pre></td></tr></table></figure><ul><li>A: <em>8</em></li><li>B: <em>10</em></li><li>C: <em>SyntaxError</em></li><li>D: <em>ReferenceError</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>var</em> 声明的变量允许重复声明，但后面的值会覆盖前面的值。</p></blockquote><h3 id="266-下面代码的输出是什么？（-C-）"><a href="#266-下面代码的输出是什么？（-C-）" class="headerlink" title="266. 下面代码的输出是什么？（ C ）"></a>266. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><br>obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>false</em>  <em>true</em>  <em>false</em>  <em>true</em></li><li>B: <em>false</em>  <em>true</em>  <em>true</em>  <em>true</em></li><li>C: <em>true</em>  <em>true</em>  <em>false</em>  <em>true</em></li><li>D: <em>true</em>  <em>true</em>  <em>true</em>  <em>true</em></li></ul><h3 id="267-下面代码的输出是什么？（-C-）"><a href="#267-下面代码的输出是什么？（-C-）" class="headerlink" title="267. 下面代码的输出是什么？（ C ）"></a>267. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;three&quot;</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>A: <em>{ a: “one”, b: “two” }</em></li><li>B: <em>{ b: “two”, a: “three” }</em></li><li>C: <em>{ a: “three”, b: “two” }</em></li><li>D: <em>SyntaxError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>如果对象有两个具有相同名称的键，则后面的将替前面的键。它仍将处于第一个位置，但具有最后指定的值。</p></blockquote><h3 id="268-下面代码的输出是什么？（-C-）"><a href="#268-下面代码的输出是什么？（-C-）" class="headerlink" title="268. 下面代码的输出是什么？（ C ）"></a>268. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A: <em>1  2</em></li><li>B: <em>1  2  3</em></li><li>C: <em>1  2  4</em></li><li>D: <em>1  3  4</em></li></ul><blockquote><p><strong>分析：</strong></p><p>当 <em>i</em> 的值为 <em>3</em> 时，进入 <em>if</em> 语句执行 <em>continue</em>，结束本次循环，立即进行下一次循环。</p></blockquote><h3 id="269-下面代码的输出是什么？（-A-）"><a href="#269-下面代码的输出是什么？（-A-）" class="headerlink" title="269. 下面代码的输出是什么？（ A ）"></a>269. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">giveLydiaPizza</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Just give Lydia pizza already!&quot;</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Lydia&quot;</span>;<br><br>name.<span class="hljs-title function_">giveLydiaPizza</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>“Just give Lydia pizza already!”</em></li><li>B: <em>TypeError: not a function</em></li><li>C: <em>SyntaxError</em></li><li>D: <em>undefined</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>String</em> 是一个内置的构造函数，我们可以为它添加属性。 我们给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！</p><p>当使用基本类型的字符串调用 <em>giveLydiaPizza</em> 时，实际上发生了下面的过程：</p><ul><li>创建一个 <em>String</em> 的包装类型实例</li><li>在实例上调用 <em>substring</em> 方法</li><li>销毁实例</li></ul></blockquote><h3 id="270-下面代码的输出是什么？（-B-）"><a href="#270-下面代码的输出是什么？（-B-）" class="headerlink" title="270. 下面代码的输出是什么？（ B ）"></a>270. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> a = &#123;&#125;;<br><span class="hljs-keyword">const</span> b = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;b&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> c = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;;<br><br>a[b] = <span class="hljs-number">123</span>;<br>a[c] = <span class="hljs-number">456</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[b]);<br></code></pre></td></tr></table></figure><ul><li>A: <em>123</em></li><li>B: <em>456</em></li><li>C: <em>undefined</em></li><li>D: <em>ReferenceError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>当 <em>b</em> 和 <em>c</em> 作为一个对象的键时，会自动转换为字符串，而对象自动转换为字符串化时，结果都为 *[Object object]*。因此 <em>a[b]</em> 和 <em>a[c]</em> 其实都是同一个属性 *a[“Object object”]*。</p><p>对象同名的属性后面的值会覆盖前面的，因此最终 <em>a[“Object object”]</em> 的值为 <em>456</em>。</p></blockquote><h3 id="271-下面代码的输出是什么？（-B-）"><a href="#271-下面代码的输出是什么？（-B-）" class="headerlink" title="271. 下面代码的输出是什么？（ B ）"></a>271. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;First&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bar</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Second&quot;</span>));<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">baz</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Third&quot;</span>);<br><br><span class="hljs-title function_">bar</span>();<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">baz</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>First</em>  <em>Second</em>  <em>Third</em></li><li>B: <em>First</em>  <em>Third</em>  <em>Second</em></li><li>C: <em>Second</em>  <em>First</em>  <em>Third</em></li><li>D: <em>Second</em>  <em>Third</em>  <em>First</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>bar</em> 函数中执行的是一段异步代码，按照 <em>JavaScript</em> 中的事件循环机制，主线程中的所有同步代码执行完成后才会执行异步代码。因此 <em>“Second”</em> 最后输出。</p></blockquote><h3 id="272-单击按钮时-event-target-是什么？（-C-）"><a href="#272-单击按钮时-event-target-是什么？（-C-）" class="headerlink" title="272. 单击按钮时 event.target 是什么？（ C ）"></a>272. 单击按钮时 <em>event.target</em> 是什么？（ <em>C</em> ）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;first div&#x27;)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;second div&#x27;)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;button&#x27;)&quot;</span>&gt;</span><br>      Click!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>A: <em>div</em> 外部</li><li>B: <em>div</em> 内部</li><li>C: <em>button</em></li><li>D: 所有嵌套元素的数组</li></ul><blockquote><p><strong>分析：</strong></p><p><em>event.target</em> 指向的是事件目标，即触发事件的元素。因此点击 <em><button></button></em> 触发事件的也就是  *<button>*。</button></p></blockquote><h3 id="273-单击下面的-html-片段打印的内容是什么？（-A-）"><a href="#273-单击下面的-html-片段打印的内容是什么？（-A-）" class="headerlink" title="273. 单击下面的 html 片段打印的内容是什么？（ A ）"></a>273. 单击下面的 <em>html</em> 片段打印的内容是什么？（ <em>A</em> ）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;div&#x27;)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;p&#x27;)&quot;</span>&gt;</span><br>    Click here!<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>A: <em>p</em>  <em>div</em></li><li>B: <em>div</em>  <em>p</em></li><li>C: <em>p</em></li><li>D: <em>div</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>onclick</em> 绑定的事件为冒泡型事件。因此当点击 <em>p</em> 标签时，事件会从事件目标开始依次往外触发。</p></blockquote><h3 id="274-下面代码的输出是什么？（-D-）"><a href="#274-下面代码的输出是什么？（-D-）" class="headerlink" title="274. 下面代码的输出是什么？（ D ）"></a>274. 下面代码的输出是什么？（ <em>D</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Lydia&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> is <span class="hljs-subst">$&#123;age&#125;</span>`</span>);<br>&#125;<br><br>sayHi.<span class="hljs-title function_">call</span>(person, <span class="hljs-number">21</span>);<br>sayHi.<span class="hljs-title function_">bind</span>(person, <span class="hljs-number">21</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>undefined is 21</em>   <em>Lydia is 21</em></li><li>B: <em>function</em>   <em>function</em></li><li>C: <em>Lydia is 21</em>   <em>Lydia is 21</em></li><li>D: <em>Lydia is 21</em>   <em>function</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>call</em> 和 <em>bind</em> 都可以修改 <em>this</em> 的指向，但区别在于 <em>call</em> 方法会立即执行，而 <em>bind</em> 会返回一个修改后的新函数。</p></blockquote><h3 id="275-下面代码的输出是什么？（-B-）"><a href="#275-下面代码的输出是什么？（-B-）" class="headerlink" title="275. 下面代码的输出是什么？（ B ）"></a>275. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span>)();<br>&#125;<br><br><span class="hljs-keyword">typeof</span> <span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><ul><li>A: <em>“object”</em></li><li>B: <em>“number”</em></li><li>C: <em>“function”</em></li><li>D: <em>“undefined”</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>return</em> 后是一个 <em>IIFE</em>，其返回值是 <em>0</em>，因此 <em>sayHi</em> 函数中返回的是一个 <em>0</em>。<em>typeof</em> 检测 <em>sayHi</em> 返回值类型即为 <em>number</em>。</p></blockquote><h3 id="276-下面这些值哪些是假值？（-A-）"><a href="#276-下面这些值哪些是假值？（-A-）" class="headerlink" title="276. 下面这些值哪些是假值？（ A ）"></a>276. 下面这些值哪些是假值？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-number">0</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">0</span>);<br>(<span class="hljs-string">&quot;&quot;</span>);<br>(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><ul><li>A: <em>0</em>   <em>“”</em>    <em>undefined</em></li><li>B: <em>0</em>   <em>new Number(0)</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li><li>C: <em>0</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li><li>D: 所有都是假值。</li></ul><blockquote><p><strong>分析：</strong></p><p><em>JavaScript</em> 中假值只有 <em>6</em> 个：<em>false</em>、*””<em>、</em>null<em>、</em>undefined<em>、</em>NaN<em>、</em>0*</p></blockquote><h3 id="278-下面代码的输出是什么？（-B-）"><a href="#278-下面代码的输出是什么？（-B-）" class="headerlink" title="278. 下面代码的输出是什么？（ B ）"></a>278. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>“number”</em></li><li>B: <em>“string”</em></li><li>C: <em>“object”</em></li><li>D: <em>“undefined”</em></li></ul><blockquote><p>分析：</p><p><em>typeof 1</em> 返回 <em>“number”<em>，</em>typeof “number”</em> 返回 <em>“string”</em></p></blockquote><h3 id="279-下面代码的输出是什么？（-C-）"><a href="#279-下面代码的输出是什么？（-C-）" class="headerlink" title="279. 下面代码的输出是什么？（ C ）"></a>279. 下面代码的输出是什么？（ <em>C</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>numbers[<span class="hljs-number">10</span>] = <span class="hljs-number">11</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers);<br></code></pre></td></tr></table></figure><ul><li>A: <em>[1, 2, 3, 7 x null, 11]</em></li><li>B: <em>[1, 2, 3, 11]</em></li><li>C: <em>[1, 2, 3, 7 x empty, 11]</em></li><li>D: <em>SyntaxError</em></li></ul><blockquote><p><strong>分析：</strong></p><p>当你为数组中的元素设置一个超过数组长度的值时，<em>JavaScript</em> 会创建一个名为“空插槽”的东西。 这些位置的值实际上是 <em>undefined</em>，但你会看到类似的东西：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">csharp<br>复制代码[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span> x empty, <span class="hljs-number">11</span>]<br></code></pre></td></tr></table></figure><p>这取决于你运行它的位置（每个浏览器有可能不同）。</p></blockquote><h3 id="280-下面代码的输出是什么？（-A-）"><a href="#280-下面代码的输出是什么？（-A-）" class="headerlink" title="280. 下面代码的输出是什么？（ A ）"></a>280. 下面代码的输出是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> x, y;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (x) &#123;<br>    (x = <span class="hljs-number">1</span>), (y = <span class="hljs-number">2</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);<br>&#125;)();<br></code></pre></td></tr></table></figure><ul><li>A: <em>1</em>   <em>undefined</em>   <em>2</em></li><li>B: <em>undefined</em>   <em>undefined</em>   <em>undefined</em></li><li>C: <em>1</em>   <em>1</em>   <em>2</em></li><li>D: <em>1</em>   <em>undefined</em>   <em>undefined</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>catch</em> 块接收参数 <em>x</em>。当我们传递参数时，这与变量的 <em>x</em> 不同。这个变量 <em>x</em> 是属于 <em>catch</em> 作用域的。</p><p>之后，我们将这个块级作用域的变量设置为 <em>1</em>，并设置变量 <em>y</em> 的值。 现在，我们打印块级作用域的变量 <em>x</em>，它等于 <em>1</em>。</p><p>在<em>catch</em> 块之外，<em>x</em> 仍然是 <em>undefined</em>，而 <em>y</em> 是 <em>2</em>。 当我们想在 <em>catch</em> 块之外的 <em>console.log(x)</em> 时，它返回<em>undefined</em>，而 <em>y</em> 返回 <em>2</em>。</p></blockquote><h3 id="281-JavaScript-中的所有内容都是…（-A-）"><a href="#281-JavaScript-中的所有内容都是…（-A-）" class="headerlink" title="281. JavaScript 中的所有内容都是…（ A ）"></a>281. <em>JavaScript</em> 中的所有内容都是…（ <em>A</em> ）</h3><ul><li>A：原始或对象</li><li>B：函数或对象</li><li>C：技巧问题！只有对象</li><li>D：数字或对象</li></ul><blockquote><p>分析：</p><p><em>JavaScript</em> 只有原始类型和对象。</p></blockquote><h3 id="282-下面代码的输出是什么"><a href="#282-下面代码的输出是什么" class="headerlink" title="282. 下面代码的输出是什么?"></a>282. 下面代码的输出是什么?</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]].<span class="hljs-title function_">reduce</span>(<br>  <span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> acc.<span class="hljs-title function_">concat</span>(cur);<br>  &#125;,<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>);<br></code></pre></td></tr></table></figure><ul><li>A: <em>[0, 1, 2, 3, 1, 2]</em></li><li>B: <em>[6, 1, 2]</em></li><li>C: <em>[1, 2, 0, 1, 2, 3]</em></li><li>D: <em>[1, 2, 6]</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>[1,2]</em> 是我们的初始值。 这是我们开始执行 <em>reduce</em> 函数的初始值，以及第一个 <em>acc</em> 的值。 在第一轮中，<em>acc</em> 是 <em>[1,2]<em>，</em>cur</em> 是 *[0,1]*。 我们将它们连接起来，结果是 *[1,2,0,1]*。</p><p>然后，<em>acc</em> 的值为 <em>[1,2,0,1]<em>，</em>cur</em> 的值为 *[2,3]*。 我们将它们连接起来，得到 *[1,2,0,1,2,3]*。</p></blockquote><h3 id="283-下面代码的输出是什么？（-B-）"><a href="#283-下面代码的输出是什么？（-B-）" class="headerlink" title="283. 下面代码的输出是什么？（ B ）"></a>283. 下面代码的输出是什么？（ <em>B</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码!!<span class="hljs-literal">null</span>;<br>!!<span class="hljs-string">&quot;&quot;</span>;<br>!!<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>A: <em>false</em>   <em>true</em>   <em>false</em></li><li>B: <em>false</em>   <em>false</em>   <em>true</em></li><li>C: <em>false</em>   <em>true</em>   <em>true</em></li><li>D: <em>true</em>   <em>true</em>   <em>false</em></li></ul><blockquote><p><strong>分析：</strong></p><p><em>null</em> 是假值。 <em>!null</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p><p><em>“”</em> 是假值。 <em>!””</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p><p><em>1</em> 是真值。 <em>!1</em> 返回 <em>false</em>。 <em>!false</em> 返回 <em>true</em>。</p></blockquote><h3 id="284-setInterval-方法的返回值什么？（-A-）"><a href="#284-setInterval-方法的返回值什么？（-A-）" class="headerlink" title="284. setInterval 方法的返回值什么？（ A ）"></a>284. <em>setInterval</em> 方法的返回值什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><ul><li>A：一个唯一的 <em>id</em></li><li>B：指定的毫秒数</li><li>C：传递的函数</li><li>D：<em>undefined</em></li></ul><blockquote><p><strong>分析：</strong></p><p>它返回一个唯一的 <em>id</em>。 此 <em>id</em> 可用于使用 <em>clearInterval()</em> 函数清除该定时器。</p></blockquote><h3 id="285-下面代码的返回值是什么？（-A-）"><a href="#285-下面代码的返回值是什么？（-A-）" class="headerlink" title="285. 下面代码的返回值是什么？（ A ）"></a>285. 下面代码的返回值是什么？（ <em>A</em> ）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码[...<span class="hljs-string">&quot;Lydia&quot;</span>];<br></code></pre></td></tr></table></figure><ul><li>A: <em>[“L”, “y”, “d”, “i”, “a”]</em></li><li>B: <em>[“Lydia”]</em></li><li>C: <em>[[], “Lydia”]</em></li><li>D: <em>[[“L”, “y”, “d”, “i”, “a”]]</em></li></ul><blockquote><p><strong>分析：</strong></p><p>字符串是可迭代的。 扩展运算符将迭代的每个字符映射到一个元素。</p></blockquote><h3 id="286-document-write-和-innerHTML-有哪些区别？"><a href="#286-document-write-和-innerHTML-有哪些区别？" class="headerlink" title="286. document.write 和 innerHTML 有哪些区别？"></a>286. <em>document.write</em> 和 <em>innerHTML</em> 有哪些区别？</h3><blockquote><p>参考答案：</p><p><em>document.write</em> 和 <em>innerHTML</em> 都能将 <em>HTML</em> 字符串解析为 <em>DOM</em> 树，再将 <em>DOM</em> 树插入到某个位置，但两种在执行细节上还是有许多不同。</p><p>1）<em>write()</em> 方法存在于 <em>Document</em> 对象中，<em>innerHTML</em> 属性存在于 <em>Element</em> 对象中；</p><p>2）<em>document.write</em> 会将解析后的 <em>DOM</em> 树插入到文档中调用它的脚本元素的位置，而 <em>innerHTML</em> 会将 <em>DOM</em> 树插入到指定的元素内；</p><p>3）<em>document.write</em> 会将多次调用的字符串参数自动连接起来，<em>innerHTML</em> 要用赋值运算符 <em>“+&#x3D;”</em> 拼接；</p><p>4）只有当文档还在解析时，才能使用 <em>document.write</em>，否则 <em>document.write</em> 的值会将当前文档覆盖掉，而 <em>innerHTML</em> 属性则没有这个限制；</p></blockquote><blockquote><p>注：也可以参阅前面第 <em>157</em> 题答案</p></blockquote><h3 id="287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？"><a href="#287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？" class="headerlink" title="287. 假设有两个变量 a 和 b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？"></a>287. 假设有两个变量 <em>a</em> 和 <em>b</em>，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？</h3><blockquote><p>参考答案：</p><p>方法一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码a = a + b;<br>b = a - b;<br>a = a - b; <br></code></pre></td></tr></table></figure><p>方法二（<em>ES6</em> 中的解构）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码[a, b] = [b, a]<br></code></pre></td></tr></table></figure></blockquote><h3 id="288-前端为什么提倡模块化开发？"><a href="#288-前端为什么提倡模块化开发？" class="headerlink" title="288. 前端为什么提倡模块化开发？"></a>288. 前端为什么提倡模块化开发？</h3><blockquote><p>参考答案：</p><p>模块化能将一个复杂的大型系统分解成一个个高内聚、低耦合的简单模块，并且每个模块都是独立的，用于完成特定的功能。模块化后的系统变得更加可控、可维护、可扩展，程序代码也更简单直观，可读性也很高，有利于团队协作开发。<em>ES6</em> 模块化的出现，使得前端能更容易、更快速的实现模块化开发。</p></blockquote><h3 id="289-请解释-JSONP-的原理，并用代码描述其过程。"><a href="#289-请解释-JSONP-的原理，并用代码描述其过程。" class="headerlink" title="289. 请解释 JSONP 的原理，并用代码描述其过程。"></a>289. 请解释 <em>JSONP</em> 的原理，并用代码描述其过程。</h3><blockquote><p>参考答案：</p><p><em>JSONP（JSON with padding）</em>是一种借助 <em><script></em> 元素实现跨域的技术，它不会使用 <em>XHR</em> 对象。之所以能实现跨域，主要是因为 <em><script></em> 元素有以下两个特点：</p><p>1）它的 <em>src</em> 属性能够访问任何 <em>URL</em> 资源，不会受同源策略的限制；</p><p>2）如果访问的资源包含 <em>JavaScript</em> 代码，那么在下载下来后会自动执行；</p><p><em>JSONP</em> 就是基于这两点，再与服务器配合来实现跨域请求的，它的执行步骤可分为以下 <em>6</em> 步：</p><p>1）定义一个回调函数；</p><p>2）用 <em>DOM</em> 方法动态创建一个 <em><script></em> 元素；</p><p>3）通过 <em><script></em> 元素的 <em>src</em> 属性指定要请求的 <em>URL</em>，并且将回调函数的名称作为一个参数传递过去；</p><p>4）将 <em><script></em> 元素插入到当前文档中，开始请求；</p><p>5）服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式输出；</p><p>6）当 <em><script></em> 元素接收到响应中的脚本代码后，就会自动的执行它们；</p></blockquote><h3 id="290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。"><a href="#290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。" class="headerlink" title="290. 列举几种 JavaScript 中数据类型的强制转换和隐式转换。"></a>290. 列举几种 <em>JavaScript</em> 中数据类型的强制转换和隐式转换。</h3><blockquote><p>参考答案：</p><p>强制转换：</p><ul><li>转换为 <em>number</em>：<em>parseInt()<em>、</em>parseFloat()<em>、</em>Number()</em></li><li>转换为 <em>string</em>：<em>String()<em>、</em>toString()</em></li><li>转换为 <em>boolean</em>：<em>Boolean()</em></li></ul><p>隐式转换：</p><ul><li>隐式转换为 <em>number</em>：算术运算/比较运算，例如加、减、乘、除、相等（==）、大于、小于等；</li><li>隐式转换为 <em>string</em>：与字符串拼接，例如 + ""；</li><li>隐式转换为 <em>boolean</em>：逻辑运算，例如或（||）、与（&&）、非（!）；</li></ul></blockquote><h3 id="291-分析以下代码的执行结果并解释为什么。"><a href="#291-分析以下代码的执行结果并解释为什么。" class="headerlink" title="291. 分析以下代码的执行结果并解释为什么。"></a>291. 分析以下代码的执行结果并解释为什么。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> b = a;<br>a.<span class="hljs-property">x</span> = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">x</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">x</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>运行结果：</p><p><em>undefined</em>、*{n: 2}*</p><p>分析：</p><p>首先，<em>a</em> 和 <em>b</em> 同时引用了 <em>{n: 1}</em> 对象，接着执行到 <em>a.x = a = {n: 2}</em> 语句，虽然赋值是从右到左执行，但是点（.）的优先级比赋值符（=）要高，所以这里首先执行 <em>a.x</em>，相当于为 <em>a</em>（或者 <em>b</em>）所指向的 <em>{n:1}</em> 对象新增了一个属性 <em>x</em>，即此时对象将变为 *{n: 1; x: undefined}*。然后按正常情况，从右到左进行赋值，此时执行 <em>a = {n: 2}</em> 的时候，a的引用改变，指向了新对象 *{n: 2}*，而 <em>b</em> 依然指向的是旧对象 *{n: 1; x: undefined}*。之后再执行 <em>a.x = {n: 2}</em> 的时候，并不会重新解析一遍 <em>a</em>，而是沿用最初解析 <em>a.x</em> 时候的 <em>a</em>，即旧对象 *{n: 1; x: undefined}<em>，故此时旧对象的 <em>x</em> 的值变为</em>{n: 2}*，旧对象为 *{n: 1; x: {n: 2}}*，它依然被 <em>b</em> 引用着。</p><p>最后，<em>a</em> 指向的对象为  <em>{n: 2}<em>，</em>b</em> 指向的对象为 *{n: 1; x: {n: 2}}*。因此输出 <em>a.x</em> 值为 <em>undefined</em>，输出 <em>b.x</em> 值为 *{n: 2}*。</p></blockquote><h3 id="292-分析以下代码的执行结果并解释为什么。"><a href="#292-分析以下代码的执行结果并解释为什么。" class="headerlink" title="292. 分析以下代码的执行结果并解释为什么。"></a>292. 分析以下代码的执行结果并解释为什么。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// example 1</span><br><span class="hljs-keyword">var</span> a = &#123;&#125;, b = <span class="hljs-string">&#x27;123&#x27;</span>, c = <span class="hljs-number">123</span>;  <br>a[b] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>a[c] = <span class="hljs-string">&#x27;c&#x27;</span>;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[b]);<br><br><span class="hljs-comment">// example 2</span><br><span class="hljs-keyword">var</span> a = &#123;&#125;, b = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;123&#x27;</span>), c = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;123&#x27;</span>);  <br>a[b] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>a[c] = <span class="hljs-string">&#x27;c&#x27;</span>;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[b]);<br><br><span class="hljs-comment">// example 3</span><br><span class="hljs-keyword">var</span> a = &#123;&#125;, b = &#123;<span class="hljs-attr">key</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;, c = &#123;<span class="hljs-attr">key</span>:<span class="hljs-string">&#x27;456&#x27;</span>&#125;;  <br>a[b] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>a[c] = <span class="hljs-string">&#x27;c&#x27;</span>;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[b]);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>运行结果：</p><p><em>example 1</em>：<em>c</em></p><p><em>example 2</em>：<em>b</em></p><p><em>example 3</em>：<em>c</em></p><p>分析：</p><p>这题考察的是对象的键名的转换。</p><ul><li>对象的键名只能是字符串和 <em>Symbol</em> 类型。</li><li>其他类型的键名会被转换成字符串类型。</li><li>对象转字符串默认会调用 <em>String</em> 方法。</li></ul><p>因此 <em>example 1</em> 中 <em>c</em> 作为键名后也是 <em>'123'<em>，直接覆盖 <em>a[b]</em> 的值；而 <em>example 2</em> 中，</em>Symbol</em> 作为 <em>ES6</em> 中新增的基本数据类型，它的特点就是唯一，<em>Symbol()</em> 方法生成的值都是唯一的，里面的参数不会影响结果。因此在 <em>example 2</em> 中 <em>b</em> 和 <em>c</em> 是两个不同的键名；<em>example 3</em> 中，对象不能作为键名，因此 <em>b</em> 和 <em>c</em> 都会通过 <em>String()</em> 方法转为字符串 *[object Object]*。</p></blockquote><h3 id="293-下面的代码打印什么内容？为什么？"><a href="#293-下面的代码打印什么内容？为什么？" class="headerlink" title="293. 下面的代码打印什么内容？为什么？"></a>293. 下面的代码打印什么内容？为什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>  b = <span class="hljs-number">20</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br>&#125;)()<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>运行结果：</p><p><em>function b() { b = 20; console.log(b) }</em> 分析：</p><p>当 <em>JavaScript</em> 解释器遇到非匿名立即执行函数（题目中的 <em>b</em>）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 <em>b</em>，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p></blockquote><h3 id="294-下面代码中，a-在什么情况下会执行输出语句打印-1-？"><a href="#294-下面代码中，a-在什么情况下会执行输出语句打印-1-？" class="headerlink" title="294. 下面代码中，a 在什么情况下会执行输出语句打印 1 ？"></a>294. 下面代码中，<em>a</em> 在什么情况下会执行输出语句打印 <em>1</em> ？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> a = ?;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>分析：</p><p>这道题考查的知识点是：相等运算符（==）在作比较时会进行隐式转换，而如果操作数是引用类型，则会调用 <em>toString()</em> 或 <em>valueOf()</em> 方法对引用类型数据进行隐式转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 方法一：利用 toString()</span><br><span class="hljs-keyword">let</span> a = &#123;<br>  <span class="hljs-attr">i</span>: <span class="hljs-number">1</span>,<br>  toString () &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">i</span>++;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 方法二：利用 valueOf()</span><br><span class="hljs-keyword">let</span> a = &#123;<br>  <span class="hljs-attr">i</span>: <span class="hljs-number">1</span>,<br>  valueOf () &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">i</span>++<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 方法三：利用数组（这个是真的骚）</span><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.<span class="hljs-property">join</span> = a.<span class="hljs-property">shift</span>;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 方法四：利用 Symbol</span><br><span class="hljs-keyword">let</span> a = &#123;[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>]: (<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> ++i) (<span class="hljs-number">0</span>)&#125;;<br><span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法一和方法二没啥解释的了，解释下方法三和方法四。</p><p>方法三：</p><p><em>a.join = a.shift</em> 的目的是将数组的 <em>join</em> 方法替换成 <em>shift</em> 方法。因为数组在参与相等比较时也会通过 <em>toString()</em> 将数组转为字符串，而该字符串实际上是数组中每个元素的 <em>toString()</em> 返回值经调用 <em>join()</em> 方法拼接（由逗号隔开）组成。现在我们将 <em>join()</em> 方法替换为了 <em>shift()</em> 方法，也就意味着数组在通过 <em>toString()</em> 隐式转换后，得到是 <em>shift()</em> 的返回值，每次返回数组中的第一个元素，而原数组删除第一个值，正好可以使判断成立。</p><p>方法四：</p><p><em>ES6</em> 中提供了 <em>11</em> 个内置的 <em>Symbo</em> 值，指向语言内部使用的方法。<em>Symbol.toPrimitive</em> 就是其中一个，它指向一个方法，当该对象被转为原始类型的值时，会调用这个方法，并返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个闭包返回的函数。</p></blockquote><h3 id="295-介绍前端模块化的发展。"><a href="#295-介绍前端模块化的发展。" class="headerlink" title="295. 介绍前端模块化的发展。"></a>295. 介绍前端模块化的发展。</h3><blockquote><p>参考答案：</p><ul><li><p><em>IIFE</em>：使用自执行函数来编写模块化（特点：在一个单独的函数作用域中执行代码，避免变量冲突）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">data</span>:[] &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure></li><li><p><em>AMD</em>：使用 <em>requireJS</em> 来编写模块化（特点：依赖必须提前声明好）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)&#123;<br><span class="hljs-comment">// code 就是index.js 返回的内容</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><em>CMD</em>：使用 <em>seaJS</em> 来编写模块化（特点：支持动态引入依赖文件）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;  <br>  <span class="hljs-keyword">var</span> indexCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><em>CommonJS</em>：<em>nodejs</em> 中自带的模块化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p><em>UMD</em>：通用模块规范，整合了 <em>AMD</em> 和 <em>CommonJS</em> 模块化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span>, factory</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span> !== <span class="hljs-literal">undefined</span>) &#123; <span class="hljs-comment">//检查CommonJS是否可用</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) &#123;      <span class="hljs-comment">//检查AMD是否可用</span><br>    <span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;toggler&#x27;</span>, [<span class="hljs-string">&#x27;jquery&#x27;</span>, factory])<br>  &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">//两种都不能用，把模块添加到JavaScript的全局命名空间中。</span><br>    <span class="hljs-variable language_">global</span>.<span class="hljs-property">toggler</span> = <span class="hljs-title function_">factory</span>(<span class="hljs-variable language_">global</span>, factory);<br>  &#125;<br>&#125;)(<span class="hljs-variable language_">this</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">init</span>: init<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><em>webpack(require.ensure)<em>：</em>webpack 2.x</em> 版本中的代码分割。</p></li><li><p><em>ES Modules</em>： <em>ES6</em> 引入的模块化，支持 <em>import</em> 来引入另一个 <em>js</em> 。</p></li></ul></blockquote><h3 id="296-请指出-document-onload-和-document-ready-两个事件的区别"><a href="#296-请指出-document-onload-和-document-ready-两个事件的区别" class="headerlink" title="296. 请指出 document.onload 和 document.ready 两个事件的区别"></a>296. 请指出 <em>document.onload</em> 和 document.ready 两个事件的区别</h3><blockquote><p>参考答案：</p><p>页面加载完成有两种事件：一是 <em>ready</em>，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；二是 <em>onload</em>，指示页面包含图片等文件在内的所有元素都加载完成。</p></blockquote><h3 id="297-表单元素的readonly-和-disabled-两个属性有什么区别？"><a href="#297-表单元素的readonly-和-disabled-两个属性有什么区别？" class="headerlink" title="297. 表单元素的readonly 和 disabled 两个属性有什么区别？"></a>297. 表单元素的<em>readonly</em> 和 <em>disabled</em> 两个属性有什么区别？</h3><blockquote><p>参考答案：</p><ul><li><p>readonly</p><p>：</p><ul><li>不可编辑，但可以选择和复制；</li><li>值可以传递到后台；</li></ul></li><li><p>disabled：</p><ul><li>不能编辑，不能复制，不能选择；</li><li>值不可以传递到后台；</li></ul></li></ul></blockquote><h3 id="298-列举几种你知道的数组排序的方法。"><a href="#298-列举几种你知道的数组排序的方法。" class="headerlink" title="298. 列举几种你知道的数组排序的方法。"></a>298. 列举几种你知道的数组排序的方法。</h3><blockquote><p>参考答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 方法一：选择排序</span><br><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ary.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; ary.<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">if</span> (ary[i] &lt; ary[j]) &#123;<br>      [ary[i], ary[j]] = [ary[j], ary[i]];<br>    &#125;<br>  &#125;<br>&#125;<br>js复制代码<span class="hljs-comment">// 方法二：冒泡排序</span><br><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; ary.<span class="hljs-property">length</span>; i++) &#123; <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; ary.<span class="hljs-property">length</span> - i; j++) &#123;  <br>    <span class="hljs-keyword">if</span> (ary[j] &lt; ary[j + <span class="hljs-number">1</span>]) &#123;<br>      [ary[j], ary[j + <span class="hljs-number">1</span>]] = [ary[j + <span class="hljs-number">1</span>], ary[j]]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"><a href="#299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？" class="headerlink" title="299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？"></a>299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</h3><blockquote><p>参考答案：</p><ul><li>客户区坐标：鼠标指针在可视区中的水平坐标 (<em>clientX</em>) 和垂直坐标 (<em>clientY</em>)；</li><li>页面坐标：鼠标指针在页面布局中的水平坐标 (<em>pageX</em>) 和垂直坐标 (<em>pageY</em>)；</li><li>屏幕坐标：设备物理屏幕的水平坐标 (<em>screenX</em>) 和垂直坐标 (<em>screenY</em>)；</li></ul></blockquote><h3 id="300-如何编写高性能的-JavaScript？"><a href="#300-如何编写高性能的-JavaScript？" class="headerlink" title="300. 如何编写高性能的 JavaScript？"></a>300. 如何编写高性能的 <em>JavaScript</em>？</h3><blockquote><p>参考答案：</p><ul><li>遵循严格模式："use strict"</li><li>将 <em>JavaScript</em> 本放在页面底部，加快渲染页面</li><li>将 <em>JavaScript</em> 脚本将脚本成组打包，减少请求</li><li>使用非阻塞方式下载 <em>JavaScript</em> 脚本</li><li>尽量使用局部变量来保存全局变量</li><li>尽量减少使用闭包</li><li>使用 <em>window</em> 对象属性方法时，省略 <em>window</em></li><li>尽量减少对象成员嵌套</li><li>缓存 <em>DOM</em> 节点的访问</li><li>通过避免使用 <em>eval()</em> 和 <em>Function()</em> 构造器</li><li>给 <em>setTimeout()</em> 和 <em>setInterval()</em> 传递函数而不是字符串作为参数</li><li>尽量使用直接量创建对象和数组</li><li>最小化重绘 (<em>repaint</em>) 和回流 (<em>reflow</em>)</li></ul></blockquote><h3 id="301-下面的代码输出什么？"><a href="#301-下面的代码输出什么？" class="headerlink" title="301. 下面的代码输出什么？"></a>301. 下面的代码输出什么？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> &#125;<br>a.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><blockquote><p>参考答案：</p><p>10</p><p>因为会自动调用 a 函数的 <em>toString</em> 方法。</p></blockquote></script></em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github 掘金 Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Css面试题</title>
    <link href="/2022/11/23/%E6%8E%98%E9%87%91-Css/"/>
    <url>/2022/11/23/%E6%8E%98%E9%87%91-Css/</url>
    
    <content type="html"><![CDATA[<h2 id="1-px-和-em-的区别"><a href="#1-px-和-em-的区别" class="headerlink" title="1. px 和 em 的区别"></a>1. px 和 em 的区别</h2><p><strong>📢 参考回答：</strong></p><p><code>px</code>全称<code>pixel</code>像素，是相对于屏幕分辨率而言的，它是一个绝对单位，但同时具有一定的相对性。因为在同一个设备上每个像素代表的物理长度是固定不变的，这点表现的是绝对性。但是在不同的设备之间每个设备像素所代表的物理长度是可以变化的，这点表现的是相对性</p><p><code>em</code>是一个相对长度单位，具体的大小需要相对于父元素计算，比如父元素的字体大小为80px，那么子元素1em就表示大小和父元素一样为80px，0.5em就表示字体大小是父元素的一半为40px</p><h2 id="2-vw、vh-是什么？"><a href="#2-vw、vh-是什么？" class="headerlink" title="2. vw、vh 是什么？"></a>2. <em>vw、vh</em> 是什么？</h2><p><strong>📢 参考回答：</strong></p><p><em>vw</em> 和 <em>vh</em> 是 <em>CSS3</em> 新单位，即 <em>view width</em> 可视窗口宽度 和 <em>view height</em> 可视窗口高度。1<em>vw</em> 就等于可视窗口宽度的百分之一，1<em>vh</em> 就等于可视窗口高度的百分之一。</p><h2 id="3-介绍下-BFC-及其应用"><a href="#3-介绍下-BFC-及其应用" class="headerlink" title="3.  介绍下 BFC 及其应用"></a>3.  介绍下 <em>BFC</em> 及其应用</h2><p><strong>📢 参考回答：</strong></p><p>所谓 <em>BFC</em>，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</p><p>触发 <em>BFC</em> 的方式有很多，常见的有：</p><ul><li>设置浮动</li><li><em>overflow</em> 设置为 <em>auto、scroll、hidden</em></li><li><em>positon</em> 设置为 <em>absolute、fixed</em></li></ul><p>常见的 <em>BFC</em> 应用有：</p><ul><li>解决浮动元素令父元素高度坍塌的问题</li><li>解决非浮动元素被浮动元素覆盖问题</li><li>解决外边距垂直方向重合的问题</li></ul><h2 id="4-介绍下-BFC、IFC、GFC-和-FFC"><a href="#4-介绍下-BFC、IFC、GFC-和-FFC" class="headerlink" title="4. 介绍下 BFC、IFC、GFC 和 FFC"></a>4. 介绍下 <em>BFC、IFC、GFC</em> 和 <em>FFC</em></h2><p><strong>📢 参考回答：</strong></p><ul><li><em>BFC</em>：块级格式上下文，指的是一个独立的布局环境，<em>BFC</em> 内部的元素布局与外部互不影响。</li><li><em>IFC</em>：行内格式化上下文，将一块区域以行内元素的形式来格式化。</li><li><em>GFC</em>：网格布局格式化上下文，将一块区域以 <em>grid</em> 网格的形式来格式化</li><li><em>FFC</em>：弹性格式化上下文，将一块区域以弹性盒的形式来格式化</li></ul><h2 id="5-flex-布局如何使用？"><a href="#5-flex-布局如何使用？" class="headerlink" title="5. flex 布局如何使用？"></a>5. <em>flex</em> 布局如何使用？</h2><p><strong>📢 参考回答：</strong></p><p>flex 是 Flexible Box 的缩写，意为”弹性布局”。指定容器display: flex即可。</p><p>容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content，align-items，align-content。</p><ul><li>flex-direction属性决定主轴的方向；</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行；</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap；</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，flex，align-self。</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</li><li>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li><li>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 <em>auto</em>，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><h2 id="6-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。"><a href="#6-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景。" class="headerlink" title="6. 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。"></a>6. 分析比较 <em>opacity: 0、visibility: hidden、display: none</em> 优劣和适用场景。</h2><p><strong>📢 参考回答：</strong></p><ul><li>结构： display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击</li><li>继承： display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。 visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。</li><li>性能： displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 opacity: 0 ： 修改元素会造成重绘，性能消耗较少</li></ul><h2 id="7-如何用-css-或-js-实现多行文本溢出省略效果，考虑兼容性"><a href="#7-如何用-css-或-js-实现多行文本溢出省略效果，考虑兼容性" class="headerlink" title="7. 如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性"></a>7. 如何用 <em>css</em> 或 <em>js</em> 实现多行文本溢出省略效果，考虑兼容性</h2><p><strong>📢 参考回答：</strong></p><p>CSS 实现方式</p><p>单行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br><span class="hljs-attribute">white-space</span>: nowrap;<br></code></pre></td></tr></table></figure><p>多行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-attribute">display</span>: -webkit-box;<br>-webkit-box-orient: vertical;<br>-webkit-line-clamp: <span class="hljs-number">3</span>; //行数<br><span class="hljs-attribute">overflow</span>: hidden;<br></code></pre></td></tr></table></figure><p>兼容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">position</span>: relative; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>; <span class="hljs-attribute">max-height</span>: <span class="hljs-number">40px</span>;<span class="hljs-attribute">overflow</span>: hidden;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;...&quot;</span>; <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">40px</span>;<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">-webkit-linear-gradient</span>(left, transparent, <span class="hljs-number">#fff</span> <span class="hljs-number">55%</span>);<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">-o-linear-gradient</span>(right, transparent, <span class="hljs-number">#fff</span> <span class="hljs-number">55%</span>);<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">-moz-linear-gradient</span>(right, transparent, <span class="hljs-number">#fff</span> <span class="hljs-number">55%</span>);<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to right, transparent, <span class="hljs-number">#fff</span> <span class="hljs-number">55%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>JS 实现方式：</p><ul><li>使用split + 正则表达式将单词与单个文字切割出来存入words</li><li>加上 ‘…’</li><li>判断scrollHeight与clientHeight，超出的话就从words中pop一个出来</li></ul><h2 id="8-居中为什么要使用-transform（为什么不使用-marginLeft-x2F-Top）（阿里）"><a href="#8-居中为什么要使用-transform（为什么不使用-marginLeft-x2F-Top）（阿里）" class="headerlink" title="8. 居中为什么要使用 transform（为什么不使用 marginLeft&#x2F;Top）（阿里）"></a>8. 居中为什么要使用 <em>transform</em>（为什么不使用 <em>marginLeft&#x2F;Top</em>）（阿里）</h2><p><strong>📢 参考回答：</strong></p><p>transform 属于合成属性（composite property），对合成属性进行 transition&#x2F;animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。</p><p>top&#x2F;left属于布局属性，该属性的变化会导致重排（reflow&#x2F;relayout），所谓重排即指对这些节点以及受这些节点影响的其它节点，进行CSS计算-&gt;布局-&gt;重绘过程，浏览器需要为整个层进行重绘并重新上传到 GPU，造成了极大的性能开销。</p><h2 id="9-介绍下粘性布局（sticky）（网易）"><a href="#9-介绍下粘性布局（sticky）（网易）" class="headerlink" title="9. 介绍下粘性布局（sticky）（网易）"></a>9. 介绍下粘性布局（<em>sticky</em>）（网易）</h2><p><strong>📢 参考回答：</strong></p><p>position 中的 sticky 值是 CSS3 新增的，设置了 sticky 值后，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。</p><p>sticky 属性值有以下几个特点：</p><ul><li>该元素并不脱离文档流，仍然保留元素原本在文档流中的位置。</li><li>当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。</li><li>元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量</li></ul><h2 id="10-说出-space-between-和-space-around-的区别？（携程）"><a href="#10-说出-space-between-和-space-around-的区别？（携程）" class="headerlink" title="10. 说出 space-between 和 space-around 的区别？（携程）"></a>10. 说出 <em>space-between</em> 和 <em>space-around</em> 的区别？（携程）</h2><p><strong>📢 参考回答：</strong></p><p>这个是 <em>flex</em> 布局的内容，其实就是一个边距的区别，按水平布局来说，<code>space-between</code>是两端对齐，在左右两侧没有边距，而<code>space-around</code>是每个 子项目左右方向的 margin 相等，所以两个item中间的间距会比较大。</p><h2 id="11-CSS3-中-transition-和-animation-的属性分别有哪些（哔哩哔哩）"><a href="#11-CSS3-中-transition-和-animation-的属性分别有哪些（哔哩哔哩）" class="headerlink" title="11. CSS3 中 transition 和 animation 的属性分别有哪些（哔哩哔哩）"></a>11. <em>CSS3</em> 中 <em>transition</em> 和 <em>animation</em> 的属性分别有哪些（哔哩哔哩）</h2><p><strong>📢 参考回答：</strong></p><p><em>transition</em> 过渡动画：</p><ul><li><em>transition-property</em>：指定过渡的 <em>CSS</em> 属性</li><li><em>transition-duration</em>：指定过渡所需的完成时间</li><li><em>transition-timing-function</em>：指定过渡函数</li><li><em>transition-delay</em>：指定过渡的延迟时间</li></ul><p><em>animation</em> 关键帧动画：</p><ul><li><em>animation-name</em>：指定要绑定到选择器的关键帧的名称</li><li><em>animation-duration</em>：动画指定需要多少秒或毫秒完成</li><li><em>animation-timing-function</em>：设置动画将如何完成一个周期</li><li><em>animation-delay</em>：设置动画在启动前的延迟间隔</li><li><em>animation-iteration-count</em>：定义动画的播放次数</li><li><em>animation-direction</em>：指定是否应该轮流反向播放动画</li><li><em>animation-fill-mode</em>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式</li><li><em>animation-play-state</em>：指定动画是否正在运行或已暂停</li></ul><h2 id="12-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景"><a href="#12-分析比较-opacity-0、visibility-hidden、display-none-优劣和适用场景" class="headerlink" title="12. 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景"></a>12. 分析比较 <em>opacity: 0、visibility: hidden、display: none</em> 优劣和适用场景</h2><p><strong>📢 参考回答：</strong></p><ol><li>display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）</li><li>visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）</li><li>opacity: 0（占据空间，可以点击）（场景：可以跟transition搭配）</li></ol><h2 id="13-讲一下png8、png16、png32的区别，并简单讲讲-png-的压缩原理"><a href="#13-讲一下png8、png16、png32的区别，并简单讲讲-png-的压缩原理" class="headerlink" title="13. 讲一下png8、png16、png32的区别，并简单讲讲 png 的压缩原理"></a>13. 讲一下<em>png8、png16、png32</em>的区别，并简单讲讲 <em>png</em> 的压缩原理</h2><p><strong>📢 参考回答：</strong></p><p>PNG图片主要有三个类型，分别为 PNG 8&#x2F; PNG 24 &#x2F; PNG 32。</p><ul><li><code>PNG 8</code>：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。</li><li><code>PNG 24</code>：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0-255),G(0-255),B(0-255)，可以表达256乘以256乘以256&#x3D;16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。</li><li><code>PNG 32</code>：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0<del>255),G(0</del>255),B(0<del>255),A(0</del>255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。</li></ul><p>PNG图片的压缩，分两个阶段：</p><ul><li><code>预解析（Prediction）</code>：这个阶段就是对png图片进行一个预处理，处理后让它更方便后续的压缩。</li><li><code>压缩（Compression）</code>：执行Deflate压缩，该算法结合了 LZ77 算法和 Huffman 算法对图片进行编码。</li></ul><h2 id="14-如何用-CSS-实现一个三角形"><a href="#14-如何用-CSS-实现一个三角形" class="headerlink" title="14. 如何用 CSS 实现一个三角形"></a>14. 如何用 <em>CSS</em> 实现一个三角形</h2><p><strong>📢 参考回答：</strong></p><p>可以利用 border 属性</p><p>利用盒模型的 <code>border</code> 属性上下左右边框交界处会呈现出平滑的斜线这个特点，通过设置不同的上下左右边框宽度或者颜色即可得到三角形或者梯形。</p><p>如果想实现其中的任一个三角形，把其他方向上的 <code>border-color</code> 都设置成透明即可。</p><p>示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>css复制代码div&#123;<br>width: 0;<br>height: 0;<br>border: 10px solid red;<br>border-top-color: transparent;<br>border-left-color: transparent;<br>border-right-color: transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-如何实现一个自适应的正方形"><a href="#15-如何实现一个自适应的正方形" class="headerlink" title="15. 如何实现一个自适应的正方形"></a>15. 如何实现一个自适应的正方形</h2><p><strong>📢 参考回答：</strong></p><p><strong>方法1：利用 CSS3 的 vw 单位</strong></p><p><code>vw</code> 会把视口的宽度平均分为 100 份</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.square</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br> <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法2：利用 margin 或者 padding 的百分比计算是参照父元素的 width 属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.square</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br> <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10%</span>; <br> <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; // 防止内容撑开多余的高度<br> <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-清除浮动的方法"><a href="#16-清除浮动的方法" class="headerlink" title="16. 清除浮动的方法"></a>16. 清除浮动的方法</h2><p><strong>📢 参考回答：</strong></p><ul><li>clear 清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式： <code>&#123;clear:both;height:0;overflow:hidden;&#125;</code></li><li>给浮动元素父级设置高度</li><li>父级同时浮动（需要给父级同级元素添加浮动）</li><li>父级设置成inline-block，其margin: 0 auto居中方式失效</li><li>给父级添加overflow:hidden 清除浮动方法</li><li>万能清除法 ::after 伪元素清浮动（现在主流方法，推荐使用）</li></ul><h2 id="17-说说两种盒模型以及区别"><a href="#17-说说两种盒模型以及区别" class="headerlink" title="17. 说说两种盒模型以及区别"></a>17. 说说两种盒模型以及区别</h2><p><strong>📢 参考回答：</strong></p><p>盒模型也称为框模型，就是从盒子顶部俯视所得的一张平面图，用于描述元素所占用的空间。它有两种盒模型，W3C盒模型和IE盒模型（IE6以下，不包括IE6以及怪异模式下的IE5.5+）</p><p>理论上两者的主要区别是二者的盒子宽高是否包括元素的边框和内边距。当用CSS给给某个元素定义高或宽时，IE盒模型中内容的宽或高将会包含内边距和边框，而W3C盒模型并不会。</p><h2 id="18-如何触发重排和重绘？"><a href="#18-如何触发重排和重绘？" class="headerlink" title="18. 如何触发重排和重绘？"></a>18. 如何触发重排和重绘？</h2><p><strong>📢 参考回答：</strong></p><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h2 id="19-重绘与重排的区别？"><a href="#19-重绘与重排的区别？" class="headerlink" title="19. 重绘与重排的区别？"></a>19. 重绘与重排的区别？</h2><p><strong>📢 参考回答：</strong></p><p><strong>重排:</strong>  部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</p><p><strong>重绘:</strong>  由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变</p><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p><p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p><p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p><h2 id="20-如何优化图片"><a href="#20-如何优化图片" class="headerlink" title="20. 如何优化图片"></a>20. 如何优化图片</h2><p><strong>📢 参考回答：</strong></p><ol><li>对于很多装饰类图片，尽量不用图片，因为这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 <em>base64</em> 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：</li></ol><ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul><h2 id="21-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#21-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="21. 你能描述一下渐进增强和优雅降级之间的不同吗?"></a>21. 你能描述一下渐进增强和优雅降级之间的不同吗?</h2><p><strong>📢 参考回答：</strong></p><p><strong>渐进增强 （progressive enhancement）</strong>：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><strong>优雅降级 （graceful degradation）</strong>：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p><code>区别</code>：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><h2 id="22-CSS3-新增了那些东西？"><a href="#22-CSS3-新增了那些东西？" class="headerlink" title="22. CSS3 新增了那些东西？"></a>22. <em>CSS3</em> 新增了那些东西？</h2><p><strong>📢 参考回答：</strong></p><p><strong>CSS3</strong> 新增东西众多，这里列举出一些关键的新增内容：</p><ul><li>选择器</li><li>盒子模型属性：<em>border-radius、box-shadow、border-image</em></li><li>背景：<em>background-size、background-origin、background-clip</em></li><li>文本效果：<em>text-shadow、word-wrap</em></li><li>颜色：新增 <em>RGBA，HSLA</em> 模式</li><li>渐变：线性渐变、径向渐变</li><li>字体：*@font-face*</li><li>2D&#x2F;3D转换：<em>transform、transform-origin</em></li><li>过渡与动画：<em>transition、@keyframes、animation</em></li><li>多列布局</li><li>媒体查询</li></ul><h2 id="23-隐藏页面中的某个元素的方法有哪些？"><a href="#23-隐藏页面中的某个元素的方法有哪些？" class="headerlink" title="23. 隐藏页面中的某个元素的方法有哪些？"></a>23. 隐藏页面中的某个元素的方法有哪些？</h2><p><strong>📢 参考回答：</strong></p><p><strong>隐藏类型</strong></p><p>屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类：</p><ul><li>完全隐藏：元素从渲染树中消失，不占据空间。</li><li>视觉上的隐藏：屏幕中不可见，占据空间。</li><li>语义上的隐藏：读屏软件不可读，但正常占据空。</li></ul><p><strong>完全隐藏</strong></p><p>(1) display 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css<br>复制代码 <span class="hljs-attribute">display</span>: none;<br></code></pre></td></tr></table></figure><p>(2) hidden 属性 HTML5 新增属性，相当于 display: none</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">hidden</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>视觉上的隐藏</strong></p><p>(1) 设置 posoition 为 absolute 或 fixed，通过设置 top、left 等值，将其移出可视区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;<br></code></pre></td></tr></table></figure><p>(2) 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-attribute">position</span>: relative;<br><span class="hljs-attribute">left</span>: -<span class="hljs-number">99999px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>(3) 设置 margin 值，将其移出可视区域范围（可视区域占位）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码margin-<span class="hljs-attr">left</span>: -99999px;<br><span class="hljs-attr">height</span>: <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>语义上隐藏</strong></p><p><em>aria-hidden 属性</em></p><p>读屏软件不可读，占据空间，可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码&lt;div aria-hidden=<span class="hljs-string">&quot;true&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github 掘金 Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html面试题</title>
    <link href="/2022/11/23/%E6%8E%98%E9%87%91-Html/"/>
    <url>/2022/11/23/%E6%8E%98%E9%87%91-Html/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-DOCTYPE，-有何作用？"><a href="#1-什么是-DOCTYPE，-有何作用？" class="headerlink" title="1. 什么是 DOCTYPE， 有何作用？"></a>1. 什么是 <em>DOCTYPE</em>， 有何作用？</h2><p><code>Doctype</code>是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为<code>怪异模式</code>，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的<code>bug</code>，所以文档声明是必须的。</p><h2 id="2-说说对-html-语义化的理解"><a href="#2-说说对-html-语义化的理解" class="headerlink" title="2. 说说对 html 语义化的理解"></a>2. 说说对 <em>html</em> 语义化的理解</h2><p>HTML标签的语义化，简单来说，就是用正确的标签做正确的事情，给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，无论是谁都能看懂这块内容是什么。</p><p>语义化的优点如下：</p><ul><li>在没有CSS样式情况下也能够让页面呈现出清晰的结构</li><li>有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</li><li>方便团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化</li></ul><h2 id="3-src-和-href-的区别"><a href="#3-src-和-href-的区别" class="headerlink" title="3. src 和 href 的区别"></a>3. <em>src</em> 和 <em>href</em> 的区别</h2><p>src和href都是HTML中特定元素的属性，都可以用来引入外部的资源。两者区别如下：</p><ul><li>src：全称<em>source</em>，它通常用于img、video、audio、script元素，通过src指向请求外部资源的来源地址，指向的内容会嵌入到文档中当前标签所在位置，在请求src资源时，它会将资源下载并应用到文档内，比如说：js脚本、img图片、frame等元素。当浏览器解析到该元素时，会暂停其它资源下载，直到将该资源加载、编译、执行完毕。这也是为什么将js脚本放在底部而不是头部的原因。</li><li>href：全称<em>hyper reference</em>，意味着超链接，指向网络资源，当浏览器识别到它指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理，通常用于a、link元素。</li></ul><h2 id="4-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？"><a href="#4-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？" class="headerlink" title="4. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？"></a>4. <em>title</em> 与 <em>h1</em> 的区别、<em>b</em> 与 <em>strong</em> 的区别、<em>i</em> 与 <em>em</em> 的区别？</h2><ul><li><em>title</em> 属性表示网页的标题，<em>h1</em> 元素则表示层次明确的页面内容标题，对页面信息的抓取也有很大的影响</li><li><em>strong</em> 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong会重读，而<em>b</em>是展示强调内容</li><li><em>i</em> 是<em>italic</em>(斜体)的简写，是早期的斜体元素，表示内容展示为斜体，而 <em>em</em> 是<em>emphasize</em>（强调）的简写，表示强调的文本</li></ul><h2 id="5-什么是严格模式与混杂模式？"><a href="#5-什么是严格模式与混杂模式？" class="headerlink" title="5. 什么是严格模式与混杂模式？"></a>5. 什么是严格模式与混杂模式？</h2><ul><li>严格模式：是以浏览器支持的最高标准运行</li><li>混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为</li></ul><h2 id="6-前端页面有哪三层构成，分别是什么？"><a href="#6-前端页面有哪三层构成，分别是什么？" class="headerlink" title="6. 前端页面有哪三层构成，分别是什么？"></a>6. 前端页面有哪三层构成，分别是什么？</h2><p>构成：<code>结构层</code>、<code>表示层</code>、<code>行为层</code></p><ol><li><p>结构层（structural layer）</p><p>结构层类似于盖房子需要打地基以及房子的悬梁框架，它是由HTML超文本标记语言来创建的，也就是页面中的各种标签，在结构层中保存了用户可以看到的所有内容，比如说：一段文字、一张图片、一段视频等等</p></li><li><p>表示层（presentation layer）</p><p>表示层是由CSS负责创建，它的作用是如何显示有关内容，学名：<code>层叠样式表</code>，也就相当于装修房子，看你要什么风格的，田园的、中式的、地中海的，总之CSS都能办妥</p></li><li><p>行为层（behaviorlayer）</p><p>行为层表示网页内容跟用户之间产生交互性，简单来说就是用户操作了网页，网页给用户一个反馈，这是<code>JavaScript</code>和<code>DOM</code>主宰的领域</p></li></ol><h2 id="7-iframe的作用以及优缺点"><a href="#7-iframe的作用以及优缺点" class="headerlink" title="7. iframe的作用以及优缺点"></a>7. iframe的作用以及优缺点</h2><p>iframe也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入到现有的网页中。</p><p>优点：</p><ul><li>可以用来处理加载缓慢的内容，比如：广告</li></ul><p>缺点：</p><ul><li>iframe会阻塞主页面的Onload事件</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。但是可以通过JS动态给ifame添加src属性值来解决这个问题，当然也可以解决iframe会阻塞主页面的Onload事件的问题</li><li>会产生很多页面，不易管理</li><li>浏览器的后退按钮没有作用</li><li>无法被一些搜索引擎识别</li></ul><h2 id="8-img上-title-与-alt"><a href="#8-img上-title-与-alt" class="headerlink" title="8. img上 title 与 alt"></a>8. img上 title 与 alt</h2><ul><li>alt：全称<code>alternate</code>，切换的意思，如果无法显示图像，浏览器将显示alt指定的内容</li><li>title：当鼠标移动到元素上时显示title的内容</li></ul><p>区别：</p><p>一般当鼠标滑动到元素身上的时候显示<code>title</code>，而<code>alt</code>是img标签特有的属性，是图片内容的等价描述，用于图片无法加载时显示，这样用户还能看到关于丢失了什么东西的一些信息，相对来说比较友好。</p><h2 id="9-H5和HTML5区别"><a href="#9-H5和HTML5区别" class="headerlink" title="9. H5和HTML5区别"></a>9. H5和HTML5区别</h2><ul><li>H5是一个产品名词，包含了最新的HTML5、CSS3、ES6等新技术来制作的应用</li><li>HTML5是一个技术名词，指的就是第五代HTML</li></ul><h2 id="10-行内元素和块级元素分别有哪些？有何区别？怎样转换？"><a href="#10-行内元素和块级元素分别有哪些？有何区别？怎样转换？" class="headerlink" title="10. 行内元素和块级元素分别有哪些？有何区别？怎样转换？"></a>10. 行内元素和块级元素分别有哪些？有何区别？怎样转换？</h2><p>常见的块级元素：<code>p、div、form、ul、li、ol、table、h1、h2、h3、h4、h5、h6、dl、dt、dd</code></p><p>常见的行级元素：<code>span、a、img、button、input、select</code></p><p>块级元素：</p><ul><li>总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列</li><li>宽度缺少时是它的容器的100%，除非设置一个宽度</li><li>高度、行高以及外边距和内边距都是可以设置的</li><li>块级元素可以容纳其它行级元素和块级元素</li></ul><p>行内元素：</p><ul><li>和其它元素都会在一行显示</li><li>高、行高以及外边距和内边距可以设置</li><li>宽度就是文字或者图片的宽度，不能改变</li><li>行级元素只能容纳文本或者其它行内元素</li></ul><p>使用行内元素需要注意的是：</p><ul><li>行内元素设置宽度<code>width</code>无效</li><li>行内元素设置<code>height</code>无效，但是可以通过<code>line-height</code>来设置</li><li>设置<code>margin</code>只有左右有效，上下无效</li><li>设置<code>padding</code>只有左右有效，上下无效</li></ul><p>可以通过<code>display</code>属性对行内元素和块级元素进行切换(主要看第 <code>2、3、4</code>三个值)：</p><img src="/2022/11/23/%E6%8E%98%E9%87%91-Html/11/23/%E6%8E%98%E9%87%91-Html/671860f93c61456da6bc2a5fe67bdb29tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class title="img"><h2 id="11-label的作用是什么？是怎么用的？"><a href="#11-label的作用是什么？是怎么用的？" class="headerlink" title="11. label的作用是什么？是怎么用的？"></a>11. label的作用是什么？是怎么用的？</h2><p><code>label</code>元素不会向用户呈现任何特殊效果，但是，它为鼠标用户改进了可用性，当我们在label元素内点击文本时就会触发此控件。也就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。最常用label的地方就是表单中的性别单选框了，当点击文字时也能够自动聚焦绑定的表单控件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="12-对于Web标准以及W3C的理解"><a href="#12-对于Web标准以及W3C的理解" class="headerlink" title="12. 对于Web标准以及W3C的理解"></a>12. 对于Web标准以及W3C的理解</h2><p><code>Web标准</code>简单来说可以分为结构、表现、行为。其中结构是由HTML各种标签组成，简单来说就是body里面写入标签是为了页面的结构。表现指的是CSS层叠样式表，通过CSS可以让我们的页面结构标签更具美感。行为指的是页面和用户具有一定的交互，这部分主要由JS组成</p><p><code>W3C</code>，全称：world wide web consortium是一个制定各种标准的非盈利性组织，也叫万维网联盟，标准包括HTML、CSS、ECMAScript等等，web标准的制定有很多好处，比如说：</p><ul><li>可以统一开发流程，统一使用标准化开发工具（VSCode、WebStorm、Sublime），方便多人协作</li><li>学习成本降低，只需要学习标准就行，否则就要学习各个浏览器厂商标准</li><li>跨平台，方便迁移都不同设备</li><li>降低代码维护成本</li></ul><h2 id="13-Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？"><a href="#13-Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？" class="headerlink" title="13. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？"></a>13. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？</h2><p>页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。</p><p>区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：</p><ul><li><code>盒模型</code>：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border</li><li><code>设置行内元素的高宽</code>：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效</li><li><code>用margin：0 auto设置水平居中</code>:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效</li><li><code>设置百分比高度</code>:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的</li></ul><h2 id="14-知道什么是微格式吗？谈谈理解，在前端构建中应该考虑微格式吗？"><a href="#14-知道什么是微格式吗？谈谈理解，在前端构建中应该考虑微格式吗？" class="headerlink" title="14. 知道什么是微格式吗？谈谈理解，在前端构建中应该考虑微格式吗？"></a>14. 知道什么是微格式吗？谈谈理解，在前端构建中应该考虑微格式吗？</h2><p>所谓的微格式是建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式。</p><p>具体表现是把语义嵌入到HTML中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾HTML文档的人机可读性，相当于对web网页进行语义注解。</p><p>采用微格式的web页面，在HTML文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理HTML文档的软件，更好的理解HTML文档。当爬取web内容时，能够更为准确地识别内容块的语义，微格式可以对网站进行SEO优化。</p><h2 id="15-HTML5为什么只需要写-lt-DOCTYPE-html-gt"><a href="#15-HTML5为什么只需要写-lt-DOCTYPE-html-gt" class="headerlink" title="15. HTML5为什么只需要写&lt;!DOCTYPE html&gt;?"></a>15. HTML5为什么只需要写<code>&lt;!DOCTYPE html&gt;</code>?</h2><p>为什么HTML5只需要写一段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而HTML4却需要写很长的一段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">html<br>复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其实主要是因为HTML5不基于SGML，所以不需要引用DTD。在HTML4中，<code>&lt;!DOCTYPE&gt;</code>声明引用DTD，因为HTML4基于SGML。DTD规定了标记语言的规则，这样浏览器才能正确的呈现内容。</p><h2 id="16-HTML5新增了哪些新特性？移除了哪些元素？"><a href="#16-HTML5新增了哪些新特性？移除了哪些元素？" class="headerlink" title="16. HTML5新增了哪些新特性？移除了哪些元素？"></a>16. HTML5新增了哪些新特性？移除了哪些元素？</h2><p>HTML5主要是关于图像、位置、存储、多任务等功能的增加：</p><ul><li>语义化标签，如：article、footer、header、nav等</li><li>视频video、音频audio</li><li>画布canvas</li><li>表单控件，calemdar、date、time、email</li><li>地理</li><li>本地离线存储，localStorage长期存储数据，浏览器关闭后数据不丢失，sessionStorage的数据在浏览器关闭后自动删除</li><li>拖拽释放</li></ul><p>移除的元素：</p><ul><li>纯表现的元素：<code>basefont、font、s、strike、tt、u、big、center</code></li><li>对可选用性产生负面影响的元素：<code>frame、frameset、noframes</code></li></ul><h2 id="17-怎么处理HTML5新标签兼容问题？"><a href="#17-怎么处理HTML5新标签兼容问题？" class="headerlink" title="17. 怎么处理HTML5新标签兼容问题？"></a>17. 怎么处理HTML5新标签兼容问题？</h2><p>主要有两种方式：</p><ol><li>实现标签被识别：通过<code>document.createElement(tagName)</code>方法可以让浏览器识别新的标签，浏览器支持新标签后。还可以为新标签添加CSS样式</li><li>用JavaScript解决：使用HTML5的shim框架，在<code>head</code>标签中调用以下代码：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码&lt;!--[<span class="hljs-keyword">if</span> lt <span class="hljs-variable constant_">IE</span> <span class="hljs-number">9</span>]&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> src=<span class="hljs-string">&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;![endif]--&gt;<br></code></pre></td></tr></table></figure><h2 id="18-如何实现在一张图片上的某个区域做到点击事件"><a href="#18-如何实现在一张图片上的某个区域做到点击事件" class="headerlink" title="18. 如何实现在一张图片上的某个区域做到点击事件"></a>18. 如何实现在一张图片上的某个区域做到点击事件</h2><p>我们可以通过图片热区技术：</p><ol><li>插入一张图片，并设置好图像的有关参数，在<code>&lt;img&gt;</code>标记中设置参数<code>usemap=&quot;#Map&quot;</code>，以表示对图像地图的引用。</li><li>用<code>&lt;map&gt;</code>标记设定图像地图的作用区域，并取名：Map；</li><li>分别用<code>&lt;area&gt;</code>标记针对相应位置互粉出多个矩形作用区域，并设定好链接参数<code>href</code></li></ol><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">usemap</span>=<span class="hljs-string">&quot;#Map&quot;</span> /&gt;</span><br> 　　<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Map&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;poly&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;65,71,98,58,114,90,108,112,79,130,56,116,38,100,41,76,52,53,83,34,110,33,139,46,141,75,145,101,127,115,113,133,85,132,82,131,159,117&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;poly&quot;</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;28,22,57,20,36,39,27,61&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="19-a元素除了用于导航外，还有什么作用？"><a href="#19-a元素除了用于导航外，还有什么作用？" class="headerlink" title="19. a元素除了用于导航外，还有什么作用？"></a>19. a元素除了用于导航外，还有什么作用？</h2><p>href属性中的url可以是浏览器支持的任何协议，所以a标签可以用来手机拨号<code>&lt;a href=&quot;tel:110&quot;&gt;110&lt;/a&gt;</code>，也可以用来发送短信<code>&lt;a href=&quot;sms:110&quot;&gt;110&lt;/a&gt;</code>，还有邮件等等</p><p>当然，a元素最常见的就是用来做<em>锚点</em>和 <em>下载文件</em>。</p><p>锚点可以在点击时快速定位到一个页面的某个位置，而下载的原理在于a标签所对应的资源浏览器无法解析，于是浏览器会选择将其下载下来。</p><h2 id="20-你知道SEO中的TDK吗？"><a href="#20-你知道SEO中的TDK吗？" class="headerlink" title="20. 你知道SEO中的TDK吗？"></a>20. 你知道SEO中的TDK吗？</h2><p>在SEO中，TDK其实就是<code>title</code>、<code>description</code>、<code>keywords</code>这三个标签，title表示标题标签，description是描述标签，keywords是关键词标签</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github 掘金 Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React面试题</title>
    <link href="/2022/11/23/%E6%8E%98%E9%87%91-React/"/>
    <url>/2022/11/23/%E6%8E%98%E9%87%91-React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="如何创建一个react的项目（使用脚手架）"><a href="#如何创建一个react的项目（使用脚手架）" class="headerlink" title="如何创建一个react的项目（使用脚手架）"></a>如何创建一个react的项目（使用脚手架）</h2><ul><li>安装cr脚手架：npm install -g create-react-app</li><li>进入文件夹：create-react-app 项目名称</li><li>进入项目：cd 项目名称</li><li>运行项目：npm start</li></ul><h2 id="如何不使用脚手架创建一个项目"><a href="#如何不使用脚手架创建一个项目" class="headerlink" title="如何不使用脚手架创建一个项目"></a>如何不使用脚手架创建一个项目</h2><p>之前面试官问过是否有不使用脚手架创建项目的经历。</p><p>详细可以查看<a href="https://juejin.cn/post/7071169689216352263">这篇文章</a></p><p>我理解这个问题说出来大概就可以，比如：</p><ol><li>yarn init 初始化package.json文件</li><li>安装react和react-dom</li><li>配置webpack<ul><li>配置babel支持ES6</li><li>配置@babel&#x2F;preset-react支持react</li><li>支持ts：ts-loader @types&#x2F;react @types&#x2F;react-dom</li><li>支持antd</li><li>支持less：less-loader，css-loader，style-loader</li><li>配置plugins，常用的有html-webpack-plugin（当使用 webpack 打包时，创建一个 html 文件，并把 webpack 打包后的静态文件自动插入到这个 html 文件当中。）和 clean-webpack-plugin（是一个清除文件的插件。 在每次打包后，磁盘空间会存有打包后的资源，在再次打包的时候，我们需要先把本地已有的打包后的资源清空，来减少它们对磁盘空间的占用。 插件clean-webpack-plugin就可以帮我们做这个事情）</li></ul></li><li>安装router</li><li>安装redux</li></ol><h2 id="对于React-框架的理解（React的特性有哪些）"><a href="#对于React-框架的理解（React的特性有哪些）" class="headerlink" title="对于React 框架的理解（React的特性有哪些）"></a>对于React 框架的理解（React的特性有哪些）</h2><p>React是一个用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案。</p><p>它有以下特性：</p><ul><li><p>组件化：将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面，提高代码的复用率和开发效率。</p></li><li><p>数据驱动视图：</p><ul><li><code>React</code>通过<code>setState</code>实现数据驱动视图，通过<code>setState</code>来引发一次组件的更新过程从而实现页面的重新渲染。</li><li>数据驱动视图是我们只需要关注数据的变化，不用再去操作dom。同时也提升了性能。</li></ul></li><li><p>JSX 语法：用于声明组件结构，是一个 JavaScript 的语法扩展。</p></li><li><p>单向数据绑定：从高阶组件到低阶组件的单向数据流，单向响应的数据流会比双向绑定的更安全，速度更快</p></li><li><p>虚拟 DOM：使用虚拟 <code>DOM</code> 来有效地操作 <code>DOM</code></p></li><li><p>声明式编程:</p><p>如实现一个标记的地图： 通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 创建地图</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">map</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;map&quot;</span>), &#123;<br>  <span class="hljs-attr">zoom</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attr">center</span>: &#123; lat, lng &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 创建标记</span><br><span class="hljs-keyword">const</span> marker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">marker</span>(&#123;<br>  <span class="hljs-attr">position</span>: &#123; lat, lng &#125;,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Hello Marker&quot;</span>,<br>&#125;);<br><br><span class="hljs-comment">// 地图上添加标记</span><br>marker.<span class="hljs-title function_">setMap</span>(map);<br></code></pre></td></tr></table></figure><p>而用 React 实现上述功能则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码&lt;<span class="hljs-title class_">Map</span> zoom=&#123;<span class="hljs-number">4</span>&#125; center=&#123;(lat, lng)&#125;&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Marker</span> <span class="hljs-attr">position</span>=<span class="hljs-string">&#123;(lat,</span> <span class="hljs-attr">lng</span>)&#125; <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">Hello</span> <span class="hljs-attr">Marker</span>&quot;&#125; /&gt;</span></span><br>&lt;/<span class="hljs-title class_">Map</span>&gt;<br></code></pre></td></tr></table></figure><p>声明式编程方式使得 React 组件很容易使用，最终的代码简单易于维护</p></li></ul><h2 id="jsx语法是必须的吗"><a href="#jsx语法是必须的吗" class="headerlink" title="jsx语法是必须的吗"></a>jsx语法是必须的吗</h2><p>以下是经过babel转译之后的jsx：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-comment">// jsx</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<br>  <span class="hljs-string">&#x27;root&#x27;</span><br>);<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(element, container);<br><br><span class="hljs-comment">// babel 处理后</span><br><span class="hljs-keyword">const</span> element = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello, world!&quot;</span>);<br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>);<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(element, container);<br></code></pre></td></tr></table></figure><p><em>注：React.createElement(标签名，属性对象，子元素)</em></p><p>所以不使用jsx语法也可以使用React：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// 本文件用于测试jsx 语法是否是必须的</span><br><br><span class="hljs-comment">// 不使用jsx语法创建的元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCreateElement</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello, createElement!&quot;</span>);<br><br><span class="hljs-comment">// 使用jsx语法创建的元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">JsxElement</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, JSX!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><br><span class="hljs-keyword">export</span> &#123;<br>    <span class="hljs-title class_">JsxElement</span>,<span class="hljs-title class_">ReactCreateElement</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">ReactCreateElement</span>,<span class="hljs-title class_">JsxElement</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/JsxNecessary&#x27;</span>; <span class="hljs-comment">// 验证jsx是否是必须的</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">            &#123;ReactCreateElement&#125;</span><br><span class="language-xml">            &#123;JsxElement&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>两者均可正常显示，但是两者的优劣显而易见，使用createElement方法会使代码更加的冗余，而jsx更加简洁。</p><h2 id="为什么提出jsx"><a href="#为什么提出jsx" class="headerlink" title="为什么提出jsx"></a>为什么提出jsx</h2><p>JSX是JS的语法扩展，主要用于声明元素，可以理解为React.createElement()的语法糖，React并不强制使用JSX，即使使用了JSX最后也会被babel编译成createElement。</p><p>React认为视图和逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p><p>React并没有采用将视图与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。 为了实现其组件化的目的，而不引入更多的概念（比如Vue引入了模板语法，这就是新的概念，学习成本会比较高），使用人们熟悉的js语法的扩展更加适用。</p><p>并且相比于createElement，JSX更加的简洁。</p><p><em>关注点分离是日常生活和生产中广泛使用的解决复杂问题的一种系统思维方法。大体思路是,先将复杂问题做合理的分解,再分别仔细研究问题的不同侧面(关注点)，最后综合各方面的结果，合成整体的解决方案。</em></p><h2 id="Babel-插件是如何实现-JSX-到-JS-的编译-？"><a href="#Babel-插件是如何实现-JSX-到-JS-的编译-？" class="headerlink" title="Babel 插件是如何实现 JSX 到 JS 的编译 ？"></a>Babel 插件是如何实现 JSX 到 JS 的编译 ？</h2><p>需要的依赖：</p><ul><li>@babel&#x2F;cli</li><li>@babel&#x2F;core</li><li>@babel&#x2F;preset-react</li></ul><p>babel.rc文件添加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">json复制代码<span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 React.createElement 的函数。</p><p>React.createElement源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, config, children</span>) &#123;<br>    <span class="hljs-comment">// propName 变量用于储存后面需要用到的元素属性</span><br>    <span class="hljs-keyword">let</span> propName;<br>    <span class="hljs-comment">// props 变量用于储存元素属性的键值对集合</span><br>    <span class="hljs-keyword">const</span> props = &#123;&#125;;<br>    <span class="hljs-comment">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span><br>    <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> ref = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> source = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// config 对象中存储的是元素的属性</span><br>    <span class="hljs-keyword">if</span> (config != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidRef</span>(config)) &#123;<br>            ref = config.<span class="hljs-property">ref</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此处将 key 值字符串化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidKey</span>(config)) &#123;<br>            key = <span class="hljs-string">&#x27;&#x27;</span> + config.<span class="hljs-property">key</span>;<br>        &#125;<br><br>        self = config.<span class="hljs-property">__self</span> === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.<span class="hljs-property">__self</span>;<br>        source = config.<span class="hljs-property">__source</span> === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : config.<span class="hljs-property">__source</span>;<br><br>        <span class="hljs-comment">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span><br>        <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> config) &#123;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// 筛选出可以提进 props 对象里的属性</span><br>                hasOwnProperty.<span class="hljs-title function_">call</span>(config, propName) &amp;&amp;<br>                !<span class="hljs-variable constant_">RESERVED_PROPS</span>.<span class="hljs-title function_">hasOwnProperty</span>(propName)<br>            ) &#123;<br>                props[propName] = config[propName];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span><br>    <span class="hljs-keyword">const</span> childrenLength = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span><br>    <span class="hljs-keyword">if</span> (childrenLength === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 直接把这个参数的值赋给props.children</span><br>        props.<span class="hljs-property">children</span> = children;<br>        <span class="hljs-comment">// 处理嵌套多个子元素的情况</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childrenLength &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 声明一个子元素数组</span><br>        <span class="hljs-keyword">const</span> childArray = <span class="hljs-title class_">Array</span>(childrenLength);<br>        <span class="hljs-comment">// 把子元素推进数组里</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; childrenLength; i++) &#123;<br>            childArray[i] = <span class="hljs-variable language_">arguments</span>[i + <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-comment">// 最后把这个数组赋值给props.children</span><br>        props.<span class="hljs-property">children</span> = childArray;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理 defaultProps</span><br>    <span class="hljs-keyword">if</span> (type &amp;&amp; type.<span class="hljs-property">defaultProps</span>) &#123;<br>        <span class="hljs-keyword">const</span> defaultProps = type.<span class="hljs-property">defaultProps</span>;<br>        <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> defaultProps) &#123;<br>            <span class="hljs-keyword">if</span> (props[propName] === <span class="hljs-literal">undefined</span>) &#123;<br>                props[propName] = defaultProps[propName];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactElement</span>(<br>        type,<br>        key,<br>        ref,<br>        self,<br>        source,<br>        <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">current</span>,<br>        props,<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>createElement并没有十分复杂的操作，整个过程看起来更像是一个格式化的过程：将我们输入的相对简单清晰的结构转化为ReactElement函数需要的格式。</p><p>ReactElement函数源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactElement</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">type, key, ref, self, source, owner, props</span>) &#123;<br>  <span class="hljs-keyword">const</span> element = &#123;<br>    <span class="hljs-comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span><br>    <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span>,<br><br>    <span class="hljs-comment">// 内置属性赋值</span><br>    <span class="hljs-attr">type</span>: type,<br>    <span class="hljs-attr">key</span>: key,<br>    <span class="hljs-attr">ref</span>: ref,<br>    <span class="hljs-attr">props</span>: props,<br><br>    <span class="hljs-comment">// 记录创造该元素的组件</span><br>    <span class="hljs-attr">_owner</span>: owner,<br>  &#125;;<br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    <span class="hljs-comment">// 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> element;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ReactElement 其实只做了一件事情，那就是“创建”，说得更精确一点，是“组装”：ReactElement 把传入的参数按照一定的规范，“组装”进了 element 对象里，并把它返回给了 React.createElement，最终 React.createElement 又把它交回到了开发者手中。</p><p>ReactElement返回的element 其实就是虚拟DOM中的一个节点：一个JS对象，这个对象包含了对真实节点的描述。</p><h2 id="对于React虚拟DOM的理解"><a href="#对于React虚拟DOM的理解" class="headerlink" title="对于React虚拟DOM的理解"></a>对于React虚拟DOM的理解</h2><ul><li>js对象，保存在内存中</li><li>是对真实DOM结构的映射</li></ul><p>虚拟 DOM 的工作流程：</p><p><strong>挂载阶段</strong>：React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）；</p><p><strong>更新阶段</strong>：页面的变化先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM。</p><p>虚拟 DOM 解决的关键问题有以下三个：</p><ul><li><strong>减少 DOM 操作</strong>：虚拟 DOM 可以将多次 DOM 操作合并为一次操作</li><li><strong>研发体验&#x2F;研发效率的问题</strong>：虚拟 DOM 的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。</li><li><strong>跨平台的问题</strong>：虚拟 DOM 是对真实渲染内容的一层抽象。同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”</li></ul><p>既然是虚拟 DOM，那就意味着它和渲染到页面上的真实 DOM 之间还有一定的距离，这个距离通过 ReactDOM.render 方法填充：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="hljs-comment">// 需要渲染的元素（ReactElement）</span><br>    element, <br>    <span class="hljs-comment">// 元素挂载的目标容器（一个真实DOM）</span><br>    container,<br>    <span class="hljs-comment">// 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span><br>    [callback]<br>)<br></code></pre></td></tr></table></figure><h2 id="VDOM-和-DOM-的区别"><a href="#VDOM-和-DOM-的区别" class="headerlink" title="VDOM 和 DOM 的区别"></a>VDOM 和 DOM 的区别</h2><ul><li>真实DOM存在重排和重绘，虚拟DOM不存在；</li><li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM <strong>差异</strong>增删改+排版与重绘（可能比直接操作真实DOM要少）”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li></ul><p>传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。</p><p>当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程。</p><p>而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算。</p><h2 id="VDOM-和-DOM-优缺点"><a href="#VDOM-和-DOM-优缺点" class="headerlink" title="VDOM 和 DOM 优缺点"></a>VDOM 和 DOM 优缺点</h2><p>真实 DOM 的优势：</p><ul><li>易用</li></ul><p>真实 DOM 的缺点：</p><ul><li>效率低，解析速度慢，内存占用量过高</li><li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li></ul><p>虚拟 DOM 的优势：</p><ul><li>简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难</li><li>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能</li><li>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行</li></ul><p>虚拟 DOM 的缺点：</p><ul><li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li></ul><h2 id="react-的生命周期"><a href="#react-的生命周期" class="headerlink" title="react 的生命周期"></a>react 的生命周期</h2><p><a href="https://link.juejin.cn/?target=https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">react生命周期图解</a></p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p><ul><li>constructor()</li><li>static getDerivedStateFromProps()</li><li>render()</li><li>componentDidMount()</li></ul><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><p>该方法是新增的生命周期方法，是一个静态的方法，因此<strong>不能访问到组件的实例</strong>。</p><p>执行时机：组件创建和更新阶段，不论是props变化还是state变化，都会调用。</p><p><strong>在每次render方法前调用</strong>，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和 state来加一些限制条件，防止无用的state更新</p><p>该方法<strong>需要返回一个新的对象作为新的state或者返回null表示state状态不需要更新</strong></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ul><h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h4><p>该周期函数在render后执行，执行之时DOM元素还没有被更新</p><p>该方法返回的一个Snapshot值(不返回报错)，作为componentDidUpdate第三个参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;#enter getSnapshotBeforeUpdate&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>&#125;<br><br><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;#enter componentDidUpdate snapshot = &#x27;</span>, snapshot);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法的目的在于获取组件<strong>更新前的一些信息</strong>，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>当组件从 DOM 中移除时会调用如下方法：</p><ul><li>componentWillUnmount()</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p><ul><li>static getDerivedStateFromError()：更改状态，从而显示降级组件</li><li>componentDidCatch()：打印错误信息</li></ul><p><a href="https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/react-component.html">各生命周期的具体作用看这里</a></p><h2 id="React父子组件的生命周期调用顺序"><a href="#React父子组件的生命周期调用顺序" class="headerlink" title="React父子组件的生命周期调用顺序"></a>React父子组件的生命周期调用顺序</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-comment">//parent组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>=&#123;&#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent constructor&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent getDerivedStateFromProps&#x27;</span>)<br>        <span class="hljs-keyword">return</span> &#123;&#125;<br>    &#125;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent didMount&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent willUnmount&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent scu&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent render&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Son</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Parent</span><br><br><span class="hljs-comment">//son 组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>=&#123;&#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son constructor&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son getDerivedStateFromProps&#x27;</span>)<br>        <span class="hljs-keyword">return</span> &#123;&#125;<br>    &#125;<br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son willUnmount&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son didMount&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son scu&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;son render&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>son<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Son</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">kotlin复制代码parent <span class="hljs-keyword">constructor</span><br>parent getDerivedStateFromProps<br>parent render<br>son <span class="hljs-keyword">constructor</span><br>son getDerivedStateFromProps<br>son render<br><span class="hljs-comment">// 注意</span><br>son didMount<br>parent didMount<br>son willUnmount<br>parent willUnmount<br></code></pre></td></tr></table></figure><h2 id="React事件和原生事件执行顺序"><a href="#React事件和原生事件执行顺序" class="headerlink" title="React事件和原生事件执行顺序"></a>React事件和原生事件执行顺序</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-comment">// React 事件和原生事件的执行顺序</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventRunOrder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dom parent&#x27;</span>)<br>        &#125;)<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dom child&#x27;</span>)<br>        &#125;)<br><br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;document&#x27;</span>)<br>        &#125;)<br>    &#125;<br><br>    childClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;react child&#x27;</span>)<br>    &#125;<br><br>    parentClick = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;react parent&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.parentClick&#125;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref</span> =&gt;</span> this.parent = ref&#125;&gt;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.childClick&#125;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref</span> =&gt;</span> this.child = ref&#125;&gt;</span><br><span class="language-xml">                    test</span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">EventRunOrder</span><br>javascript复制代码dom child<br>dom parent<br>react child<br>react parent<br><span class="hljs-variable language_">document</span><br></code></pre></td></tr></table></figure><p>react所有事件都挂载在document上，当真实dom触发后冒泡到document后才会对react事件进行处理，所以：</p><ul><li>原生事件先执行</li><li>react合成事件再执行</li><li>document上挂载的事件最后执行</li></ul><h2 id="react的事件机制"><a href="#react的事件机制" class="headerlink" title="react的事件机制"></a>react的事件机制</h2><p>react实现了一套自己的事件机制，包括事件注册、事件合成、事件冒泡、事件派发等。在react中这套事件被称为合成事件。</p><p>合成事件是 React模拟原生 DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器</p><p>根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-keyword">const</span> button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果想要获得原生DOM事件，可以通过e.nativeEvent属性获取:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">nativeEvent</span>);;<br><span class="hljs-keyword">const</span> button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>按钮&lt;/button</span><br></code></pre></td></tr></table></figure><p>从上面可以看到React事件和原生事件也非常的相似，但也有一定的区别：</p><ul><li>事件名称命名方式不同:react采用小驼峰格式</li><li>事件处理函数书写不同：react使用{}，而原生事件使用双引号</li></ul><p>虽然onclick看似绑定到DOM元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听。</p><p>这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。</p><p>当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</p><p>所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：</p><ul><li>阻止合成事件间的冒泡，用e.stopPropagation()</li><li>阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()</li><li>阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免</li></ul><img src="/2022/11/23/%E6%8E%98%E9%87%91-React/11/23/%E6%8E%98%E9%87%91-React/5d1f6c67acba46d7952de3f5f367e30etplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" class title="阻止冒泡"><p>综上所述：</p><ul><li>React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)</li><li>React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。</li><li>React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback</li><li>React 有一套自己的合成事件 SyntheticEvent</li></ul><h2 id="函数组件和类组件输出差别（闭包陷阱）"><a href="#函数组件和类组件输出差别（闭包陷阱）" class="headerlink" title="函数组件和类组件输出差别（闭包陷阱）"></a>函数组件和类组件输出差别（闭包陷阱）</h2><p>以下函数组件代码，先alert再add，页面显示的值和alert的值分别是什么</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">FunctionComponentClosure</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">log</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(value)<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;log&#125;</span>&gt;</span>alert<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setValue(value + 1)&#125;&gt;add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>  <span class="hljs-title class_">FunctionComponentClosure</span><br></code></pre></td></tr></table></figure><p>alert ：1</p><p>页面显示：2</p><p>原因：log方法内的value和<strong>点击动作触发时</strong>的value相同，后续value的变化不会对log内部的value产生任何的影响。这种现象被称为 <strong>闭包陷阱</strong>，即函数式组件每次render都产生一个新的log函数，这个log函数会产生一个当前阶段value值的闭包。</p><p>除了闭包陷阱之外，函数组件和类组件还存在如下区别：</p><ul><li>写法不同：函数组件代码更加简洁</li><li>函数组件不需要处理this但是类组件需要</li><li>类组件有生命周期和state函数组件不存在（但是函数组件中可以通过hooks达到类似的效果）</li></ul><h3 id="如何解决闭包陷阱"><a href="#如何解决闭包陷阱" class="headerlink" title="如何解决闭包陷阱"></a>如何解决闭包陷阱</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">const</span> <span class="hljs-title function_">Test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(value)<br><br>    <span class="hljs-keyword">const</span> log = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(countRef.<span class="hljs-property">current</span>)<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        countRef.<span class="hljs-property">current</span> = value<br>    &#125;, [value])<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;log&#125;</span>&gt;</span>alert<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setValue(value + 1)&#125;&gt;add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>useRef每次render都会返回同一个引用类型对象，设置和读取都在这个对象上处理的话，就可以得到最新的value值了。</p><p>在类组件中情况是否会相同呢？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    log = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>)<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.log&#125;</span>&gt;</span>alert<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(&#123;</span><br><span class="language-xml">                    value: this.state.value + 1</span><br><span class="language-xml">                &#125;)&#125;&gt;add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Test</span><br></code></pre></td></tr></table></figure><p>alert和页面显示的值相同。</p><h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h2><p>受控组件：简单理解为<strong>双向绑定</strong>，数据和视图的变化是同步的，受控组件一般需要<strong>初始状态（value或者checked）</strong> 和一个 <strong>状态更新事件函数</strong>。</p><p>非受控组件：不受控制的组件，在其内部存储自身的状态，可以通过ref查询DOM的当前值。<strong>初始状态为defaultValue</strong></p><p>推荐使用受控组件，在受控组件中数据由React组件处理。</p><p>操作DOM的情况下一般需要使用非受控组件，数据由DOM本身处理，控制能力较弱，但是代码量更少。</p><h2 id="React如何实现状态自动保存（vue中的keep-alive）"><a href="#React如何实现状态自动保存（vue中的keep-alive）" class="headerlink" title="React如何实现状态自动保存（vue中的keep-alive）"></a>React如何实现状态自动保存（vue中的keep-alive）</h2><h3 id="为什么需要状态保存"><a href="#为什么需要状态保存" class="headerlink" title="为什么需要状态保存"></a>为什么需要状态保存</h3><p>在React中通常使用路由去管理不同的页面，在切换页面时，路由将会卸载掉未匹配的页面组件，所以比如从列表进入详情页面，等到退回列表页面时会回到列表页的顶部。</p><h3 id="什么情况下需要状态保存"><a href="#什么情况下需要状态保存" class="headerlink" title="什么情况下需要状态保存"></a>什么情况下需要状态保存</h3><ul><li>列表进入详情</li><li>已填写但是未提交的表单</li><li>管理系统中可切换和关闭的标签</li></ul><p>总而言之就是在交互过程中离开需要对状态进行保存的场景。</p><h3 id="React为什么不支持"><a href="#React为什么不支持" class="headerlink" title="React为什么不支持"></a>React为什么不支持</h3><p>状态保存在vue中可以使用keep-alive进行实现，但是react认为这个功能容易造成内存泄漏，所以暂时不支持。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><ol><li><p>手动保存状态：适用于数据较少的情况</p><p>在componentWillUnmount的时候将状态通过redux进行保存，然后在componentDidMount周期进行数据恢复。</p></li><li><p>通过路由实现：</p><p>基本思想是，将KeepAlive中的组件也就是children取出来，渲染到一个不会被卸载的组件keeper中，在使用Dom操作将keeper内的真实内容移入对应的keepalive</p></li></ol><h2 id="useEffect和useLayoutEffect有什么区别"><a href="#useEffect和useLayoutEffect有什么区别" class="headerlink" title="useEffect和useLayoutEffect有什么区别"></a>useEffect和useLayoutEffect有什么区别</h2><p>相同点：</p><ul><li>处理副作用：函数组件内不允许操作副作用。比如：改变DOM、设置订阅、操作定时器等</li><li>底层都是调用mountEffectlmpl方法，基本上可以替换使用</li></ul><p>不同点：</p><ul><li>useEffect在像素变化之后异步调用，改变屏幕内容可能会造成页面的闪烁</li><li>useLayoutEffect在像素变化之前同步调用，可能会造成页面延迟显示，但是不会闪烁：主要用于处理<strong>DOM操作、调整样式、避免页面闪烁等</strong>。因为是同步执行，所以要避免做大量计算，从而避免造成阻塞。</li><li>useLayoutEffect先于useEffect执行</li></ul><h2 id="对react-hook的理解，解决了什么问题"><a href="#对react-hook的理解，解决了什么问题" class="headerlink" title="对react hook的理解，解决了什么问题"></a>对react hook的理解，解决了什么问题</h2><p>官方给出的动机是解决长时间使用和维护react过程中常遇到的问题，例如：</p><ul><li>难以重用和共享组件中的与状态相关的逻辑</li><li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</li><li>类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题</li><li>由于业务变动，函数组件不得不改为类组件等等</li></ul><p>在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作</p><p>在有了hooks之后，函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理。</p><p>hooks的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用hooks能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑hooks。</p><h2 id="React常用的hooks"><a href="#React常用的hooks" class="headerlink" title="React常用的hooks"></a>React常用的hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>定义状态，解决了函数组件没有状态的问题。</p><p>接受一个初始值（初始值可以是一个<strong>具体数据类型</strong>，也可以是一个<strong>函数</strong>，该函数只执行一次返回值作为初始值）作为参数，返回一个数组，第一项是变量，第二项是设置变量的函数。</p><ul><li><p>对象<strong>不可局部更新</strong>：state是一个对象时，不能局部更新对象属性，<code>useState</code>不会合并，会把整个对象覆盖。要用展开运算符自己进行属性值的覆盖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码    <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;)<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeState</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;tom&quot;</span>&#125;) <span class="hljs-comment">//覆盖整个state</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>地址要变更</strong>：对于引用类型，数据地址不变的时候，认为数据没有变化，不会更新视图。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码    <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;)<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeState</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> obj = state <span class="hljs-comment">//obj和state指向同一个地址</span><br>        obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span><br>        <span class="hljs-title function_">setState</span>(obj) <span class="hljs-comment">// 地址没有变更，不会更新</span><br>    &#125;<br>   <br></code></pre></td></tr></table></figure></li><li><p><code>useState</code> 传入一个函数：<code>useState</code>初始化是惰性的，<code>initialState</code>只有在初始渲染中起作用，<em>后续渲染会被忽略</em>，如果初始state需要通过复杂的计算获得，可以传入一个函数，在函数中计算并返回初始state，次函数只在初始渲染时被调用。</p></li><li><p><code>useState</code>异步回调问题：如何获取到更新后的state，使用<code>useEffect</code>，当<code>state</code>变化时触发</p></li><li><p>操作合并：传入对象会被合并，传入函数，使用<code>preState</code>参数不会被合并</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码 <span class="hljs-title function_">setState</span>(&#123;<br>          ...state,<br>            <span class="hljs-attr">name</span>: state.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span><br>         &#125;)<br>         <span class="hljs-title function_">setState</span>(&#123;<br>            ...state,<br>            <span class="hljs-attr">name</span>: state.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span><br>        &#125;)<br>         <span class="hljs-title function_">setState</span>(&#123;<br>            ...state,<br>            <span class="hljs-attr">name</span>: state.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span><br>        &#125;)<br>        <br>        <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> (&#123; ...state, <span class="hljs-attr">name</span>: pre.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span> &#125;))<br>        <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> (&#123; ...state, <span class="hljs-attr">name</span>: pre.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span> &#125;))<br>        <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> (&#123; ...state, <span class="hljs-attr">name</span>: pre.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span> &#125;))<br></code></pre></td></tr></table></figure></li></ul><h4 id="对比类组件的state"><a href="#对比类组件的state" class="headerlink" title="对比类组件的state"></a>对比类组件的state</h4><ol><li>在正常的<strong>react的事件流里</strong>（如onClick等）：<ul><li>setState和useState是<strong>异步执行</strong>的（不会立即更新state的结果）</li><li>多次执行setState和useState，<strong>只会调用一次重新渲染render</strong></li><li>传入对象会被合并，函数则不会被合并。<strong>可以通过setState传入一个函数来更新state，这样不会被合并</strong></li></ul></li><li>在setTimeout，Promise.then等<strong>异步事件</strong>中：<ul><li>setState和useState是<strong>同步执行</strong>的（立即更新state的结果）</li><li>多次执行setState和useState，每一次的执行setState和useState，都会调用一次render</li></ul></li></ol><h4 id="setState执行机制（类组件）"><a href="#setState执行机制（类组件）" class="headerlink" title="setState执行机制（类组件）"></a>setState执行机制（类组件）</h4><p>通过setState来修改组件内部的state，并且触发render方法进行视图的更新。</p><p>直接修改state不会引起视图的更新，因为react没有像vue一样通过proxy或者definProperty监听数据变化，必须通过setState方法来告知react组件state已经发生了改变。</p><p>关于state方法的定义是从React.Component中继承，定义的源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) &#123;<br>  <span class="hljs-title function_">invariant</span>(<br>    <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&#x27;object&#x27;</span> ||<br>      <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&#x27;function&#x27;</span> ||<br>      partialState == <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;setState(...): takes an object of state variables to update or a &#x27;</span> +<br>      <span class="hljs-string">&#x27;function which returns an object of state variables.&#x27;</span>,<br>  );<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面可以看到setState第一个参数可以是一个对象，或者是一个函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据。</p><h5 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h5><ul><li>在组件生命周期或React合成事件中，setState是异步。要想获取更新后的值，可以通过setState的第二个参数传入一个函数（函数组件通过useEffect）。</li><li>在setTimeout或者原生dom事件中，setState是同步。</li></ul><h5 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h5><ul><li>合成事件或者生命周期中setState传入对象会被合并。要想避免合并可以将第一个参数写成函数。</li><li>而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象。</li></ul><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>给没有生命周期的组件添加结束渲染的信号，在<strong>渲染结束后执行</strong>。</p><ul><li><p>如果<strong>不接受第二个参数</strong>，那么在<strong>第一次渲染完成之后</strong>和<strong>每次更新渲染页面</strong>的时候，都会调用<code>useEffect</code>的回调函数。</p></li><li><p>可以对<strong>第二个参数传入一个数组</strong>，这个数组表示的是更新执行所依赖的列表，只有<strong>依赖列表改变时</strong>（数组中的任意一项变化时），才会触发回调函数</p></li><li><p><strong>第二项是一个空数组</strong>：只在第一次渲染完成时执行。相当于didMounted</p></li><li><p>清除副作用：比如绑定了自定义DOM 事件以防止内存泄漏</p><p>如何清除：<code>clean-up</code> 函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,func);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>         <span class="hljs-comment">//  在每次执行useEffect之前都会执行上一次return中内容</span><br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,func)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>异步操作：useEffect返回的是clean-up函数，因此没有办法返回一个promise实现异步</p><ul><li><p>立即执行函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">anyNameFunction</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadContent</span>();<br>    &#125;)();<br>  &#125;, []);<br></code></pre></td></tr></table></figure></li><li><p>在useEffect外部或者内部实现async&#x2F;await函数，然后在内部调用</p></li></ul></li></ul><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>共享状态钩子。不同组件之间共享状态，避免props层层传递</p><ul><li><code>React.createContext</code></li><li><code>Context.Provider</code></li></ul><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>Action钩子，复杂版的<code>useState</code></p><p><code>redux</code>的原理是用户在页面中发起<code>action</code>,从而通过<code>reducer</code>方法来改变<code>state</code>,从而实现页面和状态的通信。而<code>Reducer</code>的形式是<code>(state, action) =&gt; newstate</code>。类似，我们的<code>useReducer()</code>是这样的：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState)<br></code></pre></td></tr></table></figure><h3 id="自己创建hooks"><a href="#自己创建hooks" class="headerlink" title="自己创建hooks"></a>自己创建hooks</h3><p>自己创建hooks就是一个将公共代码封装的过程，比如一个hooks输出一个鼠标位置坐标，可以如下实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMousePosition</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [position, setPosition] = <span class="hljs-title function_">useState</span>(&#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span><br>  &#125;)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">move</span> = (<span class="hljs-params">e</span>) =&gt; &#123;<br>      <span class="hljs-title function_">setPosition</span>(&#123; <span class="hljs-attr">x</span>: e.<span class="hljs-property">x</span>, <span class="hljs-attr">y</span>: e.<span class="hljs-property">y</span> &#125;)<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, move)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, move)<br>    &#125;<br>  &#125;, [])<br>  <span class="hljs-keyword">return</span> position<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br> <span class="hljs-keyword">const</span> position = <span class="hljs-title function_">useMousePosition</span>()<br></code></pre></td></tr></table></figure><h2 id="useEffect的触发时机"><a href="#useEffect的触发时机" class="headerlink" title="useEffect的触发时机"></a>useEffect的触发时机</h2><p>或者可以问：</p><ul><li>数组可不可以什么都不传</li><li>数组里边内容如何确定</li></ul><p>触发机制跟第二个参数有关：</p><ul><li>第二个参数不传时：每次渲染完成后触发</li><li>第二个参数是一个空数组时：初始化渲染完成后触发，相当于didMounted</li><li>第二个参数是非空数组时：数组中数据有一项更新时触发</li></ul><p>数组中的内容一般是props或者state，<em>是普通变量时不会触发执行</em>。</p><h2 id="useEffect的第一个函数返回一个函数"><a href="#useEffect的第一个函数返回一个函数" class="headerlink" title="useEffect的第一个函数返回一个函数"></a>useEffect的第一个函数返回一个函数</h2><p>返回一个clean-up 函数，用来清除副作用。clean-up的执行时机是每个useEffect执行前会执行上一个effect返回的clean-up函数。</p><h2 id="hooks使用规则"><a href="#hooks使用规则" class="headerlink" title="hooks使用规则"></a>hooks使用规则</h2><ul><li>Hooks只在<strong>函数组件</strong>的<strong>顶层调用</strong>，不要在循环、条件判断或者嵌套函数中调用钩子。在类组件中无法使用。</li><li>对于自定义Hooks，使用use开头命名。</li></ul><p>要 Hook 的调用顺序在多次渲染之间保持一致，React 就能<strong>正确地将内部 state 和对应的 Hook 进行关联</strong>。但如果我们将一个 Hook  调用放到一个条件语句中会发生什么呢？</p><p><a href="https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/hooks-rules.html%23explanation">详解看这里</a></p><h2 id="useMemo、memo、useCallback"><a href="#useMemo、memo、useCallback" class="headerlink" title="useMemo、memo、useCallback"></a>useMemo、memo、useCallback</h2><p>他们三个的应用场景都是缓存结果，当依赖值没有改变时避免不必要的计算或者渲染。</p><ul><li>useCallback 是针对<strong>函数</strong>进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。</li><li>React.memo 是对<strong>组件</strong>进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。</li><li>React.useMemo是针对 <strong>值计算</strong> 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo</li></ul><p><strong>useMemo与useEffect的区别</strong></p><p>传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p><p>useEffect在渲染后执行，可以访问渲染后的值。</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。和useEffect类似，但是如果每次渲染时都计算，那就没必要使用useMemo了。</p><h2 id="ref使用场景"><a href="#ref使用场景" class="headerlink" title="ref使用场景"></a>ref使用场景</h2><p>使用场景：直接使用<strong>dom元素的某个方法</strong>，或者直接使用<strong>自定义组件中的某个方法</strong>。在以下场景会用到ref:</p><ul><li>对Dom元素的焦点控制、内容选择、控制</li><li>对Dom元素的内容设置及媒体播放</li><li>对Dom元素的操作和对组件实例的操作</li><li>集成第三方 DOM 库</li></ul><p>ref作用于不同的组件时：</p><ol><li>作用于内置的html组件，得到的是真实的dom</li><li>ref作用于类组件，得到的是类的实例</li><li><strong>ref不能作用于函数组件</strong></li></ol><p>使用ref的模式有：</p><ul><li><p>字符串：传入字符串，使用时通过 this.refs.“传入的字符串”的格式获取对应的元素。不再推荐使用，可能会被移除</p></li><li><p>对象：传入通过 React.createRef() 方式创建出来的对象，使用时获取到创建的对象中存在 current 属性就是对应的元素</p></li><li><p>函数：<code>ref=&#123;(el) =&gt; &#123;this.txt = el;&#125;&#125;</code></p></li><li><p>传入hook，hook是通过 useRef() 方式创建，使用时通过生成hook对象的 current 属性就是对应的元素</p></li><li><p>ref转发：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params">props, ref</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props, ref)<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 传递函数组件，得到一个新的组件，不能传递类组件，并且函数组件必须使用第二个</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">NewA</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(A)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>  <span class="hljs-title class_">ARef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>  <br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">ARef</span>) <span class="hljs-comment">// &#123;current: h1&#125;</span><br>  &#125;<br>  <br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">NewA</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.ARef&#125;</span> <span class="hljs-attr">words</span>=<span class="hljs-string">&quot;sdfsd&quot;</span>/&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用：useImperativeHandle定义方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">show</span>: <span class="hljs-function">(<span class="hljs-params">title, content</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">setVisible</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-title function_">setTitle</span>(title);<br>      <span class="hljs-title function_">setContent</span>(content);<br>    &#125;,<br>    <span class="hljs-attr">hide</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setVisible</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;));<br></code></pre></td></tr></table></figure></li></ul><h2 id="state和props有什么区别"><a href="#state和props有什么区别" class="headerlink" title="state和props有什么区别"></a>state和props有什么区别</h2><p>一个组件的数据可以来源于组件内部，也可以来源于组件外部(比如父组件)。</p><p>组件内部的状态就是state，一般在constructor中定义。通过setState修改，会调用render方法重新渲染组件。 setState 还可以接受第二个参数，它是一个函数，会在 setState 调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成。</p><p>组件外部定义的状态是props，组件中的props不可以修改，只能通过传入新的props。</p><p>相同点：</p><ul><li>两者都是 JavaScript 对象</li><li>两者都是用于保存状态</li><li>props 和 state 都能触发渲染更新</li></ul><p>区别：</p><ul><li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li><li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改 state 是多变的、可以修改</li></ul><h2 id="super和super-props-的区别"><a href="#super和super-props-的区别" class="headerlink" title="super和super(props)的区别"></a>super和super(props)的区别</h2><p>在ES6的class中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">sup</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">printName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">sup</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// super代表的是父类的构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-title function_">printAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> jack = <span class="hljs-keyword">new</span> <span class="hljs-title function_">sub</span>(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">20</span>);<br>jack.<span class="hljs-title function_">printName</span>(); <span class="hljs-comment">//输出 : jack</span><br>jack.<span class="hljs-title function_">printAge</span>(); <span class="hljs-comment">//输出 : 20</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，可以看到通过 super 关键字实现调用父类，super 代替的是父类的构建函数，使用 super(name) 相当于调用<code>sup.prototype.constructor.call(this,name)</code></p><p>如果在子类中不使用 super关键字，则会引发报错，报错的原因是<strong>子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工。</strong></p><p>而 super() 就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象。</p><p>如果先调用 this，再初始化 super()，同样是禁止的行为。所以在子类 constructor 中，必须先代用 super 才能引用 this。</p><p>在 React 中，类组件是基于 ES6 的规范实现的，继承 React.Component，因此如果用到 constructor 就必须写 super() 才初始化 this。</p><p>这时候，在调用 super() 的时候，我们一般都需要传入 props 作为参数，如果不传进去，React 内部也会将其定义在组件实例中。 所以无论有没有 constructor，在 render 中 this.props 都是可以使用的，这是 React 自动附带的，是可以不写的。</p><p>综上所述：</p><ul><li>在 React 中，类组件基于 ES6，所以在 constructor 中必须使用 super</li><li>在调用 super 过程，无论是否传入 props，React 内部都会将 porps 赋值给组件实例 porps 属性中</li><li>如果只调用了 super()，那么 this.props 在 super() 和构造函数结束之间仍是 undefined</li></ul><h2 id="react引入css的方式有哪些"><a href="#react引入css的方式有哪些" class="headerlink" title="react引入css的方式有哪些"></a>react引入css的方式有哪些</h2><p>组件式开发选择合适的css解决方案尤为重要</p><p>通常会遵循以下规则：</p><ul><li>可以编写局部css，不会随意污染其他组件内的原生；</li><li>可以编写动态的css，可以获取当前组件的一些状态，根据状态的变化生成不同的css样式；</li><li>支持所有的css特性：伪类、动画、媒体查询等；</li><li>编写起来简洁方便、最好符合一贯的css风格特点</li></ul><p>在这一方面，vue使用css起来更为简洁：</p><ul><li>通过 style 标签编写样式</li><li>scoped 属性决定编写的样式是否局部有效</li><li>lang 属性设置预处理器</li><li>内联样式风格的方式来根据最新状态设置和改变css</li></ul><p>而在react中，引入CSS就不如Vue方便简洁，其引入css的方式有很多种，各有利弊</p><p>常见的CSS引入方式有以下：</p><ul><li><p>行内样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码&lt;<span class="hljs-selector-tag">div</span> style=&#123;&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-string">&#x27;200px&#x27;</span>,<br>    height:<span class="hljs-string">&#x27;80px&#x27;</span>, 　　　　<br>&#125;&#125;&gt;测试数据&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>组件中引入 .css 文件</p></li><li><p>组件中引入 .module.css 文件</p></li><li><p>CSS in JS</p></li></ul><p>通过上面四种样式的引入，各自的优缺点：</p><ul><li>在组件内直接使用css该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱</li><li>组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠</li><li>引入.module.css 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写</li><li>通过css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</li></ul><h2 id="react事件绑定方式有哪些"><a href="#react事件绑定方式有哪些" class="headerlink" title="react事件绑定方式有哪些"></a>react事件绑定方式有哪些</h2><h3 id="绑定方式"><a href="#绑定方式" class="headerlink" title="绑定方式"></a>绑定方式</h3><ul><li>render方法中使用bind<ul><li><code>&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;test&lt;/div&gt;</code>。</li><li>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</li></ul></li><li>render方法中使用箭头函数<ul><li><code>&lt;div onClick=&#123;e =&gt; this.handleClick(e)&#125;&gt;test&lt;/div&gt;</code></li><li>每一次render的时候都会生成新的方法，影响性能</li></ul></li><li>constructor中bind：<code>this.handleClick = this.handleClick.bind(this);</code></li><li>定义阶段使用箭头函数绑定</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>编写方面：方式一、方式二、方式四写法简单，方式三的编写过于冗杂</li><li>性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例</li></ul><p>综合上述，方式四是最优的事件绑定方式。</p><h2 id="react组件的创建方式以及区别"><a href="#react组件的创建方式以及区别" class="headerlink" title="react组件的创建方式以及区别"></a>react组件的创建方式以及区别</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><ul><li>函数组件：通过一个函数，return 一个jsx语法声明的结构</li><li>React.createClass 方法创建：语法冗余，目前已经不太使用</li><li>继承 React.Component 创建的类组件：最终会被编译成createClass</li></ul><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p>由于React.createClass创建的方式过于冗杂，并不建议使用。</p><p>而像函数式创建和类组件创建的区别主要在于需要创建的组件是否需要为有状态组件：对于一些无状态的组件创建，建议使用函数式创建的方式。</p><p>在考虑组件的选择原则上，能用无状态组件则用无状态组件。</p><p>不过，由于react hooks的出现，函数式组件创建的组件通过使用hooks方法也能使之成为有状态组件，再加上目前推崇函数式编程，所以这里建议都使用函数式的方式来创建组件。</p><h2 id="react-中组件之间如何通信"><a href="#react-中组件之间如何通信" class="headerlink" title="react 中组件之间如何通信"></a>react 中组件之间如何通信</h2><p>组件传递的方式有很多种，根据传送者和接收者可以分为如下：</p><ul><li>父组件向子组件传递：props</li><li>子组件向父组件传递：父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值</li><li>兄弟组件之间的通信：状态提升，在公共的父组件中进行状态定义</li><li>父组件向后代组件传递：React.createContext创建一个context进行组件传递</li><li>非关系组件传递：redux</li></ul><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><p>通过使用React.createContext创建一个context</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码 <span class="hljs-keyword">const</span> <span class="hljs-title class_">PriceContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;price&#x27;</span>)<br></code></pre></td></tr></table></figure><p>context创建成功后，其下存在Provider组件用于创建数据源，Consumer组件用于接收数据，使用实例如下：</p><p>Provider组件通过value属性用于给后代组件传递数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码&lt;<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-number">100</span>&#125;&gt;<br>&lt;/<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Provider</span>&gt;<br></code></pre></td></tr></table></figure><p>如果想要获取Provider传递的数据，可以通过Consumer组件或者或者使用contextType属性接收，对应分别如下：</p><p>contextType:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">PriceContext</span>;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> price = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>;<br>    <span class="hljs-comment">/* 基于这个值进行渲染工作 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Consumer组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码&lt;<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Consumer</span>&gt;<br>    &#123; <span class="hljs-comment">/*这里是一个函数*/</span> &#125;<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-params">price</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>price：&#123;price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&lt;/<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Consumer</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="React中key的作用"><a href="#React中key的作用" class="headerlink" title="React中key的作用"></a>React中key的作用</h2><p><a href="https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/reconciliation.html%23the-diffing-algorithm">官网中</a>对于diff有如下规则：</p><ul><li>对比不同类型的元素：当元素类型变化时，会销毁重建</li><li>对比同一类型的元素：当元素类型不变时，比对及更新有改变的属性并且“在处理完当前节点之后，React 继续对子节点进行递归。”</li><li>对子节点进行递归：React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。若key一致，则进行更新，若key不一致，就销毁重建</li></ul><h2 id="react函数组件和类组件的区别"><a href="#react函数组件和类组件的区别" class="headerlink" title="react函数组件和类组件的区别"></a>react函数组件和类组件的区别</h2><p>针对两种React组件，其区别主要分成以下几大方向：</p><ul><li><strong>编写形式</strong>：类组件的编写形式更加的冗余</li><li><strong>状态管理</strong>：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态</li><li><strong>生命周期</strong>：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果</li><li><strong>调用方式</strong>：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法</li><li><strong>获取渲染的值</strong>：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）</li></ul><h2 id="react高阶组件以及应用场景"><a href="#react高阶组件以及应用场景" class="headerlink" title="react高阶组件以及应用场景"></a>react高阶组件以及应用场景</h2><h3 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h3><p>js高阶函数（Higher-order function），至少满足下列一个条件的函数</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>在React中，高阶组件是参数为组件，返回值为新组件的函数。本质也就是一个函数，并不是一个组件。高阶组件的这种实现方式，本质上是一个装饰者设计模式。</p><h3 id="怎么写高阶组件"><a href="#怎么写高阶组件" class="headerlink" title="怎么写高阶组件"></a>怎么写高阶组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-title class_">WrappedComponent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> /&gt;</span></span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对传入的原始组件 WrappedComponent 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 EnhancedComponent。</p><p>把<strong>通用的逻辑</strong>放在高阶组件中，对组件实现一致的处理，从而实现代码的复用。所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用。</p><h3 id="高阶组件遵循的规则"><a href="#高阶组件遵循的规则" class="headerlink" title="高阶组件遵循的规则"></a>高阶组件遵循的规则</h3><p><a href="https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/higher-order-components.html%23gatsby-focus-wrapper">官网</a></p><ul><li>不要改变原始组件，而应该使用组合</li><li>HOC 应该透传与自身无关的 props</li><li>包装显示名字以便于调试</li><li>不要在 render() 方法中使用高阶组件：这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</li><li>Refs 不会被传递：ref 实际上并不是一个 prop（就像 key 一样），它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</li></ul><p>高阶组件可以传递所有的props，但是不能传递ref，传毒ref可以使用React.forwardRef：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">withLogging</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Enhance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">WrappedComponent</span> &#123;<br>        <span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current props&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Next props&#x27;</span>, nextProps);<br>        &#125;<br>        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>            <span class="hljs-comment">// 把 forwardedRef 赋值给 ref</span><br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...rest</span>&#125; <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;forwardedRef&#125;</span> /&gt;</span></span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span><br>    <span class="hljs-comment">// 所以这边的 ref 是由 React.forwardRef 提供的</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">forwardRef</span>(<span class="hljs-params">props, ref</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Enhance</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">forwardRef</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(forwardRef);<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withLogging</span>(<span class="hljs-title class_">SomeComponent</span>);<br></code></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>通过上面的了解，高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等。</p><h2 id="react组件间的过度动画如何实现"><a href="#react组件间的过度动画如何实现" class="headerlink" title="react组件间的过度动画如何实现"></a>react组件间的过度动画如何实现</h2><p>在日常开发中，页面切换时的转场动画是比较基础的一个场景。</p><p>当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验。</p><p>在react中实现过渡动画效果会有很多种选择，如react-transition-group，react-motion，Animated，以及原生的CSS都能完成切换动画。</p><p>在react中，<strong>react-transition-group</strong>是一种很好的解决方案，其为元素添加enter，enter-active，exit，exit-active这一系列勾子</p><p>可以帮助我们方便的实现组件的入场和离场动画</p><p>其主要提供了三个主要的组件：</p><ul><li>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</li><li>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</li><li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li></ul><p>安装：</p><blockquote><p>npm install react-transition-group –save npm i –save-dev @types&#x2F;react-transition-group</p></blockquote><h3 id="CSSTransition"><a href="#CSSTransition" class="headerlink" title="CSSTransition"></a>CSSTransition</h3><p>其实现动画的原理在于，当CSSTransition的in属性置为true时，CSSTransition首先会给其子组件加上xxx-enter、xxx-enter-active的class执行动画</p><p>当动画执行结束后，会移除两个class，并且添加-enter-done的class</p><p>所以可以利用这一点，通过css的transition属性，让元素在两个状态之间平滑过渡，从而得到相应的动画效果</p><p>当in属性置为false时，CSSTransition会给子组件加上xxx-exit和xxx-exit-active的class，然后开始执行动画，当动画结束后，移除两个class，然后添加-exit-done的class</p><p>如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CSSTransition</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssTransitionCom</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [show, setShow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleShow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-title function_">setShow</span>(!show)<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">margin:</span> &quot;<span class="hljs-attr">20px</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleShow&#125;</span>&gt;</span>toggleShow CSSTransition<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">in</span>=<span class="hljs-string">&#123;show&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">classNames</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">CSSTransition</span>&#x27;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">unmountOnExit</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello CSSTransition<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CssTransitionCom</span><br></code></pre></td></tr></table></figure><p>对应css样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<span class="hljs-selector-class">.CSSTransition-enter</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.CSSTransition-enter-active</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br><br><span class="hljs-selector-class">.CSSTransition-enter-done</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: cadetblue;<br>&#125;<br><br><span class="hljs-selector-class">.CSSTransition-exit</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-selector-class">.CSSTransition-exit-active</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SwitchTransition"><a href="#SwitchTransition" class="headerlink" title="SwitchTransition"></a>SwitchTransition</h3><p>SwitchTransition可以完成两个组件之间切换的炫酷动画</p><p>比如有一个按钮需要在on和off之间切换，我们希望看到on先从左侧退出，off再从右侧进入</p><p>SwitchTransition中主要有一个属性mode，对应两个值：</p><ul><li>in-out：表示新组件先进入，旧组件再移除；</li><li>out-in：表示旧组件先移除，新组件再进入</li></ul><p><strong>SwitchTransition组件里面要有CSSTransition，不能直接包裹你想要切换的组件</strong></p><p>里面的CSSTransition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是key属性</p><p>下面给出一个按钮入场和出场的示例，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">SwitchTransition</span>, <span class="hljs-title class_">CSSTransition</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-transition-group&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchAnimation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span>&lt;&#123;&#125;, &#123; <span class="hljs-attr">isOn</span>: boolean &#125;&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props: &#123;&#125;</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">isOn</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">btnClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">isOn</span>: !<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isOn</span> &#125;)<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; isOn &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;<br><br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">margin:</span> &quot;<span class="hljs-attr">20px</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">SwitchTransition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span> <span class="hljs-attr">classNames</span>=<span class="hljs-string">&quot;SwitchAnimation&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;500&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                        <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;isOn</span> ? &quot;<span class="hljs-attr">SwitchAnimation-on</span>&quot; <span class="hljs-attr">:</span> &quot;<span class="hljs-attr">SwitchAnimation-off</span>&quot;&#125;&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this)&#125;</span>&gt;</span></span><br><span class="language-xml">                            &#123;isOn ? &quot;SwitchAnimation-on&quot; : &quot;SwitchAnimation-off&quot;&#125;</span><br><span class="language-xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">SwitchTransition</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>css文件对应如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<br><span class="hljs-selector-class">.SwitchAnimation-enter</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.SwitchAnimation-enter-active</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br><br><span class="hljs-selector-class">.SwitchAnimation-exit</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-class">.SwitchAnimation-exit-active</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TransitionGroup"><a href="#TransitionGroup" class="headerlink" title="TransitionGroup"></a>TransitionGroup</h3><p>当有一组动画的时候，就可将这些CSSTransition放入到一个TransitionGroup中来完成动画</p><p>同样CSSTransition里面没有in属性，用到了key属性</p><p>TransitionGroup在感知children发生变化的时候，先保存移除的节点，当动画结束后才真正移除</p><p>其处理方式如下：</p><ul><li>插入的节点，先渲染dom，然后再做动画</li><li>删除的节点，先做动画，然后再删除dom</li></ul><p>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CSSTransition</span>, <span class="hljs-title class_">TransitionGroup</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupAnimation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span>&lt;&#123;&#125;, &#123; <span class="hljs-attr">friends</span>: string[] &#125;&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props: &#123;&#125;</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>            <span class="hljs-attr">friends</span>: []<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">addFriend</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>            <span class="hljs-attr">friends</span>: [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">friends</span>, <span class="hljs-string">&quot;coderwhy&quot;</span>]<br>        &#125;)<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">margin:</span> &quot;<span class="hljs-attr">20px</span>&quot; &#125;&#125;&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TransitionGroup</span>&gt;</span></span><br><span class="language-xml">                    &#123;</span><br><span class="language-xml">                        this.state.friends.map((item, index) =&gt; &#123;</span><br><span class="language-xml">                            return (</span><br><span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span> <span class="hljs-attr">classNames</span>=<span class="hljs-string">&quot;GroupAnimation&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;300&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span></span><br><span class="language-xml">                                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                                <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span></span><br><span class="language-xml">                            )</span><br><span class="language-xml">                        &#125;)</span><br><span class="language-xml">                    &#125;</span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">TransitionGroup</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;primary&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addFriend()&#125;&gt;+friend<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应css如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css">css复制代码<br><span class="hljs-selector-class">.GroupAnimation-enter</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.GroupAnimation-enter-active</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br><br><span class="hljs-selector-class">.GroupAnimation-exit</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-class">.GroupAnimation-exit-active</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReactRouter-组件的理解，常用的react-router组件"><a href="#ReactRouter-组件的理解，常用的react-router组件" class="headerlink" title="ReactRouter 组件的理解，常用的react router组件"></a>ReactRouter 组件的理解，常用的react router组件</h2><p>react-router等前端路由的原理大致相同，可以实现无刷新的条件下切换显示不同的页面。</p><p>路由的本质就是页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。</p><p>因此，可以通过前端路由可以实现单页(SPA)应用</p><p>react-router主要分成了几个不同的包：</p><ul><li>react-router: 实现了路由的核心功能</li><li>react-router-dom： 基于 react-router，加入了在浏览器运行环境下的一些功能</li><li>react-router-native：基于 react-router，加入了 react-native 运行环境下的一些功能</li><li>react-router-config: 用于配置静态路由的工具库</li></ul><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p>react-router-dom的常用的一些组件：</p><ul><li>BrowserRouter、HashRouter：使用两者作为最顶层组件包裹其他组件，分别匹配history模式和hash模式</li><li>Route：Route用于路径的匹配，然后进行组件的渲染，对应的属性如下：<ul><li>path 属性：用于设置匹配到的路径</li><li>component 属性：设置匹配到路径后，渲染的组件</li><li>render 属性：设置匹配到路径后，渲染的内容</li><li>exact 属性：开启精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件</li></ul></li><li>Link、NavLink：通常路径的跳转是使用Link组件，最终会被渲染成a元素，其中属性to代替a标题的href属性 NavLink是在Link基础之上增加了一些样式属性，例如组件被选中时，发生样式变化，则可以设置NavLink的一下属性：<ul><li>activeStyle：活跃时（匹配时）的样式</li><li>activeClassName：活跃时添加的class</li></ul></li><li>switch：swich组件的作用适用于当匹配到第一个组件的时候，后面的组件就不应该继续匹配</li><li>redirect：路由的重定向</li></ul><h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><p>除了一些路由相关的组件之外，react-router还提供一些hooks，如下：</p><ul><li>useHistory：组件内部直接访问history，无须通过props获取</li><li>useParams：获取路由参数</li><li>useLocation：返回当前 URL的 location对象</li></ul><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>路由传递参数主要分成了三种形式：</p><h4 id="动态路由的方式（params）："><a href="#动态路由的方式（params）：" class="headerlink" title="动态路由的方式（params）："></a>动态路由的方式（params）：</h4><p>路由配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id/:name&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Detail</span> &#125;<br></code></pre></td></tr></table></figure><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; useHistory,useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br><span class="hljs-comment">// 跳转路由   地址栏：/detail/2/zora</span><br>history.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/detail/2/zora&#x27;</span>)<br><br>&lt;!--或者--&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>( <span class="hljs-string">&#x27;/detail/2/zora&#x27;</span> )<br></code></pre></td></tr></table></figure><p>获取参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 获取路由参数</span><br><span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParams</span>()  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params) <span class="hljs-comment">// &#123;id: &quot;2&quot;,name:&quot;zora&quot;&#125;</span><br><br>&lt;!-- 或者 --&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">match</span>.<span class="hljs-property">params</span> <br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>刷新页面，参数不丢失</li></ul><p>缺点：</p><ul><li>只能传字符串，传值过多url会变得很长</li><li>参数必须在路由上配置</li></ul><h4 id="search传递参数"><a href="#search传递参数" class="headerlink" title="search传递参数"></a>search传递参数</h4><p>路由不需要特别配置</p><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br><span class="hljs-comment">// 路由跳转  地址栏：/detail?id=2</span><br>history.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/detail?id=2&#x27;</span>)  <br><span class="hljs-comment">// 或者</span><br>history.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">&#x27;/detail&#x27;</span>,<span class="hljs-attr">search</span>:<span class="hljs-string">&#x27;?id=2&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>获取参数：所获取的是查询字符串，所以，还需要进一步的解析，自己自行解析，也可以使用第三方模块：qs，或者nodejs里的query-string</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useLocation</span>() <br>&lt;!--或者--&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>刷新页面，参数不丢失</li></ul><p>缺点：</p><ul><li>只能传字符串，传值过多url会变得很长，获取参数需要自定义hooks</li></ul><h4 id="state传参"><a href="#state传参" class="headerlink" title="state传参"></a>state传参</h4><p>路由不需要单独配置</p><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<br><span class="hljs-keyword">import</span> &#123; useHistory,useLocation &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;<br><span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br><span class="hljs-keyword">const</span> item = &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zora&quot;</span>&#125;<br><span class="hljs-comment">// 路由跳转</span><br>history.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/user/role/detail`</span>, &#123; <span class="hljs-attr">id</span>: item &#125;);<br><br>&lt;!--或者--&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">&quot;/sort &quot;</span>,state : &#123; name : <span class="hljs-string">&#x27;sunny&#x27;</span> &#125;&#125;);<br></code></pre></td></tr></table></figure><p>获取参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 参数获取</span><br><span class="hljs-keyword">const</span> &#123;state&#125; = <span class="hljs-title function_">useLocation</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state)  <span class="hljs-comment">// &#123;id:1,name:&quot;zora&quot;&#125;</span><br><br>&lt;!--或者--&gt;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">state</span> <br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>可以传对象</li></ul><p>缺点：</p><ul><li><code>&lt;HashRouter&gt;</code>刷新页面，参数丢失</li></ul><p><strong><code>&lt;HashRouter&gt;</code>通过state传递参数，刷新页面后参数丢失，官方建议使用<code>&lt;BrowserRouter&gt;</code>，<code>&lt;BrowserRouter&gt;</code>页面刷新参数也不会丢失。</strong></p><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>路由不需要特别配置</p><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">&quot;/query&quot;</span>,<span class="hljs-attr">query</span>: &#123; name : <span class="hljs-string">&#x27;sunny&#x27;</span> &#125;&#125;);<br></code></pre></td></tr></table></figure><p>获取参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码 <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">query</span>.<span class="hljs-property">name</span><br></code></pre></td></tr></table></figure><p>优势：</p><ul><li>传参优雅，传递参数可传对象；</li></ul><p>缺点：</p><ul><li>刷新地址栏，参数丢失</li></ul><h2 id="React-Router有几种模式，实现原理是什么"><a href="#React-Router有几种模式，实现原理是什么" class="headerlink" title="React Router有几种模式，实现原理是什么"></a>React Router有几种模式，实现原理是什么</h2><p>react Router 有四个库：</p><ul><li>react router：核心库，封装了<code>Router，Route，Switch</code>等核心组件,实现了从路由的改变到组件的更新的核心功能,</li><li>react router dom：dom环境下的router。在<code>react-router</code>的核心基础上，添加了用于跳转的<code>Link</code>组件，和histoy模式下的<code>BrowserRouter</code>和hash模式下的<code>HashRouter</code>组件等。所谓BrowserRouter和HashRouter，也只不过用了history库中createBrowserHistory和createHashHistory方法</li><li>react router native：RN环境下的router</li><li>react router config</li></ul><p>在单页应用中，一个web项目只有一个html页面，一旦页面加载完成之后，就不用因为用户的操作而进行页面的重新加载或者跳转，其特性如下：</p><ul><li>改变 url 且不让浏览器像服务器发送请求</li><li>在不刷新页面的前提下动态改变浏览器地址栏中的URL地址</li></ul><p>react router dom其中主要分成了两种模式：</p><ul><li>hash 模式：在url后面加上#，如<a href="https://link.juejin.cn/?target=http://127.0.0.1:5500/home/%23/page1">http://127.0.0.1:5500/home/#/page1</a></li><li>history 模式：允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录</li></ul><p>React Router对应的hash模式和history模式对应的组件为：</p><ul><li>HashRouter</li><li>BrowserRouter</li></ul><p>这两个组件的使用都十分的简单，作为最顶层组件包裹其他组件</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://juejin.cn/post/6886290490640039943">参考</a></p><p>单页面应用路由实现原理是，切换url，监听url变化，从而渲染不同的页面组件。</p><p>主要的方式有<code>history</code>模式和<code>hash</code>模式。</p><h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><h5 id="①改变路由"><a href="#①改变路由" class="headerlink" title="①改变路由"></a>①改变路由</h5><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">history.pushState<br>js<br>复制代码history.pushState(<span class="hljs-keyword">state</span>,title,path)<br></code></pre></td></tr></table></figure><p>1 <code>state</code>：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。</p><p>2 <code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，可填 null。</p><p>3 <code>path</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">history.replaceState<br>js<br>复制代码history.replaceState(<span class="hljs-keyword">state</span>,title,path)<br></code></pre></td></tr></table></figure><p>参数和<code>pushState</code>一样，这个方法会修改当前的<code>history</code>对象记录， <code>history.length</code> 的长度不会改变。</p><h5 id="②监听路由"><a href="#②监听路由" class="headerlink" title="②监听路由"></a>②监听路由</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">popstate事件<br>javascript复制代码<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-comment">/* 监听改变 */</span><br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>同一个文档的 <code>history</code> 对象出现变化时，就会触发<code> popstate</code> 事件  <code>history.pushState</code> 可以使浏览器地址改变，但是无需刷新页面。<strong>注意⚠️的是：用 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 不会触发 <code>popstate</code> 事件</strong>。 <code>popstate</code> 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 <code>history.back()、history.forward()、history.go()</code>方法。</p><h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><h5 id="①改变路由-1"><a href="#①改变路由-1" class="headerlink" title="①改变路由"></a>①改变路由</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">window</span>.<span class="hljs-keyword">location</span>.hash<br></code></pre></td></tr></table></figure><p>通过<code>window.location.hash </code>属性获取和设置 <code>hash </code>值。</p><p>在<code>hash</code>模式下 ，<code>history.push</code> 底层是调用了<code>window.location.href</code>来改变路由。<code>history.replace</code>底层是调用 <code>window.location.replace</code>改变路由。</p><h5 id="②监听路由-1"><a href="#②监听路由-1" class="headerlink" title="②监听路由"></a>②监听路由</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onhashchange<br>javascript复制代码<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-comment">/* 监听改变 */</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><img src="/2022/11/23/%E6%8E%98%E9%87%91-React/11/23/%E6%8E%98%E9%87%91-React/73f5e8da9dfc4510a766b8473b520385tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" class title="image.png"><p><strong>当地址栏改变url，组件的更新渲染都经历了什么？😊😊😊</strong> 拿history模式做参考。当url改变，首先触发histoy，调用事件监听<code>popstate</code>事件， 触发回调函数<code>handlePopState</code>，触发history下面的<code>setstate</code>方法，产生新的location对象，然后通知Router组件更新<code>location</code>并通过<code>context</code>上下文传递，<code>switch</code>通过传递的更新流，匹配出符合的Route组件渲染，最后有<code>Route</code>组件取出<code>context</code>内容，传递给渲染页面，渲染更新。</p><p><strong>当我们调用<code>history.push</code>方法，切换路由，组件的更新渲染又都经历了什么呢？</strong></p><p>我们还是拿history模式作为参考，当我们调用<code>history.push</code>方法，首先调用history的<code>push</code>方法，通过<code>history.pushState</code>来改变当前<code>url</code>，接下来触发history下面的<code>setState</code>方法，接下来的步骤就和上面一模一样了，这里就不一一说了。</p><h3 id="BrowserRouter-与-HashRouter-对⽐"><a href="#BrowserRouter-与-HashRouter-对⽐" class="headerlink" title="BrowserRouter 与 HashRouter 对⽐"></a>BrowserRouter 与 HashRouter 对⽐</h3><ul><li>HashRouter 最简单，每次路由变化不需要服务端接入，根据浏览器的hash来区分 path 就可以；BrowserRouter需要服务端解析 URL 返回页面，因此使用BrowserRouter需要在后端配置地址映射。</li><li>BrowserRouter 触发路由变化的本质是使⽤ HTML5 history API（ pushState、replaceState 和 popstate 事件）</li><li>HashRouter 不⽀持 location.key 和 location.state，动态路由需要通过?传递参数。</li><li>Hash history 只需要服务端配置一个地址就可以上线，但线上的 web 应⽤很少使用这种方式。</li></ul><h2 id="对immutable的理解-如何应用在react项目中"><a href="#对immutable的理解-如何应用在react项目中" class="headerlink" title="对immutable的理解,如何应用在react项目中"></a>对immutable的理解,如何应用在react项目中</h2><p><a href="https://link.juejin.cn/?target=https://vue3js.cn/interview/React/immutable.html%23%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">参考</a></p><p>使用Immutable对象最主要的库是immutable.js</p><p>immutable.js 是一个完全独立的库，无论基于什么框架都可以用它</p><p>其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing来解决的性能问题</p><h3 id="在React中应用"><a href="#在React中应用" class="headerlink" title="在React中应用"></a>在React中应用</h3><p>使用 Immutable可以给 React 应用带来性能的优化，主要体现在减少渲染的次数</p><p>在做react性能优化的时候，为了避免重复渲染，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法</p><p>Immutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较</p><p>在使用redux过程中也可以结合Immutable，不使用Immutable前修改一个数据需要做一个深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;_&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;<br>  <span class="hljs-title function_">getInitialState</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">times</span>: <span class="hljs-number">0</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">handleAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> data = _.<span class="hljs-title function_">cloneDeep</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>);<br>    data.<span class="hljs-property">times</span> = data.<span class="hljs-property">times</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">data</span>: data &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Immutable 后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-title function_">getInitialState</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-title class_">Map</span>(&#123; <span class="hljs-attr">times</span>: <span class="hljs-number">0</span> &#125;)<br>  &#125;<br>&#125;,<br>  <span class="hljs-title function_">handleAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">data</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">update</span>(<span class="hljs-string">&#x27;times&#x27;</span>, <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v + <span class="hljs-number">1</span>) &#125;);<br>    <span class="hljs-comment">// 这时的 times 并不会改变</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;times&#x27;</span>));<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="react-render原理，在什么时候触发"><a href="#react-render原理，在什么时候触发" class="headerlink" title="react render原理，在什么时候触发"></a>react render原理，在什么时候触发</h2><p>render存在两种形式：</p><ul><li>类组件中的render方法</li><li>函数组件的函数本身</li></ul><p>触发时机：</p><ul><li>类组件setState</li><li>函数组件通过useState hook修改状态</li></ul><p>一旦执行了setState就会执行render方法(无论值是否发生变化)，useState 会判断当前值有无发生改变确定是否执行render方法，一旦父组件发生渲染，子组件也会渲染</p><h2 id="如何提高组件的渲染效率"><a href="#如何提高组件的渲染效率" class="headerlink" title="如何提高组件的渲染效率"></a>如何提高组件的渲染效率</h2><p>在之前文章中，我们了解到render的触发时机，简单来讲就是类组件通过调用setState方法， 就会导致render，父组件一旦发生render渲染，子组件一定也会执行render渲染</p><p>父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p><ul><li>shouldComponentUpdate：<ul><li>通过shouldComponentUpdate生命周期函数来比对 state和 props，确定是否要重新渲染</li><li>默认情况下返回true表示重新渲染，如果不希望组件重新渲染，返回 false 即可</li></ul></li><li>PureComponent：<ul><li>跟shouldComponentUpdate原理基本一致，通过对 props 和 state的浅比较结果来实现 shouldComponentUpdate</li></ul></li><li>React.memo<ul><li>React.memo用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似。但不同的是， React.memo 只能用于函数组件</li><li>如果需要深层次比较，这时候可以给memo第二个参数传递比较函数</li></ul></li></ul><h2 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h2><p>跟Vue一致，React通过引入Virtual DOM的概念，极大地避免无效的Dom操作，使我们的页面的构建效率提到了极大的提升</p><p>而diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处</p><p>传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，react将算法进行一个优化，复杂度降为O(n)</p><p>react中diff算法主要遵循三个层级的策略：</p><ul><li>tree层级<ul><li>DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较</li><li>只有删除、创建操作，没有移动操作</li></ul></li><li>conponent 层级<ul><li>如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</li></ul></li><li>element 层级<ul><li>对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识</li><li>提供了 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</li><li>通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</li><li>由于dom节点的移动操作开销是比较昂贵的，在只修改文本的情况下，没有key的情况下要比有key的性能更好</li></ul></li></ul><h2 id="对Fiber架构的理解，解决了什么问题"><a href="#对Fiber架构的理解，解决了什么问题" class="headerlink" title="对Fiber架构的理解，解决了什么问题"></a>对Fiber架构的理解，解决了什么问题</h2><h3 id="Fiber-的结构"><a href="#Fiber-的结构" class="headerlink" title="Fiber 的结构"></a>Fiber 的结构</h3><p>在 React15 以前 React 的组件更新创建虚拟 DOM 和 Diff 的过程是<strong>不可中断</strong>，如果需要更新组件树层级非常深的话，在 Diff 的过程会非常占用浏览器的线程，而我们都知道<strong>浏览器执行JavaScript 的线程和渲染真实 DOM 的线程是互斥的</strong>，也就是同一时间内，浏览器要么在执行 JavaScript 的代码运算，要么在渲染页面，<strong>如果 JavaScript 的代码运行时间过长则会造成页面卡顿</strong>。</p><p>基于以上原因 React 团队在 React16 之后就改写了整个架构，<strong>将原来数组结构的虚拟DOM，改成叫 Fiber 的一种数据结构</strong>，基于这种 Fiber 的数据结构可以实现由原来不可中断的更新过程变成<strong>异步的可中断的更新</strong>。</p><p>Fiber 的数据结构主要长成以下的样子，主要通过 Fiber 的一些属性去保存组件相关的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  tag: WorkTag,</span><br><span class="hljs-params">  pendingProps: mixed,</span><br><span class="hljs-params">  key: <span class="hljs-literal">null</span> | string,</span><br><span class="hljs-params">  mode: TypeOfMode,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 作为静态数据结构的属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于连接其他Fiber节点形成Fiber树</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 作为动态的工作单元的属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">NoEffect</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 调度优先级相关</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-comment">// 指向该fiber在另一次更新时对应的fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Fiber 主要靠以下属性连成一棵树结构的数据的，也就是 Fiber 链表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-comment">// 指向父级Fiber节点</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 指向子Fiber节点</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 指向右边第一个兄弟Fiber节点</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>那么以上的 Fiber 链表的数据结构有什么特点，就是任何一个位置的 Fiber 节点，都可以非常容易知道它的父 Fiber, 第一个子元素的 Fiber,和它的兄弟节点 Fiber。却不容易知道它前一个 Fiber 节点是谁，这就是 React 中单向链表 Fiber 节点的特点。也正是因为这些即便在协调的过程被中断了，再恢复协调的时候，依然知道当前的父节点和孩子节点等信息。</p><p>在React 16 版本中，主要做了以下的操作：</p><ul><li>为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li><li>增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li><li>dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li></ul><p>从架构角度来看，Fiber 是对 React核心算法（即调和过程）的重写</p><p>从编码角度来看，Fiber是 React内部所定义的一种数据结构，它是 Fiber树结构的节点单位，也就是 React 16 新架构下的虚拟DOM</p><p>一个 fiber就是一个 JavaScript对象，包含了元素的信息、该元素的更新操作队列、类型.</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给浏览器（浏览器可以进行渲染），等浏览器不忙的时候再继续执行</p><p>即<strong>可以中断与恢复</strong>，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</p><blockquote><p>实现的上述方式的是requestIdleCallback方法： window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</p></blockquote><p>Fiber 架构可以分为三层：</p><ul><li>Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler。requestIdleCallback在调度器中用到。</li><li>Reconciler 协调器 —— 负责找出变化的组件</li><li>Renderer 渲染器 —— 负责将变化的组件渲染到页面上</li></ul><p>相比 React15，React16 多了<strong>Scheduler（调度器）</strong> ，调度器的作用是调度更新的优先级。</p><p>在新的架构模式下，工作流如下：</p><ul><li>每个更新任务都会被赋予一个优先级。</li><li>当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；</li><li>此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。</li><li>当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。</li></ul><p><strong>Fiber 架构的核心即是”可中断”、”可恢复”、”优先级”</strong></p><h4 id="React-16-是如何解决中断更新时-DOM-渲染不完全的问题呢？"><a href="#React-16-是如何解决中断更新时-DOM-渲染不完全的问题呢？" class="headerlink" title="React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？"></a>React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</h4><p>在 React 16 中，<code>Reconciler</code>与<code>Renderer</code>不再是交替工作。当<code>Scheduler</code>将任务交给<code>Reconciler</code>后，<code>Reconciler</code>会为变化的虚拟 DOM 打上的标记。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">arduino复制代码<span class="hljs-keyword">export</span> <span class="hljs-type">const</span> Placement = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b0000000000010</span> <br><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> Update = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b0000000000100</span> <br><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> PlacementAndUpdate = <span class="hljs-comment">/*    */</span> <span class="hljs-number">0b0000000000110</span> <br><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> Deletion = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b0000000001000</span> <br></code></pre></td></tr></table></figure><ul><li><code>Placement</code>表示插入操作</li><li><code>PlacementAndUpdate</code>表示替换操作</li><li><code>Update</code>表示更新操作</li><li><code>Deletion</code>表示删除操作</li></ul><p>整个<code>Scheduler</code>与<code>Reconciler</code>的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成<code>Reconciler</code>的工作，才会统一交给<code>Renderer</code>。</p><h4 id="fiber对生命周期的影响"><a href="#fiber对生命周期的影响" class="headerlink" title="fiber对生命周期的影响"></a>fiber对生命周期的影响</h4><p>新老两种架构对 React 生命周期的影响主要在 render 这个阶段，这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。</p><p>在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。</p><p>从 Firber 机制 render 阶段的角度看 react 即将废除的三个生命周期的共同特点是都处于 render 阶段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">复制代码componentWillMount<br>componentWillUpdate<br>componentWillReceiveProps<br></code></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://link.juejin.cn/?target=https://jacky-summer.github.io/2021/02/07/%E6%B5%85%E8%B0%88%E5%AF%B9-React-Fiber-%E7%9A%84%E7%90%86%E8%A7%A3/">jacky-summer.github.io&#x2F;2021&#x2F;02&#x2F;07&#x2F;…</a></p><h2 id="JSX转换成真实DOM的过程"><a href="#JSX转换成真实DOM的过程" class="headerlink" title="JSX转换成真实DOM的过程"></a>JSX转换成真实DOM的过程</h2><p>其渲染流程如下所示：</p><ol><li>将函数组件或者类组件中的jsx结构，通过babel转换成React.createElement的形式，React.createElement对接收到的参数进行“格式化”，传递给ReactElement函数；</li><li>ReactElement函数将接收到的参数进行整合，最终构造成一个虚拟DOM对象并返回；</li><li>ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM</li></ol><h2 id="react-性能优化的手段"><a href="#react-性能优化的手段" class="headerlink" title="react 性能优化的手段"></a>react 性能优化的手段</h2><ul><li><p>避免不必要的render：通过shouldComponentUpdate、PureComponent、React.memo</p></li><li><p>使用 Immutable：在做react性能优化的时候，为了避免重复渲染，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法。Immutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较</p></li><li><p>避免使用内联函数：每次调用render函数时都会创建一个新的函数实例</p></li><li><p>事件绑定方式：避免在render函数中声明函数，通过在constructor绑定this，或者在声明函数的时候使用箭头函数</p></li><li><p>使用 React Fragments 避免额外标记：用户创建新组件时，每个组件应具有单个父标签。这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用fragement</p></li><li><p>懒加载组件：从工程方面考虑，webpack存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小。而在react中使用到了Suspense和 lazy组件实现代码拆分功能，基本使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码    <span class="hljs-keyword">const</span> johanComponent = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;johanComponent&quot; */</span> <span class="hljs-string">&#x27;./myAwesome.component&#x27;</span>));<br> <br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">johanAsyncComponent</span> = props =&gt; (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>&#125;&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">johanComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span><br>    );<br></code></pre></td></tr></table></figure></li><li><p>服务端渲染：采用服务端渲染端方式，可以使用户更快的看到渲染完成的页面</p></li></ul><h2 id="在React项目中如何捕获错误"><a href="#在React项目中如何捕获错误" class="headerlink" title="在React项目中如何捕获错误"></a>在React项目中如何捕获错误</h2><p>错误在我们日常编写代码是非常常见的</p><p>举个例子，在react项目中去编写组件内JavaScript代码错误会导致 React 的内部状态被破坏，导致整个应用崩溃，这是不应该出现的现象</p><p>作为一个框架，react也有自身对于错误的处理的解决方案。</p><p>为了解决出现的错误导致整个应用崩溃的问题，react16引用了错误边界新的概念</p><p>错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件树</p><p>错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误</p><p>形成错误边界组件的两个条件：</p><ul><li>使用了 static getDerivedStateFromError()</li><li>使用了 componentDidCatch()</li></ul><p>抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span><br>    <span class="hljs-title function_">logErrorToMyService</span>(error, errorInfo);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span><br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以把自身组件的作为错误边界的子组件，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">MyWidget</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这些情况无法捕获到异常：</p><ul><li>事件处理</li><li>异步代码</li><li>服务端渲染</li><li>自身抛出来的错误</li></ul><p>对于错误边界无法捕获的异常，如事件处理过程中发生问题并不会捕获到，是因为其不会在渲染期间触发，并不会导致渲染时候问题</p><p>这种情况可以使用js的try…catch…语法，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 执行操作，如有错误则会抛出</span><br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; error &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">error</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Caught an error.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外还可以通过监听onerror事件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br>复制代码<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123; ... &#125;)<br></code></pre></td></tr></table></figure><h2 id="react和vue渲染原理上的区别"><a href="#react和vue渲染原理上的区别" class="headerlink" title="react和vue渲染原理上的区别"></a>react和vue渲染原理上的区别</h2><p>可以看<a href="https://juejin.cn/post/7144648542472044558">这篇文章</a></p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><code>redux</code>就是一个将状态进行集中管理的容器，遵循三大基本原则：</p><ul><li>单一数据源</li><li>state 是只读的</li><li>使用纯函数来执行修改</li></ul><p>注意redux并不是只有在react中使用，还可以和其他的界面库使用，比如vue</p><p>以下的情景可以使用redux:</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><img src="/2022/11/23/%E6%8E%98%E9%87%91-React/11/23/%E6%8E%98%E9%87%91-React/59152a7e33db4cc395b9edf48d9a41a7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" class title="image.png"><p>首先，用户发出 Action。</p><blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini<br>复制代码store.dispatch(action)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。</p><blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini<br>复制代码let <span class="hljs-attr">nextState</span> = todoApp(previousState, action)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><p>State 一旦有变化，Store 就会调用监听函数。</p><blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">scss复制代码<span class="hljs-comment">// 设置监听函数</span><br>store<span class="hljs-selector-class">.subscribe</span>(listener);<br></code></pre></td></tr></table></figure></blockquote><p><code>listener</code>可以通过<code>store.getState()</code>得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p><blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">ini复制代码function listerner() &#123;<br>  let <span class="hljs-attr">newState</span> = store.getState()<span class="hljs-comment">;</span><br>  component.setState(newState)<span class="hljs-comment">;   </span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>参考：<a href="https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">www.ruanyifeng.com/blog/2016/0…</a></p><p>中间件就是一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">let</span> next = store.<span class="hljs-property">dispatch</span>;<br>store.<span class="hljs-property">dispatch</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchAndLog</span>(<span class="hljs-params">action</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;dispatching&#x27;</span>, action);<br>  <span class="hljs-title function_">next</span>(action);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;next state&#x27;</span>, store.<span class="hljs-title function_">getState</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>redux-thunk中间件。</p><p>默认情况下的<code>dispatch(action)</code>，<code>action</code>需要是一个<code>JavaScript</code>的对象</p><p><code>redux-thunk</code>中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）</p><ul><li>dispatch函数用于我们之后再次派发action</li><li>getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态</li></ul><p>所以<code>dispatch</code>可以写成下述函数的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getHomeMultidataAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://xxx.xx.xx.xx/test&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;<br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeBannersAction</span>(data.<span class="hljs-property">banner</span>.<span class="hljs-property">list</span>));<br>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeRecommendsAction</span>(data.<span class="hljs-property">recommend</span>.<span class="hljs-property">list</span>));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在react中使用"><a href="#在react中使用" class="headerlink" title="在react中使用"></a>在react中使用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>state：普通对象，用来存储状态</p><p>action：普通对象，用来描述变化</p><p>reducer：接收 state 和 action，并返回新的 state 的函数，将state和action连接起来</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装：</p><blockquote><p>npm install redux</p><p>npm install react-redux</p></blockquote><ol><li><p>创建store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><br><br><span class="hljs-keyword">const</span> defaultState=&#123;<br>    <span class="hljs-attr">counter</span>:<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//纯函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">reducers</span> =(<span class="hljs-params">state = defaultState ,action</span>)=&gt;&#123;<br>    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;increment&quot;</span>)<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">counter</span>:state.<span class="hljs-property">counter</span>+<span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">counter</span>:state.<span class="hljs-property">counter</span>-<span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-keyword">default</span> :<br>        <span class="hljs-keyword">return</span> state <br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducers)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure></li><li><p>全局注入store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reportWebVitals&#x27;</span>;<br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));<br>root.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">// If you want to start measuring performance in your app, pass a function</span><br><span class="hljs-comment">// to log results (for example: reportWebVitals(console.log))</span><br><span class="hljs-comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span><br><span class="hljs-title function_">reportWebVitals</span>();<br></code></pre></td></tr></table></figure></li><li><p>react-redux将redux和react联系起来</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs jsx">jsx复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassCom</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>    &#125;<br><br>    incre = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">increment</span>()<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>类组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>store测试<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>store的值&#123;this.props.num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.incre&#125;</span>&gt;</span>increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">// export default ClassCom</span><br><span class="hljs-comment">//该函数作为connect的第一个参数，能拿到state</span><br><span class="hljs-comment">//映射state到组建的props上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-params">state</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">num</span>: state.<span class="hljs-property">counter</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//该函数作为connect的第二个参数，能拿到dispatch</span><br><span class="hljs-comment">//映射dispatch方法到组建的props上</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">dispatch</span>(&#123;<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span><br>            &#125;)<br>        &#125;,<br>        <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">dispatch</span>(&#123;<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;decrement&quot;</span><br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//connet函数执行返回一个高阶组件</span><br><span class="hljs-comment">//调用这个高阶组件，传入当前组件作为参数,返回一个增强的组件</span><br><span class="hljs-comment">//这个增强的组件props里有store的state和dispach方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">ClassCom</span>)<br></code></pre></td></tr></table></figure></li></ol><p>这个时候组件的props中会有</p><ul><li>传入的props</li><li>mapStateToProps注入的state</li><li>mapDispatchToProps 注入的dispatch</li></ul><p>接下来就可以通过props去使用状态和更新状态</p><h2 id="Redux和Vuex的异同点，以及用到的相同的思想"><a href="#Redux和Vuex的异同点，以及用到的相同的思想" class="headerlink" title="Redux和Vuex的异同点，以及用到的相同的思想"></a>Redux和Vuex的异同点，以及用到的相同的思想</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>state共享数据</li><li>流程一致：定义全局state，触发修改方法，修改state</li><li>全局注入store</li></ul><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul><li>redux使用的是不可变数据，而Vuex是可变的。</li><li>redux每次都是用新的state替换旧的state，vuex是直接修改。</li><li>redux在检测数据变化时是通过diff算法比较差异的；vuex是通过getter&#x2F;setter来比较的</li><li>vuex定义了state，getter，mutation，action；redux定义了state，reducer，action</li><li>vuex中state统一存放，方便理解；react中state依赖reducer初始值</li><li>vuex的mapGetters可以快捷得到state，redux中是mapStateToProps</li><li>vuex同步使用mutation，异步使用action；redux同步异步都使用reducer</li></ul><h3 id="相同思想"><a href="#相同思想" class="headerlink" title="相同思想"></a>相同思想</h3><ul><li>单一数据源</li><li>变化可预测</li><li>MVVM思想</li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>掘金 React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络面试题</title>
    <link href="/2022/11/23/%E6%8E%98%E9%87%91-%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/11/23/%E6%8E%98%E9%87%91-%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="网络面试题汇总"><a href="#网络面试题汇总" class="headerlink" title="网络面试题汇总"></a>网络面试题汇总</h1><h3 id="1-简述-TCP-连接的过程（淘系）"><a href="#1-简述-TCP-连接的过程（淘系）" class="headerlink" title="1.  简述 TCP 连接的过程（淘系）"></a>1.  简述 TCP 连接的过程（淘系）</h3><blockquote><p>参考答案：</p><p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p><p>首先服务器进入监听状态，然后即可处理连接</p><p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p><p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p><p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p><p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p></blockquote><h3 id="2-介绍下-HTTPS-中间人攻击"><a href="#2-介绍下-HTTPS-中间人攻击" class="headerlink" title="2.  介绍下 HTTPS 中间人攻击"></a>2.  介绍下 HTTPS 中间人攻击</h3><blockquote><p>参考答案：</p><p>针对 HTTPS 攻击主要有 SSL 劫持攻击和 SSL 剥离攻击两种。</p><p>SSL 劫持攻击是指攻击者劫持了客户端和服务器之间的连接，将服务器的合法证书替换为伪造的证书，从而获取客户端和服务器之间传递的信息。这种方式一般容易被用户发现，浏览器会明确的提示证书错误，但某些用户安全意识不强，可能会点击继续浏览，从而达到攻击目的。</p><p>SSL 剥离攻击是指攻击者劫持了客户端和服务器之间的连接，攻击者保持自己和服务器之间的 HTTPS 连接，但发送给客户端普通的 HTTP 连接，由于 HTTP 连接是明文传输的，即可获取客户端传输的所有明文数据。</p></blockquote><h3 id="3-介绍下-http1-0、http1-1、http2-0-协议的区别？"><a href="#3-介绍下-http1-0、http1-1、http2-0-协议的区别？" class="headerlink" title="3.  介绍下 http1.0、http1.1、http2.0 协议的区别？"></a>3.  介绍下 <code>http1.0</code>、<code>http1.1</code>、<code>http2.0</code> 协议的区别？</h3><blockquote><p>参考答案：</p><p>首先说 http1.0</p><p>它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p><ol><li>无法复用连接</li></ol><p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p><ol><li>队头阻塞</li></ol><p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p><p>然后是 http1.1</p><p>http1.1 是 http1.0 的改进版，它做出了以下改进：</p><ul><li>长连接</li></ul><p>http1.1 允许在请求时增加请求头connection:keep-alive，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接</p><ul><li>管道化</li></ul><p>基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p><ul><li>缓存处理</li></ul><p>新增响应头 cache-control，用于实现客户端缓存。</p><ul><li>断点传输</li></ul><p>在上传&#x2F;下载资源时，如果资源过大，将其分割为多个部分，分别上传&#x2F;下载，如果遇到网络故障，可以从已经上传&#x2F;下载好的地方继续请求，不用从头开始，提高效率</p><p>最后是 http2.0</p><p>http2.0 进一步优化了传输效率，它主要有以下改进：</p><ul><li>二进制分帧</li></ul><p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p><ul><li>多路复用</li></ul><p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p><ul><li>头部压缩</li></ul><p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p><ul><li>服务器推</li></ul><p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p></blockquote><h3 id="4-为什么-HTTP1-1-不能实现多路复用（腾讯）"><a href="#4-为什么-HTTP1-1-不能实现多路复用（腾讯）" class="headerlink" title="4.  为什么 HTTP1.1 不能实现多路复用（腾讯）"></a>4.  为什么 HTTP1.1 不能实现多路复用（腾讯）</h3><blockquote><p>参考答案：</p><p>HTTP&#x2F;1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。</p></blockquote><h3 id="5-简单讲解一下-http2-的多路复用（网易）"><a href="#5-简单讲解一下-http2-的多路复用（网易）" class="headerlink" title="5.  简单讲解一下 http2 的多路复用（网易）"></a>5.  简单讲解一下 http2 的多路复用（网易）</h3><blockquote><p>参考答案：</p><p>在 HTTP&#x2F;2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p></blockquote><h3 id="6-谈谈你对-TCP-三次握手和四次挥手的理解"><a href="#6-谈谈你对-TCP-三次握手和四次挥手的理解" class="headerlink" title="6.  谈谈你对 TCP 三次握手和四次挥手的理解"></a>6.  谈谈你对 TCP 三次握手和四次挥手的理解</h3><blockquote><p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p><p>首先服务器进入监听状态，然后即可处理连接</p><p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p><p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p><p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p><p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p><p>当需要关闭连接时，需要进行四次挥手才能关闭</p><ol><li>Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。</li><li>Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。</li><li>Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。</li><li>Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。</li><li>Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。</li><li>Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。</li></ol></blockquote><h3 id="7-介绍-HTTPS-握手过程"><a href="#7-介绍-HTTPS-握手过程" class="headerlink" title="7.  介绍 HTTPS 握手过程"></a>7.  介绍 HTTPS 握手过程</h3><blockquote><p>参考答案：</p><ol><li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li><li>服务器响应公钥和服务器证书</li><li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li><li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li><li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li><li>后续客户端和服务器使用会话密钥加密信息传递消息</li></ol></blockquote><h3 id="8-HTTPS-握手过程中，客户端如何验证证书的合法性"><a href="#8-HTTPS-握手过程中，客户端如何验证证书的合法性" class="headerlink" title="8.  HTTPS 握手过程中，客户端如何验证证书的合法性"></a>8.  HTTPS 握手过程中，客户端如何验证证书的合法性</h3><blockquote><p>参考答案：</p><ol><li>校验证书的颁发机构是否受客户端信任。</li><li>通过 CRL 或 OCSP 的方式校验证书是否被吊销。</li><li>对比系统时间，校验证书是否在有效期内。</li><li>通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。</li></ol></blockquote><h3 id="9-Http-状态码-301-和-302-的应用场景分别是什么"><a href="#9-Http-状态码-301-和-302-的应用场景分别是什么" class="headerlink" title="9.  Http 状态码 301 和 302 的应用场景分别是什么"></a>9.  Http 状态码 301 和 302 的应用场景分别是什么</h3><blockquote><p>参考答案：</p><p>301 表示永久重定向，302 表示临时重定向。</p><p>如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。</p><p>因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页</p></blockquote><h3 id="10-cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><a href="#10-cookie-和-token-都存放在-header-中，为什么不会劫持-token？" class="headerlink" title="10. cookie 和 token 都存放在 header 中，为什么不会劫持 token？"></a>10. cookie 和 token 都存放在 header 中，为什么不会劫持 token？</h3><blockquote><p>参考答案：</p><p>由于浏览器会自动发送 cookie 到服务器，因此攻击者可以利用这种特点进行 csrf 攻击。</p><p>而通常 token 是不放到 cookie 中的，需要浏览器端使用 JS 自行保存到 localstorage 中，在请求时也需要手动的加入到请求头中，因此不容易引发 csrf 攻击。</p></blockquote><h3 id="11-介绍下如何实现-token-加密"><a href="#11-介绍下如何实现-token-加密" class="headerlink" title="11. 介绍下如何实现 token 加密"></a>11. 介绍下如何实现 token 加密</h3><blockquote><p>参考答案：</p><p>以最常见的 token 格式 jwt 为例, token 分为三段，分别是 header、payload、signature。 其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。</p><p>token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。</p><p>所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。</p></blockquote><h3 id="12-说下单点登录（新东方）"><a href="#12-说下单点登录（新东方）" class="headerlink" title="12. 说下单点登录（新东方）"></a>12. 说下单点登录（新东方）</h3><blockquote><p>参考答案：</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。</p><p><strong>具体流程是</strong>：</p><ul><li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li><li>sso 认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li><li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 1</li><li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统 2 的受保护资源</li><li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li><li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li><li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 2</li><li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li></ul></blockquote><h3 id="13-http1-1-是如何复用-tcp-连接的？（网易）"><a href="#13-http1-1-是如何复用-tcp-连接的？（网易）" class="headerlink" title="13. http1.1 是如何复用 tcp 连接的？（网易）"></a>13. http1.1 是如何复用 tcp 连接的？（网易）</h3><blockquote><p>参考答案：</p><p>客户端请求服务器时，通过请求行告诉服务器使用的协议是 http1.1，同时在请求头中附带connection:keep-alive（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的 TCP 连接。</p><p>这样做的好处是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于 http1.1 不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在 http2.0 出现之前，实际项目中往往把静态资源，比如图片，分发到不同域名下的资源服务器，以便实现真正的并行传输。</p></blockquote><h3 id="14-文件上传如何做断点续传（网易）"><a href="#14-文件上传如何做断点续传（网易）" class="headerlink" title="14. 文件上传如何做断点续传（网易）"></a>14. 文件上传如何做断点续传（网易）</h3><blockquote><p>参考答案：</p><p>客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。</p><p>若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。</p><p>当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。</p></blockquote><h3 id="15-介绍-SSL-和-TLS（寺库）"><a href="#15-介绍-SSL-和-TLS（寺库）" class="headerlink" title="15. 介绍 SSL 和 TLS（寺库）"></a>15. 介绍 SSL 和 TLS（寺库）</h3><blockquote><p>参考答案：</p><p>它们都是用于保证传输安全的协议，介于传输层和应用层之间，TLS 是 SSL 的升级版。</p><p>它们的基本流程一致：</p><ul><li>客户端向服务器端索要公钥，并使用数字证书验证公钥。</li><li>客户端使用公钥加密会话密钥，服务端用私钥解密会话密钥，于是得到一个双方都认可的会话密钥</li><li>传输的数据使用会话密钥加密，然后再传输，接收消息方使用会话密钥解密得到原始数据</li></ul></blockquote><h3 id="16-说说网络的五层模型（寺库）"><a href="#16-说说网络的五层模型（寺库）" class="headerlink" title="16. 说说网络的五层模型（寺库）"></a>16. 说说网络的五层模型（寺库）</h3><blockquote><p>参考答案：</p><p>从上到下分别为：应用层、传输层、网络层、数据链路层、物理层。在发送消息时，消息从上到下进行打包，每一层会在上一层基础上加包，而接受消息时，从下到上进行解包，最终得到原始信息。</p><p>其中：</p><ul><li>应用层主要面向互联网中的应用场景，比如网页、邮件、文件中心等等，它的代表协议有 http、smtp、pop3、ftp、DNS 等等</li><li>传输层主要面向传输过程，比如 TCP 协议是为了保证可靠的传输，而 UDP 协议则是一种无连接的广播，它们提供了不同的传输方式</li><li>网络层主要解决如何定位目标的问题，比如 IP、ICMP、ARP 等等</li><li>数据链路层的作用是将数据可靠的传输到目标，比如常见的以太网协议、P2P 协议</li><li>物理层是要规范网络两端使用的物理设备，比如蓝牙、wifi、光纤、网线接头等等</li></ul></blockquote><h3 id="17-GET-和-POST-的区别（流利说）"><a href="#17-GET-和-POST-的区别（流利说）" class="headerlink" title="17. GET 和 POST 的区别（流利说）"></a>17. GET 和 POST 的区别（流利说）</h3><blockquote><p>参考答案：</p><p>从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。</p><p>之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。</p><p>受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：</p></blockquote><blockquote><ul><li>浏览器在发送 GET 请求时，不会附带请求体</li><li>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</li><li>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</li><li>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</li><li>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</li><li>GET 请求的地址可以被保存为浏览器书签，POST 不可以</li></ul></blockquote><h3 id="18-http-劫持是什么？"><a href="#18-http-劫持是什么？" class="headerlink" title="18. http 劫持是什么？"></a>18. http 劫持是什么？</h3><blockquote><p>参考答案：</p><p>是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息。</p></blockquote><h3 id="19-HTTP-劫持、DNS-劫持与-XSS"><a href="#19-HTTP-劫持、DNS-劫持与-XSS" class="headerlink" title="19. HTTP 劫持、DNS 劫持与 XSS"></a>19. HTTP 劫持、DNS 劫持与 XSS</h3><blockquote><p>参考答案：</p><p>http 劫持是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息，比如在页面中加入一些广告内容。</p><p>DNS 劫持是指攻击者劫持了 DNS 服务器，获得了修改 DNS 解析记录的权限，从而导致客户端请求的域名被解析到了错误的 IP 地址，攻击者通过这种方式窃取用户资料或破坏原有正常服务。</p><p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p><p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p></blockquote><h3 id="20-介绍-xss-csrf-攻击"><a href="#20-介绍-xss-csrf-攻击" class="headerlink" title="20. 介绍 xss csrf 攻击"></a>20. 介绍 xss csrf 攻击</h3><blockquote><p>参考答案：</p><ul><li>XSS：</li></ul><p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p><p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p><ul><li>CSRF：</li></ul><p>CSRF 是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法</p><p>它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击。</p><p><strong>防御 CSRF 攻击有多种手段：</strong></p><ol><li>不使用cookie</li><li>为表单添加校验的 token 校验</li><li>cookie中使用sameSite字段</li><li>服务器检查 referer 字段</li></ol></blockquote><h3 id="21-https-验证身份也就是-TSL-x2F-SSL-身份验证的过程"><a href="#21-https-验证身份也就是-TSL-x2F-SSL-身份验证的过程" class="headerlink" title="21. https 验证身份也就是 TSL&#x2F;SSL 身份验证的过程"></a>21. https 验证身份也就是 TSL&#x2F;SSL 身份验证的过程</h3><blockquote><p>参考答案：</p><ul><li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li><li>服务器响应公钥和服务器证书</li><li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li><li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li><li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li><li>后续客户端和服务器使用会话密钥加密信息传递消息</li></ul></blockquote><h3 id="22-为什么需要-CA-机构对证书签名"><a href="#22-为什么需要-CA-机构对证书签名" class="headerlink" title="22. 为什么需要 CA 机构对证书签名"></a>22. 为什么需要 CA 机构对证书签名</h3><blockquote><p>参考答案：</p><p>主要是为了解决证书的可信问题。如果没有权威机构对证书进行签名，客户端就无法知晓证书是否是伪造的，从而增加了中间人攻击的风险，https 就变得毫无意义。</p></blockquote><h3 id="23-身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下"><a href="#23-身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下" class="headerlink" title="23. 身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下"></a>23. 身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下</h3><blockquote><p>参考答案：</p><ul><li>密钥</li></ul><p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><ul><li>对称加密</li></ul><p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有 DES、3DES、TDEA、Blowfish、RC5 和 IDEA。</p><ul><li>非对称加密</li></ul><p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p><ul><li>摘要</li></ul><p>摘要算法又称哈希&#x2F;散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用 16 进制的字符串表示）。算法不可逆。</p></blockquote><h3 id="24-webSocket-协议是什么，能简述一下吗？"><a href="#24-webSocket-协议是什么，能简述一下吗？" class="headerlink" title="24. webSocket 协议是什么，能简述一下吗？"></a>24. webSocket 协议是什么，能简述一下吗？</h3><blockquote><p>参考答案：</p><p>websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。</p><p>首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用ws:开头的地址，请求头中要分别加入upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version标记</p><p>然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含Switching Protocols，同时响应头中包含upgrade、connection、Sec-WebSocket-Accept标记</p><p>当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。</p></blockquote><h3 id="25-webSocket-与传统的-http-有什么优势"><a href="#25-webSocket-与传统的-http-有什么优势" class="headerlink" title="25. webSocket 与传统的 http 有什么优势"></a>25. webSocket 与传统的 http 有什么优势</h3><blockquote><p>参考答案：</p><p>当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:</p><p>第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</p><p>第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</p><p>无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。</p><p>websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。</p></blockquote><h3 id="26-如何劫持-https-的请求，提供思路"><a href="#26-如何劫持-https-的请求，提供思路" class="headerlink" title="26. 如何劫持 https 的请求，提供思路"></a>26. 如何劫持 https 的请求，提供思路</h3><blockquote><p>参考答案：</p><p>https 有防篡改的特点，只要浏览器证书验证过程是正确的，很难在用户不察觉的情况下进行攻击。但若能够更改浏览器的证书验证过程，便有机会实现 https 中间人攻击。</p><p>所以，要劫持 https，首先要伪造一个证书，并且要想办法让用户信任这个证书，可以有多种方式，比如病毒、恶意软件、诱导等。一旦证书被信任后，就可以利用普通中间人攻击的方式，使用伪造的证书进行攻击。</p></blockquote><h3 id="27-怎样解决跨域问题？"><a href="#27-怎样解决跨域问题？" class="headerlink" title="27. 怎样解决跨域问题？"></a>27. 怎样解决跨域问题？</h3><blockquote><p>参考答案：</p><ol><li>使用 JSONP</li></ol><p>这是一种古老的解决跨域问题的思路。在需要跨域请求时，事先准备好一个处理服务器数据的函数，然后生成一个script元素，src指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器。</p><p>跨域站点返回一段调用该函数的脚本，当客户端接收到脚本后就会运行事先准备的函数，从而实现跨域获取数据。</p><p>JSONP 实现简单、兼容性好，但缺点也很明显，它只支持 get 请求，同时也有安全性问题，并且对服务器端代码侵入性比较强。</p><ol><li>使用 cors</li></ol><p>在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。</p><p>cors 协议已被各种主流浏览器支持，它安全性高，同时也不会侵入服务器代码，是目前最主流的跨域方式</p><p>除此之外，远古时期的跨域处理还包括 iframe、form 等，由于它们缺陷非常明显，故很少使用了。</p></blockquote><h3 id="28-前端如何实现即时通讯？"><a href="#28-前端如何实现即时通讯？" class="headerlink" title="28. 前端如何实现即时通讯？"></a>28. 前端如何实现即时通讯？</h3><blockquote><p>参考答案：</p><ul><li>短轮询。即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</li><li>长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</li><li>websocket，握手完毕后会建立持久性的连接通道，随后服务器可以在任何时候推送新消息给客户端</li></ul></blockquote><h3 id="29-HTTP-常用状态码-301-302-304-403"><a href="#29-HTTP-常用状态码-301-302-304-403" class="headerlink" title="29. HTTP 常用状态码 301 302 304 403"></a>29. HTTP 常用状态码 301 302 304 403</h3><blockquote><p>参考答案：</p><ul><li>301 永久重定向，浏览器会把重定向后的地址缓存起来，将来用户再次访问原始地址时，直接引导用户访问新地址</li><li>302 临时重定向，浏览器会引导用户进入新地址，但不会缓存原始地址，下一次用户访问源地址时，浏览器仍然要请求原地址的服务器</li><li>304 资源未修改，服务器通过该状态码告诉客户端，请求的资源和过去一样，并没有任何变化，建议自行使用过去的缓存。通常，304 状态码的响应中，服务器不会附带任何的响应体。</li><li>403 不允许访问。服务器通过该状态码告诉客户端，这个资源目前不允许访问。这种状态码通常出现在权限不足的情况下。</li></ul></blockquote><h3 id="30-在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？"><a href="#30-在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？" class="headerlink" title="30. 在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？"></a>30. 在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？</h3><blockquote><p>参考答案：</p><ul><li>浏览器自动补全协议、端口</li><li>浏览器自动完成url编码</li><li>浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求</li><li>通过DNS解析找到服务器的IP地址</li><li>浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立</li><li>若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2</li><li>浏览器决定要附带哪些cookie到请求头中</li><li>浏览器自动设置好请求头、协议版本、cookie，发出GET请求</li><li>服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。</li><li>浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。</li><li>浏览器根据响应状态码决定如何处理这一次响应</li><li>浏览器根据响应头中的Content-Type字段识别响应类型，如果是text&#x2F;html，则对响应体的内容进行HTML解析，否则做其他处理</li><li>浏览器根据响应头的其他内容完成缓存、cookie的设置</li><li>浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源</li><li>解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）</li><li>在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件</li></ul></blockquote><h3 id="30-HTTPS-握手"><a href="#30-HTTPS-握手" class="headerlink" title="30. HTTPS 握手"></a>30. HTTPS 握手</h3><blockquote><p>参考答案：</p><ul><li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li><li>服务器响应公钥和服务器证书</li><li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li><li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li><li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li><li>后续客户端和服务器使用会话密钥加密信息传递消息</li></ul></blockquote><h3 id="32-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#32-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="32. 网页验证码是干嘛的，是为了解决什么安全问题？"></a>32. 网页验证码是干嘛的，是为了解决什么安全问题？</h3><blockquote><p>参考答案：</p><p>验证码主要用于让服务器区分请求是人还是机器发送的。这样做是为了避免某些程序恶意的提交大量信息到服务器，进而导致服务器产生大量的垃圾数据。有时，验证码也可以防止机器暴力破解用户密码，它通过在短时间内不断提交登录信息，尝试各种密码组合来达到破解的目的。</p></blockquote><h3 id="33-http1-0、http2-0、http3-0-之间的区别"><a href="#33-http1-0、http2-0、http3-0-之间的区别" class="headerlink" title="33. http1.0、http2.0、http3.0 之间的区别"></a>33. http1.0、http2.0、http3.0 之间的区别</h3><blockquote><p>参考答案：</p><ul><li>http1.0</li></ul><p>每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p><ol><li>无法复用连接</li></ol><p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p><ol><li>队头阻塞</li></ol><p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p><ul><li>http2.0</li></ul><p>http2.0 优化了传输效率，它主要有以下改进：</p><ol><li>二进制分帧</li></ol><p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p><ol><li>多路复用</li></ol><p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p><ol><li>头部压缩</li></ol><p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p><ol><li>服务器推</li></ol><p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p><ul><li>http3.0</li></ul><p>http3.0 它完全抛弃了 TCP 协议，转而使用 UDP 协议，是为了进一步提升性能。 虽然 http2.0 进行了大量的优化，但它无法摆脱 TCP 协议本身的问题，比如建立连接时间长、对头阻塞问题等等。为了保证传输的可靠性，http3.0 使用了 QUIC 协议。</p></blockquote><h3 id="34-cookie-x2F-sessionStorage-x2F-localStorage-的区别"><a href="#34-cookie-x2F-sessionStorage-x2F-localStorage-的区别" class="headerlink" title="34. cookie&#x2F;sessionStorage&#x2F;localStorage 的区别"></a>34. cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</h3><blockquote><p>参考答案：</p><p>cookie、sessionStorage、localStorage 都是保存本地数据的方式</p><p>其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现set-cookie字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式。</p><p>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。</p><p>cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制</p><p>cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联</p></blockquote><h3 id="35-post-请求什么时候用-form-data-什么时候用-request-payload"><a href="#35-post-请求什么时候用-form-data-什么时候用-request-payload" class="headerlink" title="35. post 请求什么时候用 form data 什么时候用 request payload"></a>35. post 请求什么时候用 form data 什么时候用 request payload</h3><blockquote><p>参考答案：</p><p>form data 适合传递简单的键值对信息，由于传递的信息比较扁平，难以传递深层次嵌套的数据</p><p>request payload 适合传递任意格式的数据，包括单个数字、布尔、深层次嵌套的对象、数组等，但 request payload 不适合传递文件数据</p><p>在前后端分离的项目中，对于非文件数据的传递，都推荐使用 request payload 的形式，以传递最明确的数据类型和数据结构，而对于文件上传，则推荐使用传统的 form data</p></blockquote><h3 id="36-http-常见请求方法有哪些？"><a href="#36-http-常见请求方法有哪些？" class="headerlink" title="36. http 常见请求方法有哪些？"></a>36. http 常见请求方法有哪些？</h3><blockquote><p>参考答案：</p><ul><li>GET，表示向服务器获取资源</li><li>POST，表示向服务器提交信息，通常用于产生新的数据，比如注册</li><li>PUT，表示希望修改服务器的数据，通常用于修改</li><li>DELETE，表示希望删除服务器的数据</li><li>OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交</li><li>TRACE，回显服务器收到的请求，主要用于测试和诊断</li><li>CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到</li></ul></blockquote><h3 id="37-列举优化网络性能方法"><a href="#37-列举优化网络性能方法" class="headerlink" title="37. 列举优化网络性能方法"></a>37. 列举优化网络性能方法</h3><blockquote><p>参考答案：</p><ol><li>优化打包体积</li></ol><p>利用一些工具压缩、混淆最终打包代码，减少包体积</p><ol><li>多目标打包</li></ol><p>利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积</p><ol><li>压缩</li></ol><p>现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的</p><ol><li>CDN</li></ol><p>利用 CDN 可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的 CDN 资源，这样可以实现跨越站点的缓存</p><ol><li>缓存</li></ol><p>对于除 HTML 外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件 hash 值来置换缓存</p><ol><li>http2</li></ol><p>开启 http2 后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据</p><ol><li>雪碧图</li></ol><p>对于不使用 HTTP2 的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的</p><ol><li>defer、async</li></ol><p>通过 defer 和 async 属性，可以让页面尽早加载 js 文件</p><ol><li>prefetch、preload</li></ol><p>通过 prefetch 属性，可以让页面在空闲时预先下载其他页面可能要用到的资源</p><p>通过 preload 属性，可以让页面预先下载本页面可能要用到的资源</p><ol><li>多个静态资源域</li></ol><p>对于不使用 HTTP2 的场景，将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个 TCP 连接，并行下载</p></blockquote><h3 id="38-session-怎么消除"><a href="#38-session-怎么消除" class="headerlink" title="38. session 怎么消除"></a>38. session 怎么消除</h3><blockquote><p>参考答案：</p><ol><li>过期时间</li></ol><p>当客户端长时间没有传递 sessionid 过来时，服务器可以在过期时间之后自动清除 session</p><ol><li>客户端主动通知</li></ol><p>可以使用 JS 监听客户端页面关闭或其他退出操作，然后通知服务器清除 session</p></blockquote><h3 id="39-什么是-DNS-域名解析？"><a href="#39-什么是-DNS-域名解析？" class="headerlink" title="39. 什么是 DNS 域名解析？"></a>39. 什么是 DNS 域名解析？</h3><blockquote><p>参考答案：</p><p>DNS 域名解析是指把域名解析成 IP 地址的过程。</p><p>在具体的实现上，域名解析是由多个层级的服务器共同完成的。在查询域名时，客户端会先检查自身的 DNS 映射表，若找不到解析记录，则使用用户配置的 DNS 服务器，若目标 DNS 服务器中找不到记录，则继续往上一个层级寻找，直到到达根域名服务器，根域名服务器会根据域名的类型，将解析任务分发到对应的子域名服务器依次查找，直到找到解析记录为止。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github 掘金 Html 网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue面试题</title>
    <link href="/2022/11/02/%E6%8E%98%E9%87%91-Vue/"/>
    <url>/2022/11/02/%E6%8E%98%E9%87%91-Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue3-0-为什么要用-proxy？"><a href="#Vue3-0-为什么要用-proxy？" class="headerlink" title="Vue3.0 为什么要用 proxy？"></a>Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li></ul><h3 id="说说你对slot的理解？slot使用场景有哪些"><a href="#说说你对slot的理解？slot使用场景有哪些" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些"></a>说说你对slot的理解？slot使用场景有哪些</h3><h4 id="一、slot是什么"><a href="#一、slot是什么" class="headerlink" title="一、slot是什么"></a>一、slot是什么</h4><p>在HTML中 <code>slot</code> 元素 ，作为 <code>Web Components</code> 技术套件的一部分，是Web组件内的一个占位符</p><p>该占位符可以在后期使用自己的标记语言填充</p><p>举个栗子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;element-details-template&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>Slot template<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">element-details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">element-details</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">element-details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;element-name&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">element-details</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>template</code>不会展示到页面中，需要用先获取它的引用，然后添加到<code>DOM</code>中，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;element-details&#x27;</span>,<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">HTMLElement</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">super</span>();<br>      <span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span><br>        .<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;element-details-template&#x27;</span>)<br>        .<span class="hljs-property">content</span>;<br>      <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123;<span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span>&#125;)<br>        .<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在<code>Vue</code>中的概念也是如此</p><p><code>Slot</code> 艺名插槽，花名“占坑”，我们可以理解为<code>solt</code>在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中<code>slot</code>位置），作为承载分发内容的出口</p><h4 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h4><p>通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p><p>如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情</p><p>通过<code>slot</code>插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用</p><p>比如布局组件、表格列、下拉选、弹框显示内容等</p><h3 id="使用vue渲染大量数据时应该怎么优化？说下你的思路！"><a href="#使用vue渲染大量数据时应该怎么优化？说下你的思路！" class="headerlink" title="使用vue渲染大量数据时应该怎么优化？说下你的思路！"></a>使用vue渲染大量数据时应该怎么优化？说下你的思路！</h3><p><strong>分析</strong></p><p>企业级项目中渲染大量数据的情况比较常见，因此这是一道非常好的综合实践题目。</p><p><strong>回答</strong></p><ol><li>在大型企业级项目中经常需要渲染大量数据，此时很容易出现卡顿的情况。比如大数据量的表格、树</li><li>处理时要根据情况做不同处理：</li></ol><ul><li>可以采取分页的方式获取，避免渲染大量数据</li><li><a href="https://link.juejin.cn/?target=https://github.com/Akryum/vue-virtual-scroller">vue-virtual-scroller <strong>(opens new window)</strong></a>等虚拟滚动方案，只渲染视口范围内的数据</li><li>如果不需要更新，可以使用v-once方式只渲染一次</li><li>通过<a href="https://link.juejin.cn/?target=https://vuejs.org/api/built-in-directives.html%23v-memo">v-memo <strong>(opens new window)</strong></a>可以缓存结果，结合<code>v-for</code>使用，避免数据变化时不必要的<code>VNode</code>创建</li><li>可以采用懒加载方式，在用户需要的时候再加载数据，比如<code>tree</code>组件子树的懒加载</li></ul><ol><li>还是要看具体需求，首先从设计上避免大数据获取和渲染；实在需要这样做可以采用虚表的方式优化渲染；最后优化更新，如果不需要更新可以<code>v-once</code>处理，需要更新可以<code>v-memo</code>进一步优化大数据更新性能。其他可以采用的是交互方式优化，无线滚动、懒加载等方案</li></ol><h3 id="scoped样式穿透"><a href="#scoped样式穿透" class="headerlink" title="scoped样式穿透"></a>scoped样式穿透</h3><blockquote><p><code>scoped</code>虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除<code>scoped</code>属性</p></blockquote><ol><li>使用<code>/deep/</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-comment">&lt;!-- Parent --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.wrap</span> /deep/ <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Child --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>使用两个<code>style</code>标签</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-comment">&lt;!-- Parent --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 其他样式 */</span></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-class">.box</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Child --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Vue中v-html会导致哪些问题"><a href="#Vue中v-html会导致哪些问题" class="headerlink" title="Vue中v-html会导致哪些问题"></a>Vue中v-html会导致哪些问题</h3><ul><li>可能会导致 <code>xss</code> 攻击</li><li><code>v-html</code> 会替换掉标签内部的子元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">let</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-template-compiler&#x27;</span>); <br><span class="hljs-keyword">let</span> r = template.<span class="hljs-title function_">compile</span>(<span class="hljs-string">`&lt;div v-html=&quot;&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;&quot;&gt;&lt;/div&gt;`</span>) <br><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,&#123;domProps: &#123;&quot;innerHTML&quot;:_s(&#x27;&lt;span&gt;hello&lt;/span&gt;&#x27;)&#125;&#125;)&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r.<span class="hljs-property">render</span>);<br><br><span class="hljs-comment">// _c 定义在core/instance/render.js </span><br><span class="hljs-comment">// _s 定义在core/instance/render-helpers/index,js</span><br><span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;textContent&#x27;</span> || key === <span class="hljs-string">&#x27;innerHTML&#x27;</span>) &#123; <br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">if</span> (cur === oldProps[key]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// #6601 work around Chrome version &lt;= 55 bug where single textNode // replaced by innerHTML/textContent retains its parentNode property </span><br>    <span class="hljs-keyword">if</span> (elm.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123; <br>        elm.<span class="hljs-title function_">removeChild</span>(elm.<span class="hljs-property">childNodes</span>[<span class="hljs-number">0</span>]) <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如果让你从零开始写一个vuex，说说你的思路"><a href="#如果让你从零开始写一个vuex，说说你的思路" class="headerlink" title="如果让你从零开始写一个vuex，说说你的思路"></a>如果让你从零开始写一个vuex，说说你的思路</h3><p><strong>思路分析</strong></p><p>这个题目很有难度，首先思考<code>vuex</code>解决的问题：存储用户全局状态并提供管理状态API。</p><ul><li><code>vuex</code>需求分析</li><li>如何实现这些需求</li></ul><p><strong>回答范例</strong></p><ol><li>官方说<code>vuex</code>是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个<code>vuex</code></li></ol><ul><li>要实现一个<code>Store</code>存储全局状态</li><li>要提供修改状态所需API：<code>commit(type, payload), dispatch(type, payload)</code></li></ul><ol><li>实现<code>Store</code>时，可以定义<code>Store</code>类，构造函数接收选项<code>options</code>，设置属性<code>state</code>对外暴露状态，提供<code>commit</code>和<code>dispatch</code>修改属性<code>state</code>。这里需要设置<code>state</code>为响应式对象，同时将<code>Store</code>定义为一个<code>Vue</code>插件</li><li><code>commit(type, payload)</code>方法中可以获取用户传入<code>mutations</code>并执行它，这样可以按用户提供的方法修改状态。 <code>dispatch(type, payload)</code>类似，但需要注意它可能是异步的，需要返回一个<code>Promise</code>给用户以处理异步结果</li></ol><p><strong>实践</strong></p><p><code>Store</code>的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title function_">reactive</span>(options.<span class="hljs-property">state</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options<br>    &#125;<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-params">type, payload</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">mutations</span>[type].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, payload)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vuex简易版</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1 实现插件，挂载$store</span><br><span class="hljs-comment"> * 2 实现store</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Vue</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// state响应式处理</span><br>    <span class="hljs-comment">// 外部访问： this.$store.state.***</span><br>    <span class="hljs-comment">// 第一种写法</span><br>    <span class="hljs-comment">// this.state = new Vue(&#123;</span><br>    <span class="hljs-comment">//   data: options.state</span><br>    <span class="hljs-comment">// &#125;)</span><br><br>    <span class="hljs-comment">// 第二种写法：防止外界直接接触内部vue实例，防止外部强行变更</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>      <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">$$state</span>: options.<span class="hljs-property">state</span><br>      &#125;<br>    &#125;)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span> = options.<span class="hljs-property">mutations</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span> = options.<span class="hljs-property">actions</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getters</span> = &#123;&#125;<br>    options.<span class="hljs-property">getters</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleGetters</span>(options.<span class="hljs-property">getters</span>)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br><br>  get state () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span>.<span class="hljs-property">_data</span>.<span class="hljs-property">$$state</span><br>  &#125;<br><br>  set state (val) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Please use replaceState to reset state&#x27;</span>)<br>  &#125;<br><br>  handleGetters (getters) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(getters).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getters</span>, key, &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> getters[key](<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  commit (type, payload) &#123;<br>    <span class="hljs-keyword">let</span> entry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span>[type]<br>    <span class="hljs-keyword">if</span> (!entry) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span> is not defined`</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">entry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, payload)<br>  &#125;<br><br>  dispatch (type, payload) &#123;<br>    <span class="hljs-keyword">let</span> entry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span>[type]<br>    <span class="hljs-keyword">if</span> (!entry) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span> is not defined`</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">entry</span>(<span class="hljs-variable language_">this</span>, payload)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">install</span> = (<span class="hljs-params">_Vue</span>) =&gt; &#123;<br>  <span class="hljs-title class_">Vue</span> = _Vue<br><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    beforeCreate () &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">store</span>) &#123;<br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$store</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">store</span><br>      &#125;<br>    &#125;,<br>  &#125;)<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-title class_">Store</span>, install &#125;<br></code></pre></td></tr></table></figure><p>验证方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vuex&#x27;</span><br><span class="hljs-comment">// this.$store</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// state从哪里来的</span><br>    add (state) &#123;<br>      state.<span class="hljs-property">counter</span>++<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    doubleCounter (state) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    add (&#123; commit &#125;) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;add&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">modules</span>: &#123;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>参考 <a href="https://link.juejin.cn/?target=https://thoughts.teambition.com/share/638dd9f64d2d2a0042e50fb4">前端进阶面试题详细解答</a></p><h3 id="Vue与Angular以及React的区别？"><a href="#Vue与Angular以及React的区别？" class="headerlink" title="Vue与Angular以及React的区别？"></a>Vue与Angular以及React的区别？</h3><h4 id="Vue与AngularJS的区别"><a href="#Vue与AngularJS的区别" class="headerlink" title="Vue与AngularJS的区别"></a>Vue与AngularJS的区别</h4><ul><li><code>Angular</code>采用<code>TypeScript</code>开发, 而<code>Vue</code>可以使用<code>javascript</code>也可以使用<code>TypeScript</code></li><li><code>AngularJS</code>依赖对数据做脏检查，所以<code>Watcher</code>越多越慢；<code>Vue.js</code>使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li><li><code>AngularJS</code>社区完善, <code>Vue</code>的学习成本较小</li></ul><h4 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h4><p><strong>相同点：</strong></p><ol><li><code>Virtual DOM</code>。其中最大的一个相似之处就是都使用了<code>Virtual DOM</code>。(当然<code>Vue</code>是在<code>Vue2.x</code>才引用的)也就是能让我们通过操作数据的方式来改变真实的<code>DOM</code>状态。因为其实<code>Virtual DOM</code>的本质就是一个<code>JS</code>对象，它保存了对真实<code>DOM</code>的所有描述，是真实<code>DOM</code>的一个映射，所以当我们在进行频繁更新元素的时候，改变这个<code>JS</code>对象的开销远比直接改变真实<code>DOM</code>要小得多。</li><li>组件化的开发思想。第二点来说就是它们都提倡这种组件化的开发思想，也就是建议将应用分拆成一个个功能明确的模块，再将这些模块整合在一起以满足我们的业务需求。</li><li><code>Props</code>。<code>Vue</code>和<code>React</code>中都有<code>props</code>的概念，允许父组件向子组件传递数据。</li><li>构建工具、Chrome插件、配套框架。还有就是它们的构建工具以及Chrome插件、配套框架都很完善。比如构建工具，<code>React</code>中可以使用<code>CRA</code>，<code>Vue</code>中可以使用对应的脚手架<code>vue-cli</code>。对于配套框架<code>Vue</code>中有<code>vuex、vue-router</code>，<code>React</code>中有<code>react-router、redux</code>。</li></ol><p><strong>不同点</strong></p><ol><li>模版的编写。最大的不同就是模版的编写，<code>Vue</code>鼓励你去写近似常规<code>HTML</code>的模板，<code>React</code>推荐你使用<code>JSX</code>去书写。</li><li>状态管理与对象属性。在<code>React</code>中，应用的状态是比较关键的概念，也就是<code>state</code>对象，它允许你使用<code>setState</code>去更新状态。但是在<code>Vue</code>中，<code>state</code>对象并不是必须的，数据是由<code>data</code>属性在<code>Vue</code>对象中进行管理。</li><li>虚拟<code>DOM</code>的处理方式不同。<code>Vue</code>中的虚拟<code>DOM</code>控制了颗粒度，组件层面走<code>watcher</code>通知，而组件内部走<code>vdom</code>做<code>diff</code>，这样，既不会有太多<code>watcher</code>，也不会让<code>vdom</code>的规模过大。而<code>React</code>走了类似于<code>CPU</code>调度的逻辑，把<code>vdom</code>这棵树，微观上变成了链表，然后利用浏览器的空闲时间来做<code>diff</code></li></ol><h3 id="Vue项目中你是如何解决跨域的呢"><a href="#Vue项目中你是如何解决跨域的呢" class="headerlink" title="Vue项目中你是如何解决跨域的呢"></a>Vue项目中你是如何解决跨域的呢</h3><h4 id="一、跨域是什么"><a href="#一、跨域是什么" class="headerlink" title="一、跨域是什么"></a>一、跨域是什么</h4><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p><p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p><blockquote><p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p></blockquote><h3 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h3><p><code>Class</code> 可以通过对象语法和数组语法进行动态绑定</p><p>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&#x27;active&#x27;</span>,<br>  <span class="hljs-attr">errorClass</span>: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Style</code> 也可以通过对象语法和数组语法进行动态绑定</p><p>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:style=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">activeColor</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-number">30</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码&lt;div v-<span class="hljs-attr">bind</span>:style=<span class="hljs-string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-attr">data</span>: &#123;<br>  <span class="hljs-attr">styleColor</span>: &#123;<br>     <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>   &#125;,<br>  <span class="hljs-attr">styleSize</span>:&#123;<br>     <span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;23px&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="了解history有哪些方法吗？说下它们的区别"><a href="#了解history有哪些方法吗？说下它们的区别" class="headerlink" title="了解history有哪些方法吗？说下它们的区别"></a>了解history有哪些方法吗？说下它们的区别</h3><blockquote><p><code>history</code> 这个对象在<code>html5</code>的时候新加入两个<code>api</code> <code>history.pushState()</code> 和 <code>history.repalceState()</code> 这两个<code>API</code>可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。</p></blockquote><p>从参数上来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pushState</span>(state,title,url)<br><span class="hljs-comment">//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取</span><br><span class="hljs-comment">//title：标题，基本没用，一般传null</span><br><span class="hljs-comment">//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。</span><br><span class="hljs-comment">//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, &#x27;./qq/&#x27;)，则变成 https://www.baidu.com/a/qq/，</span><br><span class="hljs-comment">//执行history.pushState(null, null, &#x27;/qq/&#x27;)，则变成 https://www.baidu.com/qq/</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>(state,title,url)<br><span class="hljs-comment">//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录</span><br></code></pre></td></tr></table></figure><p>另外还有：</p><ul><li><code>window.history.back()</code> 后退</li><li><code>window.history.forward()</code>前进</li><li><code>window.history.go(1)</code> 前进或者后退几步</li></ul><p>从触发事件的监听上来说：</p><ul><li><code>pushState()</code>和<code>replaceState()</code>不能被<code>popstate</code>事件所监听</li><li>而后面三者可以，且用户点击浏览器前进后退键时也可以</li></ul><h3 id="在Vue中使用插件的步骤"><a href="#在Vue中使用插件的步骤" class="headerlink" title="在Vue中使用插件的步骤"></a>在Vue中使用插件的步骤</h3><ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li><li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, &#123; someOption: true &#125;)</code></li></ul><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a><code>$route</code>和<code>$router</code>的区别</h3><ul><li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li><li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li></ul><h3 id="为什么要使用异步组件"><a href="#为什么要使用异步组件" class="headerlink" title="为什么要使用异步组件"></a>为什么要使用异步组件</h3><ol><li>节省打包出的结果，异步组件分开打包，采用<code>jsonp</code>的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖<code>import()</code> 语法，可以实现文件的分割加载。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-attr">components</span>:&#123; <br>  <span class="hljs-title class_">AddCustomerSchedule</span>:<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../components/AddCustomer&quot;</span>) <span class="hljs-comment">// require([]) </span><br>&#125;<br></code></pre></td></tr></table></figure><p>原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"> Ctor: Class&lt;Component&gt; | <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span> | <span class="hljs-keyword">void</span>, data: ?VNodeData, context: Component, children: ?<span class="hljs-built_in">Array</span>&lt;VNode&gt;, tag?: string </span>): <span class="hljs-title class_">VNode</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span>&gt; | <span class="hljs-keyword">void</span> &#123; <br>    <span class="hljs-comment">// async component </span><br>    <span class="hljs-keyword">let</span> asyncFactory <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property">cid</span>)) &#123; <br>        asyncFactory = <span class="hljs-title class_">Ctor</span> <br>        <span class="hljs-title class_">Ctor</span> = <span class="hljs-title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor) <span class="hljs-comment">// 默认调用此函数时返回 undefiend </span><br>        <span class="hljs-comment">// 第二次渲染时Ctor不为undefined </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Ctor</span> === <span class="hljs-literal">undefined</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createAsyncPlaceholder</span>( <span class="hljs-comment">// 渲染占位符 空虚拟节点 </span><br>                asyncFactory, <br>                data, <br>                context, <br>                children, <br>                tag <br>            ) <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveAsyncComponent</span> ( <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">baseCtor</span>: <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt; ): <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">Component</span>&gt; | <span class="hljs-keyword">void</span> &#123; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(factory.<span class="hljs-property">resolved</span>)) &#123; <br>        <span class="hljs-comment">// 3.在次渲染时可以拿到获取的最新组件 </span><br>        <span class="hljs-keyword">return</span> factory.<span class="hljs-property">resolved</span> <br>    &#125;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-title function_">once</span>(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123; <br>        factory.<span class="hljs-property">resolved</span> = <span class="hljs-title function_">ensureCtor</span>(res, baseCtor) <br>        <span class="hljs-keyword">if</span> (!sync) &#123; <br>            <span class="hljs-title function_">forceRender</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">//2. 强制更新视图重新渲染 </span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            owners.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <br>        &#125; <br>    &#125;)<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-title function_">once</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(factory.<span class="hljs-property">errorComp</span>)) &#123; <br>            factory.<span class="hljs-property">error</span> = <span class="hljs-literal">true</span> <span class="hljs-title function_">forceRender</span>(<span class="hljs-literal">true</span>) <br>        &#125; <br>    &#125;)<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">factory</span>(resolve, reject)<span class="hljs-comment">// 1.将resolve方法和reject方法传入，用户调用 resolve方法后 </span><br>    sync = <span class="hljs-literal">false</span> <br>    <span class="hljs-keyword">return</span> factory.<span class="hljs-property">resolved</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数式组件优势和原理"><a href="#函数式组件优势和原理" class="headerlink" title="函数式组件优势和原理"></a>函数式组件优势和原理</h3><p><strong>函数组件的特点</strong></p><ol><li>函数式组件需要在声明组件是指定 <code>functional:true</code></li><li>不需要实例化，所以没有<code>this</code>,<code>this</code>通过<code>render</code>函数的第二个参数<code>context</code>来代替</li><li>没有生命周期钩子函数，不能使用计算属性，<code>watch</code></li><li>不能通过<code>$emit</code> 对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件</li><li>因为函数式组件是没有实例化的，所以在外部通过<code>ref</code>去引用组件时，实际引用的是<code>HTMLElement</code></li><li>函数式组件的<code>props</code>可以不用显示声明，所以没有在<code>props</code>里面声明的属性都会被自动隐式解析为<code>prop</code>,而普通组件所有未声明的属性都解析到<code>$attrs</code>里面，并自动挂载到组件根元素上面(可以通过<code>inheritAttrs</code>属性禁止)</li></ol><p><strong>优点</strong></p><ol><li>由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</li><li>函数式组件结构比较简单，代码结构更清晰</li></ol><p><strong>使用场景：</strong></p><ul><li>一个简单的展示组件，作为容器组件使用 比如 <code>router-view</code> 就是一个函数式组件</li><li>“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</li></ul><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;functional&#x27;</span>,&#123; <span class="hljs-comment">// 构造函数产生虚拟节点的</span><br>    <span class="hljs-attr">functional</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 函数式组件 // data=&#123;attrs:&#123;&#125;&#125;</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>源码相关</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// functional component</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property">options</span>.<span class="hljs-property">functional</span>)) &#123; <span class="hljs-comment">// 带有functional的属性的就是函数式组件</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFunctionalComponent</span>(<span class="hljs-title class_">Ctor</span>, propsData, data, context, children)<br>&#125;<br><br><span class="hljs-comment">// extract listeners, since these needs to be treated as</span><br><span class="hljs-comment">// child component listeners instead of DOM listeners</span><br><span class="hljs-keyword">const</span> listeners = data.<span class="hljs-property">on</span> <span class="hljs-comment">// 处理事件</span><br><span class="hljs-comment">// replace with listeners with .native modifier</span><br><span class="hljs-comment">// so it gets processed during parent component patch.</span><br>data.<span class="hljs-property">on</span> = data.<span class="hljs-property">nativeOn</span> <span class="hljs-comment">// 处理原生事件</span><br><br><span class="hljs-comment">// install component management hooks onto the placeholder node</span><br><span class="hljs-title function_">installComponentHooks</span>(data) <span class="hljs-comment">// 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）</span><br></code></pre></td></tr></table></figure><h2 id="Vue-set的实现原理"><a href="#Vue-set的实现原理" class="headerlink" title="Vue.set的实现原理"></a>Vue.set的实现原理</h2><ul><li>给对应和数组本身都增加了<code>dep</code>属性</li><li>当给对象新增不存在的属性则触发对象依赖的<code>watcher</code>去更新</li><li>当修改数组索引时，我们调用数组本身的<code>splice</code>去更新数组（数组的响应式原理就是重新了<code>splice</code>等方法，调用<code>splice</code>就会触发视图更新）</li></ul><p><strong>基本使用</strong></p><blockquote><p>以下方法调用会改变原始数组：<code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code>, <code>sort()</code>, <code>reverse()</code>,<code>Vue.set( target, key, value )</code></p></blockquote><ul><li><p>调用方法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">Vue.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">target</span>, key, value )<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要更改的数据源(可以是对象或者数组)</li><li><code>key</code>：要更改的具体数据</li><li><code>value</code> ：重新赋的值</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>&#123;&#123;user.name&#125;&#125; &#123;&#123;user.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 依赖收集的特点：给每个属性都增加一个dep属性，dep属性会进行收集，收集的是watcher</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 2. vue会给每个对象也增加一个dep属性</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123; <span class="hljs-comment">// vm._data  </span></span><br><span class="language-javascript">            <span class="hljs-attr">user</span>: &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;poetry&#x27;</span>&#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-comment">// 对象的话：调用defineReactive在user对象上定义一个age属性，增加到响应式数据中，触发对象本身的watcher，ob.dep.notify()更新 </span></span><br><span class="language-javascript">    <span class="hljs-comment">// 如果是数组 通过调用 splice方法，触发视图更新</span></span><br><span class="language-javascript">    vm.$set(vm.<span class="hljs-property">user</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 不能给根属性添加，因为给根添加属性 性能消耗太大，需要做很多处理</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 修改肯定是同步的 -&gt; 更新都是一步的  queuewatcher</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>相关源码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// src/core/observer/index.js 44</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123; <span class="hljs-comment">// new Observer(value)</span><br>  <span class="hljs-attr">value</span>: any;<br>  <span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>;<br>  <span class="hljs-attr">vmCount</span>: number; <span class="hljs-comment">// number of vms that have this object as root $data</span><br><br>  <span class="hljs-title function_">constructor</span> (<span class="hljs-attr">value</span>: any) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>() <span class="hljs-comment">// 给所有对象类型增加dep属性</span><br>  &#125;<br>&#125;<br>javascript复制代码<span class="hljs-comment">// src/core/observer/index.js 201</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span> (<span class="hljs-attr">target</span>: <span class="hljs-title class_">Array</span>&lt;any&gt; | <span class="hljs-title class_">Object</span>, <span class="hljs-attr">key</span>: any, <span class="hljs-attr">val</span>: any): any &#123;<br>  <span class="hljs-comment">// 1.是开发环境 target 没定义或者是基础类型则报错</span><br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    (<span class="hljs-title function_">isUndef</span>(target) || <span class="hljs-title function_">isPrimitive</span>(target))<br>  ) &#123;<br>    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Cannot set reactive property on undefined, null, or primitive value: <span class="hljs-subst">$&#123;(target: any)&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 2.如果是数组 Vue.set(array,1,100); 调用我们重写的splice方法 (这样可以更新视图)</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isValidArrayIndex</span>(key)) &#123;<br>    target.<span class="hljs-property">length</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(target.<span class="hljs-property">length</span>, key)<br>    <span class="hljs-comment">// 利用数组的splice变异方法触发响应式  </span><br>    target.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>, val)<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 3.如果是对象本身的属性，则直接添加即可</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> target &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)) &#123;<br>    target[key] = val <span class="hljs-comment">// 直接修改属性值  </span><br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 4.如果是Vue实例 或 根数据data时 报错,（更新_data 无意义）</span><br>  <span class="hljs-keyword">const</span> ob = (<span class="hljs-attr">target</span>: any).<span class="hljs-property">__ob__</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">_isVue</span> || (ob &amp;&amp; ob.<span class="hljs-property">vmCount</span>)) &#123;<br>    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +<br>      <span class="hljs-string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span><br>    )<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 5.如果不是响应式的也不需要将其定义成响应式属性</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[key] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 6.将属性定义成响应式的</span><br>  <span class="hljs-title function_">defineReactive</span>(ob.<span class="hljs-property">value</span>, key, val)<br>  <span class="hljs-comment">// 通知视图更新</span><br>  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们阅读以上源码可知，vm.$set 的实现原理是：</strong></p><ul><li><strong>如果目标是数组</strong> ，直接使用数组的 <code>splice</code> 方法触发相应式；</li><li><strong>如果目标是对象</strong> ，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 <code>defineReactive</code> 方法进行响应式处理（ <code>defineReactive</code> 方法就是 <code>Vue</code> 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li></ul><h3 id="Vue为什么没有类似于React中shouldComponentUpdate的生命周期"><a href="#Vue为什么没有类似于React中shouldComponentUpdate的生命周期" class="headerlink" title="Vue为什么没有类似于React中shouldComponentUpdate的生命周期"></a>Vue为什么没有类似于React中shouldComponentUpdate的生命周期</h3><ul><li>考点: <code>Vue</code>的变化侦测原理</li><li>前置知识: 依赖收集、虚拟<code>DOM</code>、响应式系统</li></ul><blockquote><p>根本原因是<code>Vue</code>与<code>React</code>的变化侦测方式有所不同</p></blockquote><ul><li>当React知道发生变化后，会使用<code>Virtual Dom Diff</code>进行差异检测，但是很多组件实际上是肯定不会发生变化的，这个时候需要 <code>shouldComponentUpdate</code> 进行手动操作来减少<code>diff</code>，从而提高程序整体的性能</li><li><code>Vue</code>在一开始就知道那个组件发生了变化，不需要手动控制<code>diff</code>，而组件内部采用的<code>diff</code>方式实际上是可以引入类似于<code>shouldComponentUpdate</code>相关生命周期的，但是通常合理大小的组件不会有过量的diff，手动优化的价值有限，因此目前<code>Vue</code>并没有考虑引入<code>shouldComponentUpdate</code>这种手动优化的生命周期</li></ul><h3 id="vue-router中如何保护路由"><a href="#vue-router中如何保护路由" class="headerlink" title="vue-router中如何保护路由"></a>vue-router中如何保护路由</h3><p><strong>分析</strong></p><p>路由保护在应用开发过程中非常重要，几乎每个应用都要做各种路由权限管理，因此相当考察使用者基本功。</p><p><strong>体验</strong></p><p>全局守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123; ... &#125;)<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 返回 false 以取消导航</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>路由独享守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span>,<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// reject the navigation</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>组件内的守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserDetails</span> = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`...`</span>,<br>  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被验证前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>    <span class="hljs-comment">// 在导航离开渲染该组件的对应路由时调用</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回答</strong></p><ul><li><code>vue-router</code>中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。</li><li>路由守卫有三个级别：<code>全局</code>、<code>路由独享</code>、<code>组件级</code>。影响范围由大到小，例如全局的<code>router.beforeEach()</code>，可以注册一个全局前置守卫，每次路由导航都会经过这个守卫，因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由；在路由注册的时候可以加入单路由独享的守卫，例如<code>beforeEnter</code>，守卫只在进入路由时触发，因此只会影响这个路由，控制更精确；我们还可以为路由组件添加守卫配置，例如<code>beforeRouteEnter</code>，会在渲染该组件的对应路由被验证前调用，控制的范围更精确了。</li><li>用户的任何导航行为都会走<code>navigate</code>方法，内部有个<code>guards</code>队列按顺序执行用户注册的守卫钩子函数，如果没有通过验证逻辑则会取消原有的导航。</li></ul><p><strong>原理</strong></p><p><code>runGuardQueue(guards)</code>链式的执行用户在各级别注册的守卫钩子函数，通过则继续下一个级别的守卫，不通过进入<code>catch</code>流程取消原本导航</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-comment">// 源码</span><br><span class="hljs-title function_">runGuardQueue</span>(guards)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check global guards beforeEach</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> beforeGuards.<span class="hljs-title function_">list</span>()) &#123;<br>      guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check in components beforeRouteUpdate</span><br>    guards = <span class="hljs-title function_">extractComponentsGuards</span>(<br>      updatingRecords,<br>      <span class="hljs-string">&#x27;beforeRouteUpdate&#x27;</span>,<br>      to,<br>      <span class="hljs-keyword">from</span><br>    )<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record <span class="hljs-keyword">of</span> updatingRecords) &#123;<br>      record.<span class="hljs-property">updateGuards</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">guard</span> =&gt;</span> &#123;<br>        guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>      &#125;)<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check the route beforeEnter</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> record <span class="hljs-keyword">of</span> to.<span class="hljs-property">matched</span>) &#123;<br>      <span class="hljs-comment">// do not trigger beforeEnter on reused views</span><br>      <span class="hljs-keyword">if</span> (record.<span class="hljs-property">beforeEnter</span> &amp;&amp; !<span class="hljs-keyword">from</span>.<span class="hljs-property">matched</span>.<span class="hljs-title function_">includes</span>(record)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(record.<span class="hljs-property">beforeEnter</span>)) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> beforeEnter <span class="hljs-keyword">of</span> record.<span class="hljs-property">beforeEnter</span>)<br>            guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(beforeEnter, to, <span class="hljs-keyword">from</span>))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(record.<span class="hljs-property">beforeEnter</span>, to, <span class="hljs-keyword">from</span>))<br>        &#125;<br>      &#125;<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> at this point to.matched is normalized and does not contain any () =&gt; Promise&lt;Component&gt;</span><br><br>    <span class="hljs-comment">// clear existing enterCallbacks, these are added by extractComponentsGuards</span><br>    to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> (record.<span class="hljs-property">enterCallbacks</span> = &#123;&#125;))<br><br>    <span class="hljs-comment">// check in-component beforeRouteEnter</span><br>    guards = <span class="hljs-title function_">extractComponentsGuards</span>(<br>      enteringRecords,<br>      <span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>,<br>      to,<br>      <span class="hljs-keyword">from</span><br>    )<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-comment">// run the queue of per route beforeEnter guards</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// check global guards beforeResolve</span><br>    guards = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> guard <span class="hljs-keyword">of</span> beforeResolveGuards.<span class="hljs-title function_">list</span>()) &#123;<br>      guards.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">guardToPromiseFn</span>(guard, to, <span class="hljs-keyword">from</span>))<br>    &#125;<br>    guards.<span class="hljs-title function_">push</span>(canceledNavigationCheck)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">runGuardQueue</span>(guards)<br>  &#125;)<br>  <span class="hljs-comment">// catch any navigation canceled</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span><br>    <span class="hljs-title function_">isNavigationFailure</span>(err, <span class="hljs-title class_">ErrorTypes</span>.<span class="hljs-property">NAVIGATION_CANCELLED</span>)<br>      ? err<br>      : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>  )<br></code></pre></td></tr></table></figure><p><a href="https://link.juejin.cn/?target=https://github1s.com/vuejs/router/blob/HEAD/packages/router/src/router.ts%23L808-L809">源码位置(opens new window)</a></p><h3 id="Vue-router-路由钩子在生命周期的体现"><a href="#Vue-router-路由钩子在生命周期的体现" class="headerlink" title="Vue-router 路由钩子在生命周期的体现"></a>Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p><p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p><ol><li>全局路由钩子</li></ol><p>vue-router全局有三个路由钩子;</p><ul><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ul><p>具体使用∶</p><ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">let</span> ifInfo = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$common</span>.<span class="hljs-title function_">getSession</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);  <span class="hljs-comment">// 判断是否登录的存储信息</span><br>    <span class="hljs-keyword">if</span> (!ifInfo) &#123; <br>        <span class="hljs-comment">// sessionStorage里没有储存user信息    </span><br>        <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <br>            <span class="hljs-comment">//如果是登录页面路径，就直接next()      </span><br>            <span class="hljs-title function_">next</span>();    <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-comment">//不然就跳转到登录      </span><br>            <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">warning</span>(<span class="hljs-string">&quot;请重新登录！&quot;</span>);     <br>            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$loginUrl</span>;    <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();  <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <br>    <span class="hljs-comment">// 跳转之后滚动条回到顶部  </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>单个路由独享钩子</li></ol><p><strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [    <br>    &#123;        <br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,        <br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,        <br>        <span class="hljs-attr">component</span>: login,        <br>        <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;          <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;即将进入登录页面&#x27;</span>)          <br>            <span class="hljs-title function_">next</span>()        <br>        &#125;    <br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ol><li>组件内钩子</li></ol><p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p><p>这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;      <br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> &#123;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/classProcess&#x27;</span>) &#123;          <br>            target.<span class="hljs-property">isFromProcess</span> = <span class="hljs-literal">true</span>        <br>        &#125;      <br>    &#125;)    <br>&#125;<br></code></pre></td></tr></table></figure><p>二、Vue路由钩子在生命周期函数的体现</p><ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol><ul><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫beforeRouteLeave</li><li>调用局前置守卫∶ beforeEach</li><li>在重用的组件里调用 beforeRouteUpdate</li><li>调用路由独享守卫 beforeEnter。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用 beforeRouteEnter</li><li>调用全局解析守卫 beforeResolve</li><li>导航被确认。</li><li>调用全局后置钩子的 afterEach 钩子。</li><li>触发DOM更新（mounted）。</li><li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul><ol><li>触发钩子的完整顺序</li></ol><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问&#x2F;操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。</li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h3 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h3><ul><li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h3 id="Vue的diff算法详细分析"><a href="#Vue的diff算法详细分析" class="headerlink" title="Vue的diff算法详细分析"></a>Vue的diff算法详细分析</h3><p><strong>1. 是什么</strong></p><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li></ul><p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p><p><strong>2. 比较方式</strong></p><p><code>diff</code>整体策略为：深度优先，同层比较</p><ol><li>比较只会在同层级进行, 不会跨层级比较</li></ol><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/6db40e34e3ca442d9a5dd0917b0e61c3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><ol><li>比较的过程中，循环从两边向中间收拢</li></ol><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f2f36643d8b84b97a25fcf49ec42956btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p><p>新旧<code>VNode</code>节点如下图所示：</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1787bafd86d24586bc05a2607bd7cd8ftplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/136cfa792cd64daebc60b7586dd2c815tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1336625195f1472ca7360f6f54a82c28tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/d80e4cd2bad14af2801713ddb9e98094tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code>startIndex</code> 移动到了 B</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/1c1b78ece7b64c44812d7e0362389928tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的 startIndex 移动到了 F</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/b882b3d85eb24d85b7570faa587373d3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面</p><img src="/2022/11/02/%E6%8E%98%E9%87%91-Vue/11/02/%E6%8E%98%E9%87%91-Vue/f7987b4d0f7a47d5b46ac3ba59160a79tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" class title="img"><p><strong>3. 原理分析</strong></p><p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p><p>源码位置：<code>src/core/vdom/patch.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVnode, vnode, hydrating, removeOnly</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode)) &#123; <span class="hljs-comment">// 没有新节点，直接执行destory钩子函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode)) <span class="hljs-title function_">invokeDestroyHook</span>(oldVnode)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> isInitialPatch = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> insertedVnodeQueue = []<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldVnode)) &#123;<br>        isInitialPatch = <span class="hljs-literal">true</span><br>        <span class="hljs-title function_">createElm</span>(vnode, insertedVnodeQueue) <span class="hljs-comment">// 没有旧节点，直接用新节点生成dom元素</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> isRealElement = <span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">nodeType</span>)<br>        <span class="hljs-keyword">if</span> (!isRealElement &amp;&amp; <span class="hljs-title function_">sameVnode</span>(oldVnode, vnode)) &#123;<br>            <span class="hljs-comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span><br>            <span class="hljs-title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, removeOnly)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span><br>            <span class="hljs-keyword">if</span> (isRealElement) &#123;<br><br>                <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span> &amp;&amp; oldVnode.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)) &#123;<br>                    oldVnode.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-variable constant_">SSR_ATTR</span>)<br>                    hydrating = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(hydrating)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;<br>                        <span class="hljs-title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="hljs-literal">true</span>)<br>                        <span class="hljs-keyword">return</span> oldVnode<br>                    &#125;<br>                &#125;<br>                oldVnode = <span class="hljs-title function_">emptyNodeAt</span>(oldVnode)<br>            &#125;<br>            <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">elm</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p><ul><li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li><li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ul><p>下面主要讲的是<code>patchVnode</code>部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;<br>    <span class="hljs-comment">// 如果新旧节点一致，什么都不做</span><br>    <span class="hljs-keyword">if</span> (oldVnode === vnode) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span><br>    <span class="hljs-keyword">const</span> elm = vnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span><br><br>    <span class="hljs-comment">// 异步占位符</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isAsyncPlaceholder</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">resolved</span>)) &#123;<br>        <span class="hljs-title function_">hydrate</span>(oldVnode.<span class="hljs-property">elm</span>, vnode, insertedVnodeQueue)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        vnode.<span class="hljs-property">isAsyncPlaceholder</span> = <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 如果新旧都是静态节点，并且具有相同的key</span><br>    <span class="hljs-comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span><br>    <span class="hljs-comment">// 也不用再有其他操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>      <span class="hljs-title function_">isTrue</span>(oldVnode.<span class="hljs-property">isStatic</span>) &amp;&amp;<br>      vnode.<span class="hljs-property">key</span> === oldVnode.<span class="hljs-property">key</span> &amp;&amp;<br>      (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isCloned</span>) || <span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isOnce</span>))<br>    ) &#123;<br>      vnode.<span class="hljs-property">componentInstance</span> = oldVnode.<span class="hljs-property">componentInstance</span><br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> i<br>    <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">prepatch</span>)) &#123;<br>      <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">const</span> ch = vnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isPatchable</span>(vnode)) &#123;<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">update</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">update</span>[i](oldVnode, vnode)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">update</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br>    <span class="hljs-comment">// 如果vnode不是文本节点或者注释节点</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>      <span class="hljs-comment">// 并且都有子节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-comment">// 并且子节点不完全一致，则调用updateChildren</span><br>        <span class="hljs-keyword">if</span> (oldCh !== ch) <span class="hljs-title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)<br><br>        <span class="hljs-comment">// 如果只有新的vnode有子节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span><br>        <span class="hljs-title function_">addVnodes</span>(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, insertedVnodeQueue)<br><br>        <span class="hljs-comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 如果老节点是文本节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) &#123;<br>        nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>)<br>      &#125;<br><br>      <span class="hljs-comment">// 如果新vnode和老vnode是文本节点或注释节点</span><br>      <span class="hljs-comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== vnode.<span class="hljs-property">text</span>) &#123;<br>      nodeOps.<span class="hljs-title function_">setTextContent</span>(elm, vnode.<span class="hljs-property">text</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(data)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">hook</span>) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = i.<span class="hljs-property">postpatch</span>)) <span class="hljs-title function_">i</span>(oldVnode, vnode)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong><code>patchVnode</code>主要做了几个判断：</strong></p><ul><li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li><li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li></ul><p>子节点不完全一致，则调用<code>updateChildren</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs javascript">javascript复制代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">// 旧头索引</span><br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span> <span class="hljs-comment">// 新头索引</span><br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// 旧尾索引</span><br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// 新尾索引</span><br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>] <span class="hljs-comment">// oldVnode的第一个child</span><br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="hljs-comment">// oldVnode的最后一个child</span><br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>] <span class="hljs-comment">// newVnode的第一个child</span><br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="hljs-comment">// newVnode的最后一个child</span><br>    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm<br><br>    <span class="hljs-comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span><br>    <span class="hljs-comment">// to ensure removed elements stay in correct relative positions</span><br>    <span class="hljs-comment">// during leaving transitions</span><br>    <span class="hljs-keyword">const</span> canMove = !removeOnly<br><br>    <span class="hljs-comment">// 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-comment">// 如果oldVnode的第一个child不存在</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;<br>        <span class="hljs-comment">// oldStart索引右移</span><br>        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span><br><br>      <span class="hljs-comment">// 如果oldVnode的最后一个child不存在</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;<br>        <span class="hljs-comment">// oldEnd索引左移</span><br>        oldEndVnode = oldCh[--oldEndIdx]<br><br>      <span class="hljs-comment">// oldStartVnode和newStartVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>        <span class="hljs-comment">// patch oldStartVnode和newStartVnode， 索引左移，继续循环</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue)<br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newStartVnode = newCh[++newStartIdx]<br><br>      <span class="hljs-comment">// oldEndVnode和newEndVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>        <span class="hljs-comment">// patch oldEndVnode和newEndVnode，索引右移，继续循环</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue)<br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newEndVnode = newCh[--newEndIdx]<br><br>      <span class="hljs-comment">// oldStartVnode和newEndVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span><br>        <span class="hljs-comment">// patch oldStartVnode和newEndVnode</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue)<br>        <span class="hljs-comment">// 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后</span><br>        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">elm</span>, nodeOps.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>))<br>        <span class="hljs-comment">// oldStart索引右移，newEnd索引左移</span><br>        oldStartVnode = oldCh[++oldStartIdx]<br>        newEndVnode = newCh[--newEndIdx]<br><br>      <span class="hljs-comment">// 如果oldEndVnode和newStartVnode是同一个节点</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>        <span class="hljs-comment">// patch oldEndVnode和newStartVnode</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue)<br>        <span class="hljs-comment">// 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前</span><br>        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>        <span class="hljs-comment">// oldEnd索引左移，newStart索引右移</span><br>        oldEndVnode = oldCh[--oldEndIdx]<br>        newStartVnode = newCh[++newStartIdx]<br><br>      <span class="hljs-comment">// 如果都不匹配</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)<br><br>        <span class="hljs-comment">// 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode</span><br>        idxInOld = <span class="hljs-title function_">isDef</span>(newStartVnode.<span class="hljs-property">key</span>)<br>          ? oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]<br>          : <span class="hljs-title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)<br><br>        <span class="hljs-comment">// 如果未找到，说明newStartVnode是一个新的节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123; <span class="hljs-comment">// New element</span><br>          <span class="hljs-comment">// 创建一个新Vnode</span><br>          <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>)<br><br>        <span class="hljs-comment">// 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          vnodeToMove = oldCh[idxInOld]<br>          <span class="hljs-comment">/* istanbul ignore if */</span><br>          <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !vnodeToMove) &#123;<br>            <span class="hljs-title function_">warn</span>(<br>              <span class="hljs-string">&#x27;It seems there are duplicate keys that is causing an update error. &#x27;</span> +<br>              <span class="hljs-string">&#x27;Make sure each v-for item has a unique key.&#x27;</span><br>            )<br>          &#125;<br><br>          <span class="hljs-comment">// 比较两个具有相同的key的新节点是否是同一个节点</span><br>          <span class="hljs-comment">//不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;<br>            <span class="hljs-comment">// patch vnodeToMove和newStartVnode</span><br>            <span class="hljs-title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue)<br>            <span class="hljs-comment">// 清除</span><br>            oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>            <span class="hljs-comment">// 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm</span><br>            <span class="hljs-comment">// 移动到oldStartVnode.elm之前</span><br>            canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br><br>          <span class="hljs-comment">// 如果key相同，但是节点不相同，则创建一个新的节点</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// same key but different element. treat as new element</span><br>            <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>)<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 右移</span><br>        newStartVnode = newCh[++newStartIdx]<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong><code>while</code>循环主要处理了以下五种情景：</strong></p><ul><li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li><li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li><li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li><li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<ul><li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li><li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li></ul></li></ul><p><strong>小结</strong></p><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><pre><code class="hljs">patchVnode<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  做了以下操作：<br><br>  - 找到对应的真实`dom`，称为`el`<br>  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点<br>  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点<br>  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`<br>  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点<br><br>- ```<br>  updateChildren<br></code></pre></td></tr></table></figure>主要做了以下操作：- 设置新旧`VNode`的头尾指针- 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>掘金 Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
