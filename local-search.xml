<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>写真集</title>
    <link href="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/"/>
    <url>/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dsadsadsadasdasdasd</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/007.jpg"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/011.jpg" alt="011"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/025.jpg" alt="025"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/037.jpg" alt="037"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/039.jpg" alt="039"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/041.jpg" alt="041"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/043.jpg" alt="043"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/045.jpg" alt="045"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/047.jpg" alt="047"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/053.jpg" alt="053"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/056.jpg" alt="056"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/057%20%E6%8B%B7%E8%B4%9D.jpg" alt="057 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/057.jpg" alt="057"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/061%20%E6%8B%B7%E8%B4%9D.jpg" alt="061 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/061.jpg" alt="061"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/062%20%E6%8B%B7%E8%B4%9D.jpg" alt="062 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/062.jpg" alt="062"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/067%20%E6%8B%B7%E8%B4%9D.jpg" alt="067 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/067.jpg" alt="067"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/072%20%E6%8B%B7%E8%B4%9D.jpg" alt="072 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/072.jpg" alt="072"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/086%20%E6%8B%B7%E8%B4%9D.jpg" alt="086 拷贝"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/086.jpg" alt="086"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/089.jpg" alt="089"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/092.jpg" alt="092"></p><p><img src="/2023/05/25/%E5%86%99%E7%9C%9F%E9%9B%86/094.jpg" alt="094"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/05/25/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是JavaScript？"><a href="#1-什么是JavaScript？" class="headerlink" title="1.什么是JavaScript？"></a>1.什么是JavaScript？</h3><blockquote><p>JavaScript是一种动态、解释型编程语言，它是Web前端开发的基础之一。JavaScript主要用于Web浏览器中的客户端脚本编写，以增强Web页面的交互性和动态性。此外，它也可以用于服务端开发，开发桌面应用程序、游戏等。JavaScript具有简单易学、灵活多变、功能实用等优点，被广泛应用于Web开发、数据可视化、移动开发等领域。</p></blockquote><h3 id="2-如何声明变量？"><a href="#2-如何声明变量？" class="headerlink" title="2.如何声明变量？"></a>2.如何声明变量？</h3><blockquote><p>在JavaScript中，可以使用三个关键字来声明变量，分别是 <code>var</code>、<code>let</code>和<code>const</code>。</p><p>使用<code>var</code>关键字声明的变量可以是全局变量或函数作用域中的局部变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Tom&quot;</span>; <span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;My name is &quot;</span> + name; <span class="hljs-comment">// 局部变量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125;<br><span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出&quot;My name is Tom&quot;</span><br></code></pre></td></tr></table></figure><p>使用 <code>let</code> 和 <code>const</code> 声明的变量则是块级作用域中的局部变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayAge</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">30</span>; <span class="hljs-comment">// 块级变量</span><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br> <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;You are an adult.&quot;</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;You are not an adult yet.&quot;</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125;<br>&#125;<br><span class="hljs-title function_">sayAge</span>(); <span class="hljs-comment">// 输出&quot;You are an adult.&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>const</code> 声明的变量是常量，一旦赋值就不能再修改其值。而 <code>let</code> 声明的变量可以被重新赋值。</p></blockquote><h3 id="3-var、let和const关键字有什么区别？"><a href="#3-var、let和const关键字有什么区别？" class="headerlink" title="3.var、let和const关键字有什么区别？"></a>3.var、let和const关键字有什么区别？</h3><blockquote><p> <code>var</code>、<code>let</code> 和 <code>const</code> 是 JavaScript 中用来声明变量的关键字，它们有以下几点不同：</p><ol><li><p>var 声明的变量可以是全局变量或函数作用域中的局部变量, 而 let 和 const 声明的变量则是块级作用域中的局部变量。</p></li><li><p>var 声明的变量存在变量提升的特性，即可在声明之前使用，而 let 和 const 声明的变量不存在变量提升的特性，必须先声明才能使用。</p></li><li><p>let 和 const 声明的变量是有作用域的，仅在声明的块级作用域中有效。而 var 声明的变量不存在块级作用域，使用 var 声明的变量在函数作用域内有效，如果没有包含在任何函数中，则在全局作用域内有效。</p></li><li><p>let 和 const 声明的变量都是有定义则必须初始化，否则会报错，而 var 声明的变量不是必须初始化。</p></li><li><p><code>const</code> 声明的变量是一个常量，一旦赋值就不能修改，而 <code>let</code> 声明的变量可以被重新赋值。</p></li></ol><p> 综上所述，如果要声明的变量不需要重复赋值，建议使用 <code>const</code>，只有在需要重新赋值时才使用 <code>let</code>，如果需要编写具有较大复杂度的代码时建议避免使用 <code>var</code>。</p></blockquote><h3 id="4-如何将JavaScript代码嵌入到HTML页面中？"><a href="#4-如何将JavaScript代码嵌入到HTML页面中？" class="headerlink" title="4.如何将JavaScript代码嵌入到HTML页面中？"></a>4.如何将JavaScript代码嵌入到HTML页面中？</h3><blockquote><p>可以在 HTML 文件中通过<code>&lt;script&gt;</code>标签来嵌入 JavaScript 代码，格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">// 在这里编写 JavaScript 代码</span></span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript 代码可以嵌入在 HTML 文档的 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 中。 通常，我们会将 JavaScript 代码单独写在一个 <code>.js</code> 文件中，并通过<code>&lt;script&gt;</code>标签的 <code>src</code> 属性引用它。例如，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;myScript.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to my page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>myScript.js</code> 是一个包含 JavaScript 代码的独立文件，该文件需要与 HTML 文件在同一目录下。使用这种方式，JavaScript 代码可以被多个页面共享，还可以避免 HTML 文件过大，使 HTML 文件与 JavaScript 代码分离出来，提高简洁性和可读性。</p></blockquote><h3 id="5-如何用JavaScript创建一个新的HTML元素？"><a href="#5-如何用JavaScript创建一个新的HTML元素？" class="headerlink" title="5.如何用JavaScript创建一个新的HTML元素？"></a>5.如何用JavaScript创建一个新的HTML元素？</h3><blockquote><p>在 JavaScript 中，可以使用 <code>createElement()</code> 方法创建一个新的 HTML 元素。该方法接受一个参数，表示要创建的元素的标签：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上代码会创建一个新的 <code>&lt;div&gt;</code> 元素，并将其保存在 <code>element</code> 变量中。可以使用以下方法来设置创建的元素的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;myDiv&quot;</span>;<br>element.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;important&quot;</span>;<br>element.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;This is my new element!&quot;</span>;<br></code></pre></td></tr></table></figure><p>以上代码会给元素设置 <code>id</code> 和 <code>class</code> 属性，以及设置元素的文本内容。可以将元素插入到文档中的任何位置。例如，可以将新元素插入到 <code>&lt;body&gt;</code> 元素的最后一个子元素之前：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">insertBefore</span>(element, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">lastElementChild</span>);<br></code></pre></td></tr></table></figure><p>以上代码将新元素 <code>element</code> 插入到 <code>&lt;body&gt;</code> 的最后一个子元素之前。最终的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以将元素插入到任何已有元素的内部。例如，可以将新元素插入到具有 <code>id</code> 属性的元素内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myParentElement&quot;</span>);<br>parent.<span class="hljs-title function_">appendChild</span>(element);<br></code></pre></td></tr></table></figure><p>以上代码将新元素 <code>element</code> 插入到元素 <code>myParentElement</code> 的内部。 最终的HTML结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myParentElement&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;important&quot;</span>&gt;</span>This is my new element!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 其他元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6-如何从HTML元素中获取文本内容？"><a href="#6-如何从HTML元素中获取文本内容？" class="headerlink" title="6.如何从HTML元素中获取文本内容？"></a>6.如何从HTML元素中获取文本内容？</h3><blockquote><p>可以使用 JavaScript 中的 <code>textContent</code> 或者 <code>innerHTML</code> 属性从 HTML 元素中获取文本内容。</p><p><code>textContent</code> 属性返回元素及其后代元素的文本内容，但会忽略 HTML 标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myElement&quot;</span>&gt;</span>This is some <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以使用以下 JavaScript 代码获取元素的文本内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><span class="hljs-keyword">var</span> text = element.<span class="hljs-property">textContent</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text); <span class="hljs-comment">// 输出 &quot;This is some bold text.&quot;</span><br></code></pre></td></tr></table></figure><p>如果要获取包括 HTML 标记在内的元素内容，可以使用 <code>innerHTML</code> 属性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><span class="hljs-keyword">var</span> html = element.<span class="hljs-property">innerHTML</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html); <span class="hljs-comment">// 输出 &quot;This is some &lt;strong&gt;bold&lt;/strong&gt; text.&quot;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>innerHTML</code> 属性也可以用于设置元素内容。如果设置的内容包含 HTML 标记，则会在元素内部插入对应的 DOM 树节点。因此，使用 <code>innerHTML</code> 属性时应确保内容是可信的，以避免安全漏洞。</p></blockquote><h3 id="7-如何在JavaScript中使用条件语句？"><a href="#7-如何在JavaScript中使用条件语句？" class="headerlink" title="7.如何在JavaScript中使用条件语句？"></a>7.如何在JavaScript中使用条件语句？</h3><blockquote><p>JavaScript 中的条件语句包括 <code>if</code> 语句、<code>else</code> 分支语句和 <code>else if</code> 语句。其语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (condition) &#123;<br><span class="hljs-regexp">//</span> 如果 condition 为 <span class="hljs-literal">true</span>，执行该代码块<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2) &#123;<br><span class="hljs-regexp">//</span> 如果 condition 为 <span class="hljs-literal">false</span>，但是 condition2 为 <span class="hljs-literal">true</span>，执行该代码块<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span> 如果 condition 和 condition2 都为 <span class="hljs-literal">false</span>，执行该代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>if</code> 后面的 <code>condition</code> 指定了一个条件表达式，如果该条件表达式返回 <code>true</code>，则执行 <code>if</code> 后面的代码块；否则，控制流会跳过该代码块，继续执行下一个语句。如果需要对多个不同的条件进行判断，可以使用 <code>else if</code> 语句。如果所有条件都不成立，则可以使用 <code>else</code> 语句执行备选代码块。</p><p>例如，以下代码检查给定的数字是否大于 10：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;<br><br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is greater than 10&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num === <span class="hljs-number">10</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is equal to 10&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;The number is less than 10&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码会输出以下结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">The <span class="hljs-built_in">number</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">greater than</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>需要注意的是，条件表达式可以返回任何结果，不一定是 <code>true</code> 或 <code>false</code>。如果条件表达式返回一个“真值”（Truthy）的值，则该代码块将被执行；否则，该代码块将被跳过。条件表达式可以是任何可以强制转换为布尔值的表达式，例如数字、字符串和对象。</p></blockquote><h3 id="8-如何在JavaScript中使用循环语句？"><a href="#8-如何在JavaScript中使用循环语句？" class="headerlink" title="8.如何在JavaScript中使用循环语句？"></a>8.如何在JavaScript中使用循环语句？</h3><blockquote><p>在JavaScript中，有几种类型的循环语句可供使用，包括for、while和do-while循环。</p><p>以下是使用这些循环语句的示例：</p><ol><li>for循环<br>for循环可用于按照指定的次数执行代码块，可以用于遍历数组等数据结构。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (initialization; condition; increment/decrement) &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><ol start="2"><li>while循环<br>while循环可用于在满足指定条件时重复执行代码块。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (condition) &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i);<br>  i++;<br>&#125;<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><ol start="3"><li>do-while循环<br>do-while循环与while循环类似，但它先执行一次代码块，然后检查条件是否为真，如果为真则重复执行代码块。</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// code block to be executed</span><br>&#125; <span class="hljs-keyword">while</span> (condition);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>);<br><span class="hljs-comment">// Output: 0, 1, 2, 3, 4</span><br></code></pre></td></tr></table></figure><p>这些循环语句可以嵌套在彼此中，以实现更复杂的逻辑。在编写循环时，请确保使用正确的条件和计数器，以避免陷入无限循环。</p></blockquote><h3 id="9-如何在JavaScript中创建对象？"><a href="#9-如何在JavaScript中创建对象？" class="headerlink" title="9.如何在JavaScript中创建对象？"></a>9.如何在JavaScript中创建对象？</h3><blockquote><p>在 JavaScript 中，对象可以通过多种方式创建，包括使用字面量、构造函数、Object.create() 方法等。下面是一些常用的创建对象的方法：</p><ol><li>使用字面量<br>使用字面量是创建对象的最简单的方法。可以通过花括号包裹键值对来定义一个对象。</li></ol><p>语法：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts">let <span class="hljs-attr">obj</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span> <br><span class="hljs-symbol">  key1:</span> value1, <br><span class="hljs-symbol">  key2:</span> value2,<br>  <span class="hljs-comment">// more key-value pairs </span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let person</span> = &#123;<br>  name: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: 25,<br>  address: &#123;<br>    street: <span class="hljs-string">&#x27;123 Main St&#x27;</span>,<br>    city: <span class="hljs-string">&#x27;Anytown&#x27;</span>,<br>    state: <span class="hljs-string">&#x27;CA&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用构造函数<br>使用构造函数可以创建一个对象的多个实例。构造函数是一种特殊类型的函数，通过关键字 <code>new</code> 来创建对象。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  <span class="hljs-keyword">this</span>.age = age;<br>  <span class="hljs-comment">// more properties and methods</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> person<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">let</span> person<span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 Object.create() 方法<br>使用 Object.create() 方法可以创建一个新对象，并将其原型设置为另一个对象或 null。</li></ol><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto[, propertiesObject]);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personProto = &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(personProto);<br></code></pre></td></tr></table></figure><p>这些方法可以组合使用，例如，可以使用构造函数创建一个对象，然后将其原型设置为另一个对象。创建对象的方式取决于您的需求和代码的结构。</p></blockquote><h3 id="10-如何访问和修改对象的属性？"><a href="#10-如何访问和修改对象的属性？" class="headerlink" title="10.如何访问和修改对象的属性？"></a>10.如何访问和修改对象的属性？</h3><blockquote><p>在 JavaScript 中，可以使用点表示法或方括号表示法来访问和修改对象的属性。以下是访问和修改对象属性的示例：</p><ol><li>点表示法<br>使用点表示法可以访问和修改对象的属性，其中点后面是属性的名称。</li></ol><p>访问属性：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let person = &#123;<br>  <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: <span class="hljs-number">25</span><br>&#125;;<br>console.log(person.name); // Output: <span class="hljs-string">&#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>修改属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person.age = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.age); <span class="hljs-comment">// Output: 30</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方括号表示法<br>使用方括号表示法也可以访问和修改对象的属性，其中方括号内是属性的名称作为字符串。</li></ol><p>访问属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person[<span class="hljs-string">&#x27;name&#x27;</span>]); <span class="hljs-comment">// Output: &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>修改属性：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br>person[<span class="hljs-string">&#x27;age&#x27;</span>] = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person[<span class="hljs-string">&#x27;age&#x27;</span>]); <span class="hljs-comment">// Output: 30</span><br></code></pre></td></tr></table></figure><p>方括号表示法可以动态生成属性名称，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><span class="hljs-keyword">let</span> propName = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[propName]); <span class="hljs-comment">// Output: &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><p>无论使用哪种方法，访问和修改属性都是很简单的。如果属性不存在，访问属性将返回 undefined。如果需要检查属性是否存在，可以使用 hasOwnProperty() 方法。</p></blockquote><h3 id="11-如何在JavaScript中使用函数？"><a href="#11-如何在JavaScript中使用函数？" class="headerlink" title="11.如何在JavaScript中使用函数？"></a>11.如何在JavaScript中使用函数？</h3><blockquote><p>在 JavaScript 中，函数是一种重要的语言构造，可以用于执行特定的任务或操作。以下是使用函数的一些常见方式：</p><ol><li>定义函数<br>定义函数是使用 function 关键字创建的，可以指定函数名称、参数和函数体。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span><span class="hljs-params">(parameter1, parameter2, <span class="hljs-rest_arg">...) &#123;</span></span><br><span class="hljs-rest_arg"><span class="hljs-params">  // function</span> body</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>调用函数<br>调用函数可以使用函数名和括号运算符。如果函数有参数，则将参数传递给括号中。</li></ol><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">greet(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>返回值<br>函数可以返回一个值，可以使用 return 语句来返回值。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><ol start="4"><li>函数表达式<br>函数表达式是将函数分配给变量的一种方式。可以在需要时定义并调用函数。</li></ol><p>语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">let functionName = <span class="hljs-keyword">function</span><span class="hljs-params">(parameter1, parameter2, <span class="hljs-rest_arg">...) &#123;</span></span><br><span class="hljs-rest_arg"><span class="hljs-params">  // function</span> body</span><br><span class="hljs-params">&#125;;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let greet = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br>greet(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// Output: &#x27;Hello, Bob!&#x27;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>箭头函数<br>箭头函数是一种简化的函数表达式，它使用箭头符号（&#x3D;&gt;）来定义函数。</li></ol><p>语法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> functionName =<span class="hljs-function"> (<span class="hljs-params">parameter1</span>, <span class="hljs-params">parameter2</span>, ...) =&gt;</span> &#123;<br>  <span class="hljs-comment">// function body</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>以上是一些基本的 JavaScript 函数使用方法。函数还有其他特性，例如函数作为参数、函数作为对象的方法等，可以根据需求进行学习和使用。</p></blockquote><h3 id="12-如何传递参数给函数？"><a href="#12-如何传递参数给函数？" class="headerlink" title="12.如何传递参数给函数？"></a>12.如何传递参数给函数？</h3><blockquote><p>在 JavaScript 中，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。以下是一些传递参数给函数的常见方式：</p><ol><li>位置参数<br>位置参数是在调用函数时传递的参数，它们按照在函数定义中声明的顺序进行传递。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，调用 add() 函数时传递了两个位置参数，它们分别赋给 a 和 b。</p><ol start="2"><li>默认参数<br>默认参数是在函数定义中声明的参数，如果在调用函数时未传递参数，则使用默认值。</li></ol><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> greet(name = <span class="hljs-string">&#x27;Guest&#x27;</span>) &#123;<br>  console.log(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br>greet(); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Guest!&#x27;</span><br>greet(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> Output: <span class="hljs-string">&#x27;Hello, Alice!&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了默认参数 name，并在函数体中使用它。如果在调用函数时未传递参数，则使用默认值 Guest。</p><ol start="3"><li>剩余参数<br>剩余参数是在函数定义中声明的参数，它们捕获调用函数时未命名的额外参数，并将它们作为数组传递给函数。</li></ol><p>示例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(multiplier, <span class="hljs-rest_arg">...nums</span>)</span> &#123;<br>  let result = multiplier;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    result *= nums[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br>let product = multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>console.log(product); <span class="hljs-comment">// Output: 24</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了 multiplier 和剩余参数 nums，并使用 for 循环将所有数字相乘。</p><p>通过以上这些常见方式，可以将参数传递给函数，以便函数使用这些参数来执行特定的任务。</p></blockquote><h3 id="13-如何在函数内部访问全局变量？"><a href="#13-如何在函数内部访问全局变量？" class="headerlink" title="13.如何在函数内部访问全局变量？"></a>13.如何在函数内部访问全局变量？</h3><blockquote><p>在 JavaScript 中，全局变量是定义在全局作用域中的变量，可以在程序的任何位置进行访问。可以在函数内部访问全局变量，以下是几种常见的方式：</p><ol><li>直接访问<br>可以在函数内部直接访问全局变量。</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar);<br>&#125;<br>sayHello(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部直接访问了全局变量 globalVar。</p><ol start="2"><li>使用 window 对象<br>可以通过 window 对象在函数内部访问全局变量。在浏览器中，所有的全局变量都是 window 对象的属性。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">globalVar</span>);<br>&#125;<br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部使用 window 对象访问了全局变量 globalVar。</p><ol start="3"><li>使用全局对象<br>在 Node.js 等非浏览器环境中，可以使用全局对象来访问全局变量。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>);<br>&#125;<br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 sayHello() 内部使用全局对象 global 访问了全局变量 globalVar。</p><p>以上是在函数内部访问全局变量的几种常见方式，可以根据需要选择适合的方法来访问全局变量。需要注意的是，全局变量可能会影响程序的可读性和可维护性，因此应该尽量避免过多使用全局变量。</p></blockquote><h3 id="14-如何从函数中返回值？"><a href="#14-如何从函数中返回值？" class="headerlink" title="14.如何从函数中返回值？"></a>14.如何从函数中返回值？</h3><blockquote><p>在 JavaScript 中，可以使用 return 语句从函数中返回一个值。当函数执行到 return 语句时，它将停止执行并返回指定的值。以下是一些使用 return 语句返回值的示例：</p><ol><li>返回一个值</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>let <span class="hljs-built_in">sum</span> = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 add() 使用 return 语句返回 a 和 b 的和。</p><ol start="2"><li>返回一个对象</li></ol><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> createUser(<span class="hljs-type">name</span>, age) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-type">name</span>: <span class="hljs-type">name</span>, age: age &#125;;<br>&#125;<br>let <span class="hljs-keyword">user</span> = createUser(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);<br>console.log(<span class="hljs-keyword">user</span>.name); // Output: <span class="hljs-string">&#x27;Alice&#x27;</span><br>console.log(<span class="hljs-keyword">user</span>.age); // Output: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 createUser() 使用 return 语句返回一个包含名称和年龄属性的对象。</p><ol start="3"><li>返回一个函数</li></ol><p>示例：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMultiplier</span>(<span class="hljs-params">multiplier</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num * multiplier;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-built_in">double</span> = createMultiplier(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Output: 10</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，函数 createMultiplier() 使用 return 语句返回一个函数，该函数使用 multiplier 值来创建一个新的函数，该函数可以将其参数乘以 multiplier。</p><p>通过使用 return 语句，可以从函数中返回各种类型的值，包括数字、字符串、对象和函数等。在编写函数时，应该考虑返回什么样的值以及如何处理返回的值。</p></blockquote><h3 id="15-如何在JavaScript中使用事件处理程序？"><a href="#15-如何在JavaScript中使用事件处理程序？" class="headerlink" title="15.如何在JavaScript中使用事件处理程序？"></a>15.如何在JavaScript中使用事件处理程序？</h3><blockquote><p>在 JavaScript 中，可以通过事件处理程序来响应浏览器的用户交互事件，如单击、双击、鼠标移动、键盘按键等。以下是一些常见的使用事件处理程序的方法：</p><ol><li>使用 HTML 属性<br>可以在 HTML 元素上使用事件处理程序属性来指定事件处理程序。例如，可以使用 onclick 属性来指定单击事件的处理程序。</li></ol><p>示例：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>&gt;Click me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure><p>在上面的示例中，单击按钮时将弹出一个包含 “Hello” 的警告框。</p><ol start="2"><li>使用 DOM 事件处理程序<br>可以使用 DOM 方法来添加事件处理程序。例如，可以使用 addEventListener() 方法来添加事件处理程序。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，使用 querySelector() 方法获取一个按钮元素，并使用 addEventListener() 方法添加一个单击事件处理程序。当按钮被单击时，将弹出一个包含 “Hello” 的警告框。</p><ol start="3"><li>使用对象属性<br>可以将事件处理程序指定为对象的属性。例如，可以创建一个包含单击事件处理程序的对象，并将其分配给按钮元素的 onclick 属性。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> handler = &#123;<br>  <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-property">onclick</span> = handler.<span class="hljs-property">handleClick</span>;<br></code></pre></td></tr></table></figure><p>在上面的示例中，创建一个对象 handler，该对象包含一个 handleClick() 方法，该方法在单击事件发生时将弹出一个包含 “Hello” 的警告框。然后将 handleClick() 方法分配给按钮元素的 onclick 属性。</p><p>通过使用这些方法之一，可以在 JavaScript 中添加事件处理程序以响应浏览器的用户交互事件。需要注意的是，在编写事件处理程序时，应该确保它们能够正确处理各种情况，以确保程序的正确性和稳定性。</p></blockquote><h3 id="16-什么是匿名函数？"><a href="#16-什么是匿名函数？" class="headerlink" title="16.什么是匿名函数？"></a>16.什么是匿名函数？</h3><blockquote><p>在 JavaScript 中，匿名函数是一种没有指定名称的函数。匿名函数可以用作函数表达式，也可以用作立即调用的函数表达式 (IIFE)。</p><ol><li>函数表达式中的匿名函数</li></ol><p>函数表达式是将函数分配给变量或属性的一种方法。如果不需要多次引用该函数，则可以使用匿名函数。</p><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Output: 5</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，将匿名函数分配给变量 add，并使用它来执行两个数字的相加操作。</p><ol start="2"><li>立即调用的函数表达式 (IIFE) 中的匿名函数</li></ol><p>IIFE 是一种立即调用的函数表达式，可以在定义后立即调用。匿名函数常常用于 IIFE 中，以便不会在全局作用域中引入不必要的函数名称。</p><p>示例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">function</span> () &#123;<br>  let message = <span class="hljs-symbol">&#x27;Hello</span>&#x27;<span class="hljs-comment">;</span><br>  console.log(<span class="hljs-name">message</span>)<span class="hljs-comment">;</span><br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，创建了一个匿名函数，并立即调用它。在匿名函数中，定义了一个名为 message 的变量，然后将字符串 ‘Hello’ 分配给它，并使用 console.log() 方法在控制台中输出消息。</p><p>由于匿名函数没有名称，因此不会在全局作用域中创建名称，从而避免了命名冲突和全局作用域污染的风险。</p><p>总之，匿名函数是一种灵活且常用的 JavaScript 函数类型，它可以在需要时使用，以避免在全局作用域中引入不必要的名称。</p></blockquote><h3 id="17-如何在JavaScript中处理异常？"><a href="#17-如何在JavaScript中处理异常？" class="headerlink" title="17.如何在JavaScript中处理异常？"></a>17.如何在JavaScript中处理异常？</h3><blockquote><p>在 JavaScript 中，异常处理是一种处理程序运行时出现的错误的机制。异常可以由各种因素引起，例如代码错误、网络问题、I&#x2F;O 错误等。</p><p>以下是在 JavaScript 中处理异常的方法：</p><ol><li>try-catch 语句</li></ol><p>try-catch 语句是一种处理异常的基本方法。它尝试执行可能会引发异常的代码，如果异常被抛出，则 catch 代码块将捕获异常并执行相应的处理。</p><p>示例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 可能会引发异常的代码</span><br>  let result = x / y;<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) &#123;<br>  <span class="hljs-comment">// 处理异常</span><br>  console.log(<span class="hljs-keyword">error</span>.message);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，try 代码块中的代码会尝试执行除法操作 x &#x2F; y。如果 y 为零，则会引发异常，并将其捕获到 catch 代码块中，然后输出错误消息。</p><ol start="2"><li>throw 语句</li></ol><p>throw 语句是一种手动引发异常的方法。它允许开发人员在代码中显式地引发异常，以便在后续的 try-catch 语句中捕获并处理。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">if</span> (y === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Cannot divide by zero&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> x / y;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，定义了一个 divide() 函数，该函数在 y 为零时显式地引发异常。然后，在 try-catch 语句中调用 divide() 函数并捕获异常。</p><ol start="3"><li>finally 语句</li></ol><p>finally 语句是一种在 try-catch 语句执行后无论是否发生异常都要执行的代码块。它通常用于释放资源或执行清理操作。</p><p>示例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 可能会引发异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) &#123;<br>  <span class="hljs-comment">// 处理异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-comment">// 执行清理操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，无论 try-catch 语句中是否发生异常，finally 代码块中的代码都会执行。</p><p>总之，JavaScript 中的异常处理是一种处理程序运行时错误的机制。try-catch 语句、throw 语句和 finally 语句是处理异常的基本方法，它们可以帮助开发人员更好地管理和处理程序中的错误情况。</p></blockquote><h3 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18.什么是闭包？"></a>18.什么是闭包？</h3><blockquote><p>在 JavaScript 中，闭包（Closure）是指一个函数与其词法环境的组合。具体来说，闭包允许函数访问其定义时所处的词法作用域中的变量和参数，即使在函数被调用后，它仍然可以访问这些变量和参数。</p><p>在 JavaScript 中，当一个函数内部定义了另一个函数，并将其返回时，返回的函数就形成了一个闭包。闭包中的函数可以访问包含它的函数的变量和参数，即使包含它的函数已经返回并被销毁。</p><p>以下是一个使用闭包的简单示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">count</span>++;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);<br>&#125;;<br>&#125;<br><br>let counter = createCounter();<br>counter(); <span class="hljs-comment">// 输出 1</span><br>counter(); <span class="hljs-comment">// 输出 2</span><br>counter(); <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，createCounter() 函数返回了一个函数，该函数形成了一个闭包，并可以访问 count 变量。每次调用 counter() 函数时，闭包中的 count 变量都会被递增，并输出当前的计数器值。</p><p>闭包在 JavaScript 中具有广泛的应用，例如：</p><ul><li>实现私有变量和方法</li><li>在循环中创建函数和事件处理程序</li><li>实现柯里化和偏函数等高级编程技巧</li><li>以及其他许多用途</li></ul><p>但是，由于闭包可能导致内存泄漏和性能问题，所以在使用闭包时应该格外小心，并确保及时释放不需要的变量和资源。</p></blockquote><h3 id="19-如何在JavaScript中使用原型？"><a href="#19-如何在JavaScript中使用原型？" class="headerlink" title="19.如何在JavaScript中使用原型？"></a>19.如何在JavaScript中使用原型？</h3><blockquote><p>在 JavaScript 中，每个对象都有一个原型（prototype）对象，该对象包含对象共享的属性和方法。当我们访问一个对象的属性或方法时，如果对象本身没有该属性或方法，JavaScript 就会沿着对象的原型链向上查找，直到找到该属性或方法为止。</p><p>在 JavaScript 中，可以使用构造函数（Constructor Function）来创建对象，每个构造函数都有一个原型对象，我们可以向该对象添加属性和方法。所有使用该构造函数创建的对象都会共享这些属性和方法。</p><p>以下是一个简单的示例，展示了如何使用原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; years old.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-number">25</span>);<br><br>person1.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is John and I&#x27;m 30 years old.&quot;</span><br>person2.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is Jane and I&#x27;m 25 years old.&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用构造函数 Person 创建了两个对象 person1 和 person2，并将它们的 name 和 age 属性设置为不同的值。我们还向 Person.prototype 对象添加了一个方法 greet，用于输出对象的信息。由于 person1 和 person2 都是使用 Person 构造函数创建的，它们都可以访问并使用该方法。</p><p>通过原型，我们可以使多个对象共享相同的属性和方法，这样可以提高程序的性能和代码的可维护性。但是，在修改原型时需要格外小心，因为这会影响到所有使用该构造函数创建的对象。</p></blockquote><h3 id="20-什么是原型链？"><a href="#20-什么是原型链？" class="headerlink" title="20.什么是原型链？"></a>20.什么是原型链？</h3><blockquote><p>在 JavaScript 中，每个对象都有一个原型对象（prototype），该对象包含该对象的共享属性和方法。每个原型对象又可以拥有自己的原型对象，这样就形成了一个原型链（prototype chain）。</p><p>当我们访问一个对象的属性或方法时，JavaScript 会首先查找该对象本身是否具有该属性或方法，如果没有，就会沿着该对象的原型链向上查找，直到找到该属性或方法为止。如果一直查找到最顶层的 Object.prototype 对象仍然没有找到，那么返回 undefined。</p><p>以下是一个简单的示例，展示了原型链的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; years old.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, major</span>) &#123;<br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">major</span> = major;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m studying &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">major</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;Computer Science&quot;</span>);<br><br>student.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, my name is John and I&#x27;m 20 years old.&quot;</span><br>student.<span class="hljs-title function_">study</span>(); <span class="hljs-comment">// 输出 &quot;I&#x27;m studying Computer Science&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了两个构造函数 Person 和 Student，Student 构造函数继承自 Person 构造函数。通过 Student.prototype &#x3D; Object.create(Person.prototype) 这行代码，我们将 Student 的原型对象设置为 Person 的原型对象，这样 Student 对象就可以共享 Person 的属性和方法。当我们调用 student.greet() 方法时，JavaScript 会首先查找 student 对象本身是否有 greet 方法，没有则沿着其原型链向上查找，最终找到 Person.prototype.greet 方法并输出。同样，当我们调用 student.study() 方法时，JavaScript 也会先查找 student 对象是否具有该方法，没有则查找 Person.prototype，最终找到 Student.prototype.study 方法并输出。</p><p>通过原型链，JavaScript 实现了对象之间的继承和属性共享，使代码更加灵活和可维护。</p></blockquote><h3 id="21-如何在JavaScript中实现继承？"><a href="#21-如何在JavaScript中实现继承？" class="headerlink" title="21.如何在JavaScript中实现继承？"></a>21.如何在JavaScript中实现继承？</h3><blockquote><p>在JavaScript中，可以通过以下几种方式来实现继承：</p><ol><li>原型继承：可以通过将一个对象的原型设置为另一个对象来实现继承。这种方法利用JavaScript中的原型链实现了继承，子类可以访问父类的属性和方法，代码示例如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I am an &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><br><span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>dog.<span class="hljs-title function_">say</span>(); <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造函数继承：可以通过在子类构造函数中调用父类构造函数并使用call或apply方法将this绑定到子类实例上来实现继承。这种方法只能继承父类的属性，而不能继承父类的原型上的方法，代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>console.log(dog.<span class="hljs-keyword">type</span>); <span class="hljs-comment">// 输出 &#x27;animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>组合继承：可以通过将原型继承和构造函数继承结合起来，既继承了父类的属性，也继承了父类原型上的方法。代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype.say = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  console.log(&#x27;I am an &#x27; + this.<span class="hljs-keyword">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Animal()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype.constructor = Dog;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>dog.say<span class="hljs-literal">()</span>; <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>寄生组合继承：可以通过使用Object.create方法创建一个中间对象，然后将子类的原型设置为这个中间对象来实现继承。这种方法比组合继承更高效，因为不需要调用父类的构造函数两次。代码示例如下：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Animal(<span class="hljs-params">type</span>)</span> &#123;<br>  this.<span class="hljs-keyword">type</span> = <span class="hljs-keyword">type</span>;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype.say = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  console.log(&#x27;I am an &#x27; + this.<span class="hljs-keyword">type</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Dog(<span class="hljs-params">type</span>)</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>call(this, <span class="hljs-keyword">type</span>);<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Animal</span>.</span></span>prototype);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dog</span>.</span></span>prototype.constructor = Dog;<br><br>var dog = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Dog(&#x27;<span class="hljs-params">animal</span>&#x27;)</span>;<br>dog.say<span class="hljs-literal">()</span>; <span class="hljs-comment">// 输出 &#x27;I am an animal&#x27;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="22-如何在JavaScript中使用对象字面量？"><a href="#22-如何在JavaScript中使用对象字面量？" class="headerlink" title="22.如何在JavaScript中使用对象字面量？"></a>22.如何在JavaScript中使用对象字面量？</h3><blockquote><p>对象字面量是一种创建和初始化JavaScript对象的方式，它使用一组键值对表示对象的属性和值。下面是使用对象字面量创建和初始化对象的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-comment">// 创建一个具有属性的对象</span><br><span class="hljs-keyword">var</span> person = &#123; <br><span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>, <br><span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>, <br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span> <br>&#125;;<br><br><span class="hljs-comment">// 访问对象属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">lastName</span>); <span class="hljs-comment">// 输出 &quot;Doe&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 25</span><br><br><span class="hljs-comment">// 修改对象属性</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 30</span><br><br><span class="hljs-comment">// 添加新属性</span><br>person.<span class="hljs-property">city</span> = <span class="hljs-string">&quot;New York&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">city</span>); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先创建了一个空对象 <code>person</code>，然后使用对象字面量创建了一个具有三个属性的对象，即 <code>firstName</code>、<code>lastName</code>和 <code>age</code>。我们可以使用点号 <code>.</code> 或方括号 <code>[]</code> 访问对象的属性，并且可以随时修改或添加新属性。对象字面量是JavaScript中创建和初始化对象的一种简单、快速且方便的方式。</p></blockquote><h3 id="23-什么是JSON？"><a href="#23-什么是JSON？" class="headerlink" title="23.什么是JSON？"></a>23.什么是JSON？</h3><blockquote><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，被广泛用于前后端数据交互和存储。它是一种文本格式，可读性高，易于理解和编写，并且可以被多种编程语言轻松解析和生成。</p><p>JSON由键值对组成，其中键必须是字符串类型，值可以是字符串、数字、布尔值、对象、数组或null。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Smith&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isMarried&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;street&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123 Main St&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Anytown&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CA&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;zip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;12345&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;phoneNumbers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;555-1234&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;555-5678&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，键值对表示一个人的信息，其中包括姓名、年龄、婚姻状况、地址和电话号码等。地址和电话号码是对象和数组类型的值。</p><p>JSON可以通过JavaScript中的<code>JSON.parse()</code>和<code>JSON.stringify()</code>方法进行解析和序列化。其他编程语言也提供了类似的解析和序列化方法。</p></blockquote><h3 id="24-如何将JSON转换为JavaScript对象？"><a href="#24-如何将JSON转换为JavaScript对象？" class="headerlink" title="24.如何将JSON转换为JavaScript对象？"></a>24.如何将JSON转换为JavaScript对象？</h3><blockquote><p>在JavaScript中，可以使用内置的<code>JSON.parse()</code>方法将JSON字符串转换为JavaScript对象。<code>JSON.parse()</code>方法需要一个JSON字符串作为参数，它会返回一个JavaScript对象。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> jsonString = &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Smith&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: 30&#125;&#x27;;<br><span class="hljs-keyword">const</span> jsObject = JSON.<span class="hljs-keyword">parse</span>(jsonString);<br>console.<span class="hljs-built_in">log</span>(jsObject.name); <span class="hljs-comment">// 输出: John Smith</span><br>console.<span class="hljs-built_in">log</span>(jsObject.age); <span class="hljs-comment">// 输出: 30</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，首先定义了一个JSON字符串，然后使用<code>JSON.parse()</code>方法将其转换为一个JavaScript对象。最后，通过访问对象的属性来获取其值。</p><p>需要注意的是，JSON字符串必须符合JSON规范，否则<code>JSON.parse()</code>方法可能会抛出异常。如果JSON字符串不正确，可以使用在线JSON验证工具（如<a href="https://jsonlint.com/%EF%BC%89%E6%9D%A5%E6%A3%80%E6%9F%A5%E5%B9%B6%E4%BF%AE%E5%A4%8D%E5%AE%83%E3%80%82">https://jsonlint.com/）来检查并修复它。</a></p></blockquote><h3 id="25-如何将JavaScript对象转换为JSON？"><a href="#25-如何将JavaScript对象转换为JSON？" class="headerlink" title="25.如何将JavaScript对象转换为JSON？"></a>25.如何将JavaScript对象转换为JSON？</h3><blockquote><p>在JavaScript中，可以使用内置的<code>JSON.stringify()</code>方法将JavaScript对象转换为JSON字符串。<code>JSON.stringify()</code>方法需要一个JavaScript对象作为参数，它会返回一个表示该对象的JSON字符串。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const jsObject = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;John Smith&#x27;</span>,<br>age: <span class="hljs-number">30</span><br>&#125;;<br>const jsonString = <span class="hljs-type">JSON</span>.stringify(jsObject);<br>console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;age&quot;:<span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，首先定义了一个JavaScript对象，然后使用<code>JSON.stringify()</code>方法将其转换为一个JSON字符串。最后，通过打印字符串来查看结果。</p><p>需要注意的是，<code>JSON.stringify()</code>方法还可以接受一个可选的第二个参数，用于指定要包含在JSON字符串中的属性。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const jsObject = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;John Smith&#x27;</span>,<br>age: <span class="hljs-number">30</span>,<br>address: &#123;<br> street: <span class="hljs-string">&#x27;123 Main St&#x27;</span>,<br> city: <span class="hljs-string">&#x27;Anytown&#x27;</span>,<br> state: <span class="hljs-string">&#x27;CA&#x27;</span>,<br> zip: <span class="hljs-string">&#x27;12345&#x27;</span><br>&#125;<br>&#125;;<br>const jsonString = <span class="hljs-type">JSON</span>.stringify(jsObject, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;address&#x27;</span>]);<br>console.log(jsonString); // 输出: &#123;&quot;name&quot;:&quot;John Smith&quot;,&quot;address&quot;:&#123;&quot;street&quot;:&quot;123 Main St&quot;,&quot;city&quot;:&quot;Anytown&quot;,&quot;state&quot;:&quot;CA&quot;,&quot;zip&quot;:&quot;12345&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，第二个参数是一个数组，包含要序列化为JSON字符串的属性名。在这个例子中，只有<code>name</code>和<code>address</code>属性被包含在了JSON字符串中，<code>age</code>属性被忽略了。</p></blockquote><h3 id="26-如何在JavaScript中使用模板字符串？"><a href="#26-如何在JavaScript中使用模板字符串？" class="headerlink" title="26.如何在JavaScript中使用模板字符串？"></a>26.如何在JavaScript中使用模板字符串？</h3><blockquote><p>在JavaScript中，可以使用模板字符串（template string）来动态生成字符串。模板字符串是由反引号 &#96;&#96; 包裹的字符串，其中可以包含占位符 <code>$&#123;expression&#125;</code>，expression 是一个 JavaScript 表达式，用于动态地插入值。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;John Smith&#x27;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// 输出: Hello, my name is John Smith and I am 30 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个模板字符串 <code>Hello, my name is $&#123;name&#125; and I am $&#123;age&#125; years old.</code>，其中 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code> 是占位符，分别被变量 <code>name</code> 和 <code>age</code> 的值所替换。</p><p>模板字符串还支持多行字符串和嵌套占位符。例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const message = <span class="hljs-string">`</span><br><span class="hljs-string">Hello,</span><br><span class="hljs-string">my name is <span class="hljs-subst">$&#123;name&#125;</span>,</span><br><span class="hljs-string">and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.</span><br><span class="hljs-string">Here is a list of my hobbies:</span><br><span class="hljs-string">  - <span class="hljs-subst">$&#123;hobbies.join(<span class="hljs-string">&#x27;\n- &#x27;</span>)&#125;</span></span><br><span class="hljs-string">`</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(message);<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个多行的模板字符串，其中包含嵌套的占位符 <code>$&#123;name&#125;</code> 和 <code>$&#123;age&#125;</code>，以及使用 <code>Array.join()</code> 方法将数组 <code>hobbies</code> 的每个元素连接成一个以 <code>- </code> 为分隔符的字符串。</p><p>需要注意的是，模板字符串在输出时会保留其原始格式，包括空格、缩进和换行符。如果想要去除多余的空格和换行符，可以使用模板标签（tagged template）或者在占位符中使用正则表达式等方式来处理。</p></blockquote><h3 id="27-什么是箭头函数？"><a href="#27-什么是箭头函数？" class="headerlink" title="27.什么是箭头函数？"></a>27.什么是箭头函数？</h3><blockquote><p>箭头函数（Arrow Function）是ES6新增的一种函数定义方式，它可以更简洁地定义一个函数，并且与普通函数有一些不同的语法特性。</p><p>箭头函数的语法格式如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">(param1, param2, ...) =&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>param1</code>、<code>param2</code> 等是函数的参数，<code>statements</code> 是函数体，可以是一条语句或者多条语句的块。如果函数只有一个参数，则可以省略括号；如果函数体只有一条语句，则可以省略大括号和 <code>return</code> 关键字。</p><p>例如，以下两个函数的定义是等价的：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 使用普通函数定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br><span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-comment">// 使用箭头函数定义</span><br>const square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x;<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个求平方的函数 <code>square</code>，第一个使用了普通函数的定义方式，第二个使用了箭头函数的定义方式。在箭头函数中，可以省略 <code>function</code> 关键字和大括号，从而让函数定义更加简洁。</p><p>除了语法上的简洁性，箭头函数还有一些其他的特性。例如，箭头函数的 <code>this</code> 值绑定到定义函数时的作用域，而不是调用函数时的作用域。这个特性可以避免在使用回调函数时出现 <code>this</code> 值丢失的问题。同时，箭头函数也不能使用 <code>arguments</code> 对象来访问参数，但可以通过使用剩余参数（rest parameter）或者默认参数（default parameter）来实现类似的功能。</p></blockquote><h3 id="28-如何在JavaScript中使用Promise？"><a href="#28-如何在JavaScript中使用Promise？" class="headerlink" title="28.如何在JavaScript中使用Promise？"></a>28.如何在JavaScript中使用Promise？</h3><blockquote><p>Promise是JavaScript异步编程的一种解决方案，它可以更好地处理异步操作的结果和错误，并且可以避免回调地狱（callback hell）的问题。在JavaScript中，Promise是一个对象，用于表示异步操作的最终完成或失败，并且可以链式调用多个操作。</p><p>使用Promise一般需要以下三个步骤：</p><ol><li><p>创建一个Promise对象，通常需要传入一个执行器函数（executor function），它会在Promise对象创建时立即执行，用于执行异步操作并决定Promise的状态。在执行器函数中，可以调用resolve方法来表示异步操作成功完成并返回结果，或者调用reject方法来表示异步操作失败并返回错误信息。</p></li><li><p>调用Promise对象的then方法来注册成功回调和catch方法来注册失败回调。在异步操作完成后，如果操作成功，则会调用成功回调，并且将异步操作的结果作为参数传递给回调函数；如果操作失败，则会调用失败回调，并且将错误信息作为参数传递给回调函数。</p></li><li><p>可以链式调用多个Promise对象，通过then方法返回一个新的Promise对象，并在其回调函数中执行下一个异步操作。如果在链式调用过程中遇到错误，则可以使用catch方法捕获错误并处理。</p></li></ol><p>例如，下面是一个使用Promise实现异步加载图片的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    const img = <span class="hljs-keyword">new</span> Image();<br>    img.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(img);<br>    img.onerror = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;Could not load image&#x27;</span>));<br>    img.src = url;<br>  &#125;);<br>&#125;<br><br>loadImage(<span class="hljs-string">&#x27;https://example.com/image.png&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Image loaded:&#x27;</span>, img);<br>    <span class="hljs-comment">// 执行下一个异步操作</span><br>    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;https://example.com/data.json&#x27;</span>);<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Data loaded:&#x27;</span>, data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它返回一个Promise对象，并且在执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后通过链式调用Promise对象的then方法和catch方法，依次执行多个异步操作，并在回调函数中处理结果或错误。</p></blockquote><h3 id="29-如何在JavaScript中使用异步函数？"><a href="#29-如何在JavaScript中使用异步函数？" class="headerlink" title="29.如何在JavaScript中使用异步函数？"></a>29.如何在JavaScript中使用异步函数？</h3><blockquote><p>异步函数（async function）是ES8（或称ES2017）中新增的语法，它是基于Promise的语法糖，可以更方便地编写异步代码。使用异步函数可以让代码更加简洁、易读和易维护，同时避免回调地狱和手动处理Promise对象的then和catch方法。</p><p>使用异步函数的步骤如下：</p><ol><li><p>在函数声明前面加上async关键字，表示这是一个异步函数。异步函数中可以使用await关键字来等待异步操作的结果，await关键字只能在异步函数中使用。</p></li><li><p>在异步函数中调用异步操作的函数，并使用await关键字等待操作结果。在等待异步操作结果的过程中，JavaScript会暂停当前异步函数的执行，并执行其他的JavaScript代码，直到异步操作完成并返回结果，然后继续执行异步函数。</p></li><li><p>如果异步操作成功完成，则await关键字返回操作结果；如果异步操作失败，则抛出一个错误，可以使用try-catch语句来捕获错误并处理。</p></li></ol><p>例如，下面是一个使用异步函数实现异步加载图片的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(img);<br>    img.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Could not load image&#x27;</span>));<br>    img.<span class="hljs-property">src</span> = url;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-string">&#x27;https://example.com/image.png&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Image loaded:&#x27;</span>, img);<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/data.json&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data loaded:&#x27;</span>, data);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个异步函数 <code>loadImage</code>，它返回一个Promise对象，并且在Promise对象的执行器函数中加载图片并根据加载结果调用resolve或reject方法。然后定义了另一个异步函数 <code>main</code>，它通过使用await关键字等待异步操作的结果来处理异步加载图片和数据的过程。最后调用main函数来启动异步过程，并使用try-catch语句来捕获错误并处理。</p></blockquote><h3 id="30-如何在JavaScript中使用回调函数？"><a href="#30-如何在JavaScript中使用回调函数？" class="headerlink" title="30.如何在JavaScript中使用回调函数？"></a>30.如何在JavaScript中使用回调函数？</h3><blockquote><p>回调函数是一种在JavaScript中广泛使用的技术，它可以让异步代码更容易编写和维护。在JavaScript中，函数可以作为变量传递，因此可以将函数作为参数传递给其他函数，这种被传递的函数就是回调函数。</p><p>使用回调函数的步骤如下：</p><ol><li><p>定义一个异步操作函数，并在该函数中定义一个回调函数参数。异步操作函数可以是自己定义的函数，也可以是JavaScript内置的异步函数，如setTimeout、setInterval、XMLHttpRequest等。</p></li><li><p>在异步操作完成后，调用回调函数并将结果作为参数传递给它。在回调函数中，可以处理异步操作的结果，例如更新页面内容、显示错误信息等。</p></li></ol><p>例如，下面是一个使用回调函数实现异步加载图片的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> load<span class="hljs-constructor">Image(<span class="hljs-params">url</span>, <span class="hljs-params">callback</span>)</span> &#123;<br>  const img = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Image()</span>;<br>  img.onload =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> callback(null, img);<br>  img.onerror =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(&#x27;Could <span class="hljs-params">not</span> <span class="hljs-params">load</span> <span class="hljs-params">image</span>&#x27;)</span>);<br>  img.src = url;<br>&#125;<br><br>load<span class="hljs-constructor">Image(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">example</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">image</span>.<span class="hljs-params">png</span>&#x27;, (<span class="hljs-params">error</span>, <span class="hljs-params">img</span>)</span> =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    console.error(&#x27;Error:&#x27;, error);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    console.log(&#x27;Image loaded:&#x27;, img);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的例子中，定义了一个函数 <code>loadImage</code>，它接受一个图片URL和一个回调函数作为参数。在函数中，创建一个Image对象，并在Image对象的onload和onerror事件中分别调用回调函数并传递操作结果。然后调用 <code>loadImage</code> 函数来启动异步加载图片的过程，并在回调函数中处理加载结果。</p><p>需要注意的是，在使用回调函数时，要避免回调地狱（callback hell）的问题。如果嵌套过多的回调函数，会使代码难以阅读和维护。可以使用Promise、async&#x2F;await等其他技术来解决这个问题。</p></blockquote><h3 id="31-什么是事件委托？"><a href="#31-什么是事件委托？" class="headerlink" title="31.什么是事件委托？"></a>31.什么是事件委托？</h3><blockquote><p>事件委托（Event delegation）是一种优化JavaScript事件处理的技术。它利用事件冒泡的机制，在祖先元素上注册事件，然后通过事件的target属性来判断是哪个后代元素触发了事件。</p><p>使用事件委托的优点包括：</p><ol><li><p>减少事件处理程序的数量：通过将事件处理程序注册到祖先元素上，可以减少页面上的事件处理程序数量，从而提高性能和代码可维护性。</p></li><li><p>动态添加元素：在使用事件委托的情况下，如果动态添加了元素，它们会自动继承祖先元素上的事件处理程序，而不需要手动注册事件。</p></li></ol><p>下面是一个使用事件委托处理按钮点击事件的例子：</p><p>HTML代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Button 3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> list = document.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);<br><br>list.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">event</span> =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.target.tagName === <span class="hljs-string">&#x27;BUTTON&#x27;</span>) &#123;<br>    console.log(<span class="hljs-string">&#x27;Button clicked:&#x27;</span>, <span class="hljs-keyword">event</span>.target.innerText);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的例子中，通过将click事件注册到祖先元素list上，可以处理按钮点击事件。在事件处理程序中，使用event.target属性来判断是哪个后代元素触发了事件，并处理点击事件。需要注意的是，只有当点击的元素是button元素时，才会触发事件处理程序。</p></blockquote><h3 id="32-什么是模块化？"><a href="#32-什么是模块化？" class="headerlink" title="32.什么是模块化？"></a>32.什么是模块化？</h3><blockquote><p>模块化是一种组织和管理JavaScript代码的方式，它将代码分解为独立的模块，每个模块都有自己的作用域，可以独立开发、测试、维护和重用。</p><p>在传统的JavaScript中，所有的代码都是在全局作用域下执行的，容易造成命名冲突、代码耦合度高等问题。而模块化则通过封装变量和函数，将代码组织成可复用的、低耦合的、可维护的模块。</p><p>常见的模块化规范有CommonJS、AMD和ES6模块化。</p><p>CommonJS是一种用于服务器端JavaScript的模块化规范，它使用require()函数来导入模块，使用module.exports对象来导出模块。</p><p>AMD（Asynchronous Module Definition）是一种用于浏览器端JavaScript的模块化规范，它使用define()函数来定义模块，使用require()函数来导入模块。</p><p>ES6模块化是JavaScript的官方模块化规范，它使用import语句来导入模块，使用export语句来导出模块。ES6模块化具有内置的异步加载和懒加载机制，可以在浏览器端和服务器端使用。</p><p>下面是一个使用ES6模块化导入和导出模块的例子：</p><p>模块A代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>模块B代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> moduleB.js<br>import &#123; greeting, sayHello &#125; from <span class="hljs-string">&#x27;./moduleA.js&#x27;</span>;<br><br>sayHello(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-regexp">//</span> 输出: Hello, Alice!<br>console.log(greeting); <span class="hljs-regexp">//</span> 输出: Hello<br></code></pre></td></tr></table></figure><p>在上面的例子中，模块A导出了两个变量：greeting和sayHello，模块B使用import语句来导入这两个变量，并使用它们输出信息。需要注意的是，模块A需要使用export语句来将变量导出，而模块B使用import语句来导入变量。</p></blockquote><h3 id="33-如何在JavaScript中使用模块化？"><a href="#33-如何在JavaScript中使用模块化？" class="headerlink" title="33.如何在JavaScript中使用模块化？"></a>33.如何在JavaScript中使用模块化？</h3><blockquote><p>在JavaScript中使用模块化，可以帮助我们更好地组织代码，并且可以避免全局作用域的污染。下面是几种常见的使用模块化的方法：</p><ol><li>CommonJS：<br>CommonJS是一种用于服务器端JavaScript的模块化系统，它使用require()和module.exports来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = add;<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> add = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br></code></pre></td></tr></table></figure><ol start="2"><li>ES6模块：<br>ES6模块是一种新的JavaScript模块化系统，它使用import和export语句来导入和导出模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用import语句来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br></code></pre></td></tr></table></figure><ol start="3"><li>AMD：<br>AMD（Asynchronous Module Definition）是一种在浏览器端使用的模块化系统，它使用define()和require()函数来定义和导入模块。例如，我们可以在一个文件中定义一个函数，并将其导出：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: add<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后，在另一个文件中，我们可以使用require()函数来导入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./module.js&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>以上是几种常见的模块化方法，每种方法都有其自己的优缺点，可以根据具体的应用场景选择合适的方法。</p></blockquote><h3 id="34-什么是IIFE？"><a href="#34-什么是IIFE？" class="headerlink" title="34.什么是IIFE？"></a>34.什么是IIFE？</h3><blockquote><p>IIFE代表立即调用的函数表达式（Immediately Invoked Function Expression），它是一种用于在JavaScript中创建局部作用域的常见模式。IIFE是一种匿名函数表达式，可以在定义后立即调用它。</p><p>IIFE通常使用以下模式来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 在这里定义变量和函数</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于函数被定义在一个函数作用域内，因此其中定义的变量和函数只在函数内部可见，不会影响全局作用域。这样可以有效地避免变量名和函数名冲突的问题。</p><p>IIFE的另一个常见的用途是将一段代码作为一个整体，并且可以在其中定义私有变量和函数。这样可以防止其他代码修改这些变量和函数，保护代码的安全性和稳定性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> result = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">add</span>();<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个IIFE来创建一个私有的作用域，并在其中定义了变量x和y，以及函数add。然后，我们通过return语句将add函数的返回值返回出来，并将其赋值给变量result。由于x、y和add都是在IIFE的作用域中定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p></blockquote><h3 id="35-如何在JavaScript中使用IIFE？"><a href="#35-如何在JavaScript中使用IIFE？" class="headerlink" title="35.如何在JavaScript中使用IIFE？"></a>35.如何在JavaScript中使用IIFE？</h3><blockquote><p>在JavaScript中使用IIFE非常简单，只需要按照以下模式编写代码即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 在这里编写代码</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个模式中，我们将一个匿名函数包裹在一对圆括号中，然后在函数后面紧跟着另外一对圆括号，这个另外一对圆括号会立即调用这个函数。由于这个匿名函数是立即调用的，因此我们也称之为“立即调用的函数表达式”（IIFE）。</p><p>下面是一个使用IIFE的简单示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> result = x + y;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个IIFE，其中包含了一些变量和逻辑。由于IIFE是立即调用的，因此其中的代码会在JavaScript引擎执行到这个函数时立即执行。在这个例子中，我们在IIFE中定义了变量x和y，并将它们相加赋值给变量result，然后将result打印到控制台上。由于变量x、y和result都是在IIFE的作用域内定义的，因此它们对全局作用域是不可见的，从而保护了代码的私密性。</p></blockquote><h3 id="36-如何设置、获取和删除cookie？"><a href="#36-如何设置、获取和删除cookie？" class="headerlink" title="36.如何设置、获取和删除cookie？"></a>36.如何设置、获取和删除cookie？</h3><blockquote><p>在JavaScript中，可以使用document对象的cookie属性来设置、获取和删除cookie。cookie是一种用于在客户端保存数据的机制，它允许Web应用程序在不同的请求之间共享数据。</p><p>以下是如何设置cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;name=value; expires=Thu, 01 Jan 2026 00:00:00 UTC; path=/&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用document.cookie属性将一个名为name，值为value的cookie写入客户端。expires选项指定了cookie的过期时间，path选项指定了cookie的路径。</p><p>以下是如何获取cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cookieValue = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?:(?:^|.*;\s*)name\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="hljs-string">&quot;$1&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用document.cookie属性获取所有的cookie，然后使用正则表达式来提取名为name的cookie的值。这里使用了一个正则表达式来匹配和提取cookie值。</p><p>以下是如何删除cookie的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将名为name的cookie的值设置为空字符串，并将过期时间设置为一个过去的时间，以便将其删除。path选项也需要与之前设置cookie时的path选项相同，否则可能会出现删除不完全的情况。</p><p>需要注意的是，由于cookie是保存在客户端上的，因此它们可能会被篡改或删除。因此，在处理敏感数据时，应该谨慎使用cookie，并使用其他更安全的机制来保存数据。</p></blockquote><h3 id="37-如何使用localStorage和sessionStorage？"><a href="#37-如何使用localStorage和sessionStorage？" class="headerlink" title="37.如何使用localStorage和sessionStorage？"></a>37.如何使用localStorage和sessionStorage？</h3><blockquote><p>localStorage和sessionStorage都是HTML5中提供的Web存储机制，它们可以用来在客户端上保存数据，并且比cookie更方便、更安全。</p><p>localStorage和sessionStorage的主要区别在于它们的生命周期和作用域：</p><ul><li>localStorage中保存的数据没有过期时间，除非被清除，否则一直存在于客户端上。</li><li>sessionStorage中保存的数据只在当前会话期间有效，当用户关闭浏览器窗口或标签页时会被清除。</li></ul><p>以下是如何使用localStorage和sessionStorage的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将数据保存到localStorage中</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;30&#x27;</span>);<br><br><span class="hljs-comment">// 从localStorage中获取数据</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-keyword">var</span> age = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><br><span class="hljs-comment">// 从localStorage中删除数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><br><span class="hljs-comment">// 将数据保存到sessionStorage中</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-string">&#x27;New York&#x27;</span>);<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;country&#x27;</span>, <span class="hljs-string">&#x27;USA&#x27;</span>);<br><br><span class="hljs-comment">// 从sessionStorage中获取数据</span><br><span class="hljs-keyword">var</span> city = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>);<br><span class="hljs-keyword">var</span> country = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;country&#x27;</span>);<br><br><span class="hljs-comment">// 从sessionStorage中删除数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;city&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先使用setItem()方法将数据保存到localStorage和sessionStorage中，然后使用getItem()方法从中获取数据，使用removeItem()方法从中删除数据。</p><p>需要注意的是，localStorage和sessionStorage中只能保存字符串类型的数据。如果需要保存其他类型的数据，可以先将其序列化为字符串，然后再保存。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;New York&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 将对象序列化为字符串</span><br><span class="hljs-keyword">var</span> personStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(person);<br><br><span class="hljs-comment">// 将字符串保存到localStorage中</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>, personStr);<br><br><span class="hljs-comment">// 从localStorage中获取字符串并反序列化为对象</span><br><span class="hljs-keyword">var</span> personObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;person&#x27;</span>));<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将一个JavaScript对象序列化为一个字符串，然后将这个字符串保存到localStorage中。当需要获取这个对象时，我们先从localStorage中获取这个字符串，然后使用JSON.parse()方法将其反序列化为一个对象。</p></blockquote><h3 id="38-如何使用XMLHttpRequest发送GET请求？"><a href="#38-如何使用XMLHttpRequest发送GET请求？" class="headerlink" title="38.如何使用XMLHttpRequest发送GET请求？"></a>38.如何使用XMLHttpRequest发送GET请求？</h3><blockquote><p>XMLHttpRequest对象是在JavaScript中发送HTTP请求的常用方式之一。使用XMLHttpRequest对象，我们可以向服务器发送GET、POST、PUT等类型的请求，并获取服务器返回的数据。</p><p>以下是使用XMLHttpRequest对象发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个XMLHttpRequest对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 设置请求的URL</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 如果请求成功</span><br><span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">var</span> responseData = xhr.<span class="hljs-property">responseText</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responseData);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// 请求失败，处理错误</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error: &#x27;</span> + xhr.<span class="hljs-property">status</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 发送请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个XMLHttpRequest对象，然后使用open()方法设置请求的URL和HTTP方法。第三个参数指示是否使用异步方式发送请求。然后我们监听XMLHttpRequest对象的onload事件，在请求完成时触发该事件，并在事件处理程序中处理服务器返回的数据。如果请求失败，我们会在事件处理程序中处理错误。</p><p>需要注意的是，XMLHttpRequest对象只能用于同源的请求。如果需要向不同源的服务器发送请求，可以使用JSONP或CORS等技术来解决跨域问题。</p></blockquote><h3 id="39-如何使用XMLHttpRequest发送POST请求？"><a href="#39-如何使用XMLHttpRequest发送POST请求？" class="headerlink" title="39.如何使用XMLHttpRequest发送POST请求？"></a>39.如何使用XMLHttpRequest发送POST请求？</h3><blockquote><p>使用XMLHttpRequest对象发送POST请求与发送GET请求的过程类似，但是我们需要设置请求的Content-Type头部，并将请求体作为send()方法的参数。</p><p>以下是使用XMLHttpRequest对象发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个XMLHttpRequest对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 设置请求的URL和HTTP方法</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置Content-Type头部</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-comment">// 监听XMLHttpRequest对象的onload事件，当请求完成时触发该事件</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 如果请求成功</span><br><span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">var</span> responseData = xhr.<span class="hljs-property">responseText</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responseData);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// 请求失败，处理错误</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error: &#x27;</span> + xhr.<span class="hljs-property">status</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 设置请求体并发送请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData));<br></code></pre></td></tr></table></figure><p>在这个示例中，我们设置了POST请求的Content-Type头部为application&#x2F;json，并将请求体序列化为一个JSON字符串，并作为send()方法的参数。在监听XMLHttpRequest对象的onload事件时，我们将服务器返回的数据作为响应的主体，可以使用responseText属性获取。</p><p>需要注意的是，如果发送的请求体是FormData对象，我们不需要手动设置Content-Type头部，因为XMLHttpRequest对象会自动设置为multipart&#x2F;form-data。</p></blockquote><h3 id="40-如何使用fetch发送请求？"><a href="#40-如何使用fetch发送请求？" class="headerlink" title="40.如何使用fetch发送请求？"></a>40.如何使用fetch发送请求？</h3><blockquote><p>Fetch API是现代浏览器中用于发送HTTP请求的一种标准方式。它使用Promise对象处理异步请求，提供了比传统XMLHttpRequest更简单的API。</p><p>以下是使用fetch发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送GET请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用fetch()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在第一个then()方法中，我们将响应体解析为一个JSON对象。在第二个then()方法中，我们可以对解析后的数据进行处理。如果出现错误，我们可以在catch()方法中处理错误。</p><p>以下是使用fetch发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送POST请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, &#123;<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br><span class="hljs-attr">headers</span>: &#123;<br> <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;,<br><span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(requestData)<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们在fetch()方法的第二个参数中指定了HTTP方法、头部和请求体。与XMLHttpRequest对象类似，我们需要设置Content-Type头部，并将请求体序列化为一个JSON字符串。</p><p>需要注意的是，fetch()方法默认不会发送cookie和身份验证信息。如果需要发送cookie或身份验证信息，需要在fetch()方法的第二个参数中设置credentials属性为’include’。</p></blockquote><h3 id="41-如何使用axios发送请求？"><a href="#41-如何使用axios发送请求？" class="headerlink" title="41.如何使用axios发送请求？"></a>41.如何使用axios发送请求？</h3><blockquote><p>Axios是一种流行的JavaScript库，用于在浏览器和Node.js中发送HTTP请求。它提供了一种简单的API，用于发送GET、POST、PUT、DELETE等类型的请求，并提供了一些可配置的选项，如请求头、超时、取消请求等。</p><p>以下是使用Axios发送GET请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送GET请求</span><br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用axios.get()方法发送了一个GET请求，并在返回的Promise对象上调用then()方法来处理响应。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p><p>以下是使用Axios发送POST请求的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送POST请求</span><br><span class="hljs-keyword">var</span> requestData = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br>axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://example.com/api/data&#x27;</span>, requestData, &#123;<br><span class="hljs-attr">headers</span>: &#123;<br> <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>&#125;<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br> <span class="hljs-comment">// 处理服务器返回的数据</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用axios.post()方法发送了一个POST请求，并将请求体作为第二个参数传递。我们还通过第三个参数指定了请求头。在then()方法中，我们可以使用response.data属性来访问响应的主体。</p><p>需要注意的是，Axios默认情况下会将响应的主体解析为JSON格式，但是如果响应的Content-Type头部不是application&#x2F;json，Axios将不会自动解析JSON数据。如果需要解析其他格式的数据，需要使用其他解析库或手动解析数据。</p></blockquote><h3 id="42-什么是跨域？"><a href="#42-什么是跨域？" class="headerlink" title="42.什么是跨域？"></a>42.什么是跨域？</h3><blockquote><p>跨域（Cross-Origin）是指在浏览器中，一个网页的脚本试图访问不同源（协议、域名或端口）的资源时，就会发生跨域问题。这是由浏览器的同源策略（Same-Origin Policy）导致的，同源策略是一种安全机制，用于防止恶意网站窃取用户数据。</p><p>同源策略要求一个网页的脚本只能与同一源（协议、域名和端口）的资源进行交互。如果脚本试图与不同源的资源进行交互，浏览器就会拒绝请求。例如，一个网页的脚本在example.com域名下运行，试图向api.example.net域名下的API发送请求，这就是跨域请求，浏览器将不会允许这个请求。</p><p>需要注意的是，跨域问题只存在于浏览器环境中，如果是在服务器端发送请求，则不存在跨域问题。因为服务器端不存在同源策略的限制，可以访问任何资源。</p></blockquote><h3 id="43-如何解决跨域问题？"><a href="#43-如何解决跨域问题？" class="headerlink" title="43.如何解决跨域问题？"></a>43.如何解决跨域问题？</h3><blockquote><p>以下是一些解决跨域问题的常用方法：</p><ol><li><p>CORS（Cross-Origin Resource Sharing）：使用CORS，服务器可以发送一个响应头，允许浏览器从不同的源请求资源。CORS需要在服务器端进行配置，通常是在响应头中添加Access-Control-Allow-Origin、Access-Control-Allow-Methods等相关的头信息。</p></li><li><p>JSONP（JSON with Padding）：JSONP是一种使用script元素发送GET请求的技术，由于脚本元素不受同源策略的限制，可以加载任何域名下的JavaScript脚本。使用JSONP，可以将回调函数名作为参数传递给服务器，服务器在返回数据时将数据作为参数传递给回调函数。</p></li><li><p>代理服务器：可以设置一个代理服务器，将客户端请求发送到代理服务器，由代理服务器转发请求到目标服务器，再将目标服务器返回的数据转发给客户端。由于代理服务器是在同一域名下运行的，因此不存在跨域问题。</p></li><li><p>WebSocket：WebSocket是一种全双工通信协议，它可以在不同源之间建立持久连接，可以用于客户端与服务器之间的实时通信，避免了跨域问题。</p></li><li><p>postMessage API：postMessage API可以在不同源之间进行通信，通过在不同窗口之间传递消息，可以实现跨域通信。这种方法需要目标窗口同意，才能进行通信。</p></li></ol><p>需要根据实际情况选择合适的解决方案，其中CORS和代理服务器是最常用的解决方案。</p></blockquote><h3 id="44-什么是事件循环？"><a href="#44-什么是事件循环？" class="headerlink" title="44.什么是事件循环？"></a>44.什么是事件循环？</h3><blockquote><p>事件循环（Event Loop）是JavaScript的一种机制，用于处理异步事件。JavaScript是单线程的，所有任务都在一个线程中执行，包括用户界面操作、计时器事件和网络请求等操作。如果所有任务都是同步的，那么它们将按照代码的书写顺序执行。但是，当涉及到异步任务时，任务的执行顺序就不是确定的，这时就需要事件循环机制来协调任务的执行。</p><p>事件循环通过维护一个事件队列（Event Queue）来管理任务的执行顺序。当任务执行时，如果任务是同步的，则会立即执行并将结果返回，如果任务是异步的，则会将任务加入事件队列中，并继续执行下一个任务。当任务队列为空时，事件循环会等待新的任务加入队列，直到有新的任务加入。</p><p>事件循环机制中的事件队列包括宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）两种。宏任务队列包括定时器事件、I&#x2F;O事件和事件回调等异步任务，而微任务队列则包括Promise和process.nextTick等异步任务。事件循环会先执行微任务队列中的所有任务，然后再执行宏任务队列中的任务。</p><p>事件循环的机制非常重要，因为它决定了异步任务的执行顺序和优先级，理解事件循环机制对于开发高效的JavaScript应用程序非常重要。</p></blockquote><h3 id="45-什么是同步代码？"><a href="#45-什么是同步代码？" class="headerlink" title="45.什么是同步代码？"></a>45.什么是同步代码？</h3><blockquote><p>同步代码是指按照代码的书写顺序依次执行的代码，每个任务必须等待前一个任务完成才能执行。在JavaScript中，通常情况下代码都是同步执行的，例如以下代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，console.log()函数会按照代码的书写顺序依次执行，并输出A、B和C。</p><p>同步代码执行时会阻塞程序的执行，直到当前任务完成，才会执行下一个任务。这意味着如果某个任务执行时间很长，那么整个程序的执行将会被阻塞，用户界面也会变得不响应。</p><p>为了避免长时间的阻塞，可以使用异步代码，将一些耗时的任务放入事件队列中，等待异步处理。当异步任务完成后，事件循环会将其加入执行队列中，优先级高的任务先执行，从而保证程序的响应性和效率。</p></blockquote><h3 id="46-什么是异步代码？"><a href="#46-什么是异步代码？" class="headerlink" title="46.什么是异步代码？"></a>46.什么是异步代码？</h3><blockquote><p>异步代码是指不按照代码书写顺序执行的代码，它们的执行顺序是由事件循环机制控制的。异步代码在执行时不会阻塞程序的执行，因此可以提高程序的效率和响应性。</p><p>在JavaScript中，异步代码通常使用回调函数、Promise、async&#x2F;await等方式来实现。例如，以下代码展示了一个使用回调函数的异步代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，setTimeout函数用于延迟执行，当计时器到期时，事件循环会将回调函数加入执行队列中，从而实现异步执行。由于回调函数是异步执行的，因此会在后台执行，不会阻塞程序的执行。</p><p>异步代码的特点是代码执行不会阻塞程序的执行，可以提高程序的效率和响应性。但是，异步代码的执行顺序是不确定的，需要使用事件循环机制来协调任务的执行。因此，在编写异步代码时需要注意回调函数的使用，避免回调地狱等问题。</p></blockquote><h3 id="47-如何在JavaScript中处理异步代码？"><a href="#47-如何在JavaScript中处理异步代码？" class="headerlink" title="47.如何在JavaScript中处理异步代码？"></a>47.如何在JavaScript中处理异步代码？</h3><blockquote><p>在JavaScript中，处理异步代码通常使用以下三种方式：</p><ol><li>回调函数：回调函数是一种异步编程的基础方式，它是一个作为参数传递给另一个函数的函数，用于在异步任务完成后执行。回调函数的实现通常使用匿名函数或命名函数，例如：</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    callback(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br>asyncFunction(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数是一个异步函数，它接受一个回调函数作为参数，在异步操作完成后执行回调函数。当异步操作完成后，回调函数会被调用，并传递结果参数result。</p><ol start="2"><li>Promise：Promise是一种更加现代化的异步处理方式，它用于处理复杂的异步操作，可以使用链式调用的方式处理多个异步操作。Promise的使用通常分为三个状态：pending、fulfilled和rejected，分别表示异步操作正在进行、异步操作已成功完成和异步操作已失败。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">asyncFunction</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数返回一个Promise对象，异步操作完成后使用resolve方法将结果传递给then方法的回调函数。</p><ol start="3"><li>async&#x2F;await：async&#x2F;await是一种更加简洁和直观的异步处理方式，它基于Promise实现，可以使用同步的方式编写异步代码。async函数用于定义异步函数，await用于暂停代码的执行，等待Promise对象的状态改变。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;<br><br><span class="hljs-title function_">asyncFunction</span>();<br></code></pre></td></tr></table></figure><p>在这个例子中，asyncFunction函数使用async关键字定义异步函数，await暂停代码的执行，等待Promise对象的状态改变。当Promise对象的状态为fulfilled时，结果会被赋值给result变量，并输出到控制台。</p><p>以上三种方式都可以用于处理异步代码，在实际应用中可以根据具体的场景和需求选择合适的方式。</p></blockquote><h3 id="48-什么是防抖？"><a href="#48-什么是防抖？" class="headerlink" title="48.什么是防抖？"></a>48.什么是防抖？</h3><blockquote><p>在前端开发中，防抖（Debouncing）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p><p>防抖的实现方式是设置一个定时器，当函数被调用时，如果定时器已经存在，则清除定时器并重新设置一个新的定时器，等待一定时间后再执行函数。如果在定时器等待的时间内再次调用了该函数，则会重新设置定时器，并等待一定时间后再次执行函数。如果在定时器等待的时间内没有再次调用该函数，则定时器会到期并执行函数。</p><p>防抖的应用场景包括：</p><ol><li><p>搜索框输入联想功能：在用户输入关键字时，如果每输入一个字符就向服务器发送请求，则会导致频繁的网络请求，影响性能和用户体验。使用防抖可以限制请求的频率，只在用户停止输入一段时间后再向服务器发送请求。</p></li><li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用防抖可以限制计算的频率，只在窗口停止调整一段时间后再重新计算。</p></li></ol><p>防抖的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span><span class="hljs-params">(func, delay)</span> &#123;<br>  let timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    clearTimeout(timer);<br>    timer = setTimeout(() =&gt; &#123;<br>      func.apply(<span class="hljs-keyword">this</span>, args);<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用debounce函数</span><br><span class="hljs-keyword">const</span> debouncedFunc = debounce(<span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，debounce函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间之后执行func函数。如果在延迟时间内再次调用该函数，则清除定时器并重新设置一个新的定时器，等待延迟时间后再次执行函数。调用debounce函数后返回一个新的函数debouncedFunc，该函数可以在需要防抖的地方使用。</p></blockquote><h3 id="49-什么是节流？"><a href="#49-什么是节流？" class="headerlink" title="49.什么是节流？"></a>49.什么是节流？</h3><blockquote><p>在前端开发中，节流（Throttling）是一种常见的优化技术，它用于限制某个函数在一段时间内被频繁调用的次数，从而提高应用程序的性能和响应速度。</p><p>节流的实现方式是设置一个定时器，在定时器等待的时间内只允许函数执行一次，等待时间结束后再次允许函数执行。如果在等待时间内再次调用该函数，则该调用会被忽略。这样可以有效减少函数被调用的次数，提高应用程序的性能和响应速度。</p><p>节流的应用场景包括：</p><ol><li><p>滚动事件：在处理滚动事件时，如果每次滚动都处理一次事件，则会导致频繁的计算和渲染，影响性能和用户体验。使用节流可以限制事件的处理频率，只在一段时间内处理一次事件。</p></li><li><p>窗口调整事件：在响应式设计中，当浏览器窗口大小改变时需要重新计算布局和样式，如果每次窗口大小改变都重新计算，则会影响性能和用户体验。使用节流可以限制计算的频率，只在一段时间内重新计算一次。</p></li></ol><p>节流的实现方式可以使用JavaScript的setTimeout和clearTimeout函数，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span><span class="hljs-params">(func, delay)</span> &#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        func.apply(<span class="hljs-keyword">this</span>, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, delay);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用throttle函数</span><br><span class="hljs-keyword">const</span> throttledFunc = throttle(<span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，throttle函数接受一个函数func和延迟时间delay作为参数，返回一个新的函数，该函数使用setTimeout设置一个定时器，在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。调用throttle函数后返回一个新的函数throttledFunc，该函数可以在需要节流的地方使用。</p></blockquote><h3 id="50-如何实现防抖和节流？"><a href="#50-如何实现防抖和节流？" class="headerlink" title="50.如何实现防抖和节流？"></a>50.如何实现防抖和节流？</h3><blockquote><p>防抖和节流是优化前端性能的两种常用方法，它们都通过限制函数的执行次数来减少计算和渲染次数，提高页面性能和响应速度。</p><p>以下是防抖和节流的实现方法：</p><p>防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br><span class="hljs-keyword">let</span> timer;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br> <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br> &#125;, delay);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> debouncedFunc = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，debounce函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数会使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则会清除之前的计时器并重新设置计时器，等待一定时间后执行函数。</p><p>节流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br><span class="hljs-keyword">let</span> timer;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br> <span class="hljs-keyword">if</span> (!timer) &#123;<br>   timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>     timer = <span class="hljs-literal">null</span>;<br>   &#125;, delay);<br> &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> throttledFunc = <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 执行的函数</span><br>&#125;, <span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p>上述代码中，throttle函数接收一个函数func和延迟时间delay作为参数，返回一个新的函数。该新函数使用setTimeout在延迟时间内只允许函数执行一次。如果在等待时间内再次调用该函数，则该调用会被忽略。</p><p>使用防抖和节流可以有效地减少函数的执行次数，提高页面性能和响应速度。需要根据具体场景选择合适的优化方法，并根据实际情况调整延迟时间来达到最优化的效果。</p></blockquote><h3 id="51-什么是深拷贝和浅拷贝？"><a href="#51-什么是深拷贝和浅拷贝？" class="headerlink" title="51.什么是深拷贝和浅拷贝？"></a>51.什么是深拷贝和浅拷贝？</h3><blockquote><p>深拷贝和浅拷贝是JavaScript中常用的两种复制对象的方式，它们之间的区别在于拷贝出的对象是否是对原始对象的完全独立拷贝。</p><p>浅拷贝指的是只复制原始对象的引用，而不是复制对象本身。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象会共享同一份数据，对拷贝出的新对象的修改会影响到原始对象，反之亦然。</p><p>以下是一个浅拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br>copy.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用Object.assign方法将原始对象obj的属性复制到一个新的对象中，并将这个新对象赋值给变量copy。由于浅拷贝的特性，copy.b和obj.b指向同一个对象，因此当我们修改copy.b.c时，obj.b.c的值也会相应地改变。</p><p>深拷贝指的是复制对象本身，而不是复制对象的引用。换句话说，当我们拷贝一个对象时，拷贝出的新对象和原始对象是完全独立的，对拷贝出的新对象的修改不会影响到原始对象，反之亦然。</p><p>以下是一个深拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br> <span class="hljs-keyword">return</span> obj;<br>&#125;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br> <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>   copy[key] = <span class="hljs-title function_">deepCopy</span>(obj[key]);<br> &#125;<br>&#125;<br><span class="hljs-keyword">return</span> copy;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">deepCopy</span>(obj);<br>copy.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出2</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用递归方式实现了一个深拷贝的函数deepCopy，该函数会遍历原始对象的每一个属性，当遇到一个对象类型的属性时，会递归地调用自身来复制这个对象。由于深拷贝的特性，copy.b和obj.b指向两个不同的对象，因此当我们修改copy.b.c时，obj.b.c的值不会改变。</p></blockquote><h3 id="52-如何实现深拷贝和浅拷贝？"><a href="#52-如何实现深拷贝和浅拷贝？" class="headerlink" title="52.如何实现深拷贝和浅拷贝？"></a>52.如何实现深拷贝和浅拷贝？</h3><blockquote><p>JavaScript 中的深拷贝和浅拷贝可以使用以下方式实现：</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝只复制对象的一层属性，而不复制对象的子对象。</p><ol><li>使用 ES6 中的 Object.assign() 方法进行浅拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用展开运算符（spread operator）进行浅拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝复制整个对象及其子对象，不会对原对象造成影响。</p><ol><li>使用 JSON.parse() 和 JSON.stringify() 方法进行深拷贝（需要注意的是，该方法无法处理函数等特殊类型的数据）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: &#123; b: 1 &#125; &#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用递归方式进行深拷贝：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      result[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title function_">deepClone</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123; a: &#123; b: 1 &#125; &#125;</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="53-什么是Event-Loop？"><a href="#53-什么是Event-Loop？" class="headerlink" title="53.什么是Event Loop？"></a>53.什么是Event Loop？</h3><blockquote><p>Event Loop（事件循环）是 JavaScript 中的一个机制，它负责协调调度所有的任务（包括异步任务和同步任务），确保它们按照正确的顺序执行。Event Loop 是 JavaScript 运行时环境的一部分，不同的运行时环境（如浏览器和 Node.js）可能有不同的实现方式，但基本原理是相同的。</p><p>在 JavaScript 中，任务分为同步任务和异步任务，同步任务会在调用栈中按顺序执行，而异步任务则会被放到消息队列中，等待 Event Loop 将其取出执行。</p><p>当调用栈中的所有同步任务执行完毕后，Event Loop 会检查消息队列中是否有待执行的异步任务，如果有，就将其从队列中取出放到调用栈中执行。在执行完异步任务后，又会检查消息队列中是否有待执行的任务，依次重复上述步骤。</p><p>由于 JavaScript 是单线程的语言，只有一个调用栈，所以 Event Loop 的机制使得 JavaScript 能够处理异步任务而不会阻塞调用栈的执行。这也是 JavaScript 能够处理大量 I&#x2F;O 操作的关键之一，例如 Ajax 请求、定时器等异步任务。</p></blockquote><h3 id="54-什么是JavaScript的执行上下文？"><a href="#54-什么是JavaScript的执行上下文？" class="headerlink" title="54.什么是JavaScript的执行上下文？"></a>54.什么是JavaScript的执行上下文？</h3><blockquote><p>在 JavaScript 中，执行上下文是指当前代码执行的环境，包括变量、函数、参数等。每当 JavaScript 引擎执行一段代码时，都会创建一个新的执行上下文，用来存储代码执行过程中的各种信息。</p><p>JavaScript 的执行上下文可以分为三种类型：</p><ol><li><p>全局执行上下文：当 JavaScript 代码第一次被解析和执行时，就会创建一个全局执行上下文，该执行上下文的作用域链包含全局变量对象和全局对象。</p></li><li><p>函数执行上下文：当 JavaScript 解析器进入函数时，就会创建一个新的函数执行上下文，该执行上下文的作用域链包含函数的活动对象、函数对象本身以及全局对象。</p></li><li><p>eval 执行上下文：当 JavaScript 解析器遇到 eval 函数时，会创建一个新的执行上下文，该执行上下文的作用域链包含 eval 函数的活动对象、全局对象以及外部函数的活动对象。</p></li></ol><p>执行上下文有三个重要的属性：</p><ol><li><p>变量对象（VO）：变量对象是执行上下文中的一个重要概念，用来存储函数中定义的变量和函数声明。函数执行上下文的变量对象包括函数的所有参数、函数声明和变量声明。</p></li><li><p>作用域链（Scope Chain）：作用域链是一个由当前执行上下文的变量对象和所有外层执行上下文的变量对象组成的列表，用于解析变量和函数的引用。</p></li><li><p>this 值：this 值是指当前执行上下文的 this 指向的对象，它的值取决于函数的调用方式。</p></li></ol><p>理解执行上下文的概念和属性对于理解 JavaScript 的作用域和执行顺序非常重要。</p></blockquote><h3 id="55-什么是作用域？"><a href="#55-什么是作用域？" class="headerlink" title="55.什么是作用域？"></a>55.什么是作用域？</h3><blockquote><p>在 JavaScript 中，作用域是指变量、函数等命名实体的可访问范围。JavaScript 采用的是词法作用域，也就是静态作用域，即作用域在代码编写时就已经确定，而不是在运行时动态确定。</p><p>JavaScript 中有两种作用域：全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p><p>在 JavaScript 中，作用域的创建是通过函数和块级作用域（ES6 中引入）来实现的。当函数被调用时，会创建一个新的作用域，该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。而块级作用域是指在一对花括号 <code>&#123;&#125;</code> 中定义的变量或函数，只能在该块级作用域内部访问。</p><p>作用域的作用是防止命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，它是指由内向外依次连接起来的作用域列表。当访问一个变量或函数时，JavaScript 引擎会先在当前作用域中查找，如果找不到就会向上一级作用域中查找，直到找到该变量或函数为止。</p></blockquote><h3 id="56-JavaScript的作用域是如何工作的？"><a href="#56-JavaScript的作用域是如何工作的？" class="headerlink" title="56.JavaScript的作用域是如何工作的？"></a>56.JavaScript的作用域是如何工作的？</h3><blockquote><p>JavaScript 的作用域是通过词法作用域来实现的，也就是在代码编写时就已经确定了变量的作用域，而不是在运行时动态确定。</p><p>在 JavaScript 中，作用域分为全局作用域和局部作用域。全局作用域是指在代码中任何地方都可以访问到的变量或函数，而局部作用域则是指在特定代码块内部定义的变量或函数。</p><p>当 JavaScript 解析器遇到一个函数时，会创建一个新的作用域，称为函数作用域。该作用域包含了函数内部定义的变量和函数，同时也可以访问到外部作用域中的变量和函数。如果在函数内部定义了一个变量，它就会覆盖同名的外部变量，而在函数外部则无法访问到该变量。</p><p>在函数作用域中，变量的查找是通过作用域链来实现的。作用域链是一个由内向外连接起来的作用域列表，它的顶端是当前函数的作用域，底部是全局作用域。当访问一个变量时，JavaScript 引擎会首先在当前作用域中查找，如果没有找到，则会向上一级作用域中查找，直到找到该变量或者抵达全局作用域。如果还没有找到该变量，则会抛出一个“变量未定义”的错误。</p><p>除了函数作用域外，ES6 中还引入了块级作用域，通过 <code>let</code> 和 <code>const</code> 关键字定义的变量就是块级作用域。块级作用域的变量只在块级作用域内部可见，超出该范围则无法访问。</p><p>总的来说，JavaScript 的作用域机制是为了避免命名冲突和隔离变量，同时也是实现模块化的重要手段之一。作用域链是 JavaScript 中作用域的一个重要概念，通过它可以实现变量的查找和访问。</p></blockquote><h3 id="57-什么是变量提升？"><a href="#57-什么是变量提升？" class="headerlink" title="57.什么是变量提升？"></a>57.什么是变量提升？</h3><blockquote><p>变量提升是 JavaScript 中的一种行为，指在代码执行之前，JavaScript 引擎会默认将所有变量的声明提升到它们所在的作用域的顶部。换句话说，变量声明会被提升到执行上下文的顶部，但是变量的赋值并不会被提升，赋值操作会按照代码的顺序执行。</p><p>例如，以下代码会输出 <code>undefined</code>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这是因为 JavaScript 引擎在执行代码之前会将变量 <code>a</code> 的声明提升到代码的顶部，因此在执行 <code>console.log(a)</code> 时，变量 <code>a</code> 已经被声明，但是并未被赋值，因此输出 <code>undefined</code>。</p><p>需要注意的是，只有变量声明会被提升，而变量赋值不会被提升。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(a)<span class="hljs-comment">; // ReferenceError: a is not defined</span><br>let a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>由于 <code>let</code> 声明的变量不会被提升，因此在执行 <code>console.log(a)</code> 时会抛出一个 <code>ReferenceError</code> 异常。</p><p>变量提升的机制虽然可以在一定程度上简化代码的书写，但是也容易引起混淆和错误，因此建议在代码中避免过度依赖变量提升，尽可能在变量使用之前进行声明和初始化。</p></blockquote><h3 id="58-如何避免变量提升？"><a href="#58-如何避免变量提升？" class="headerlink" title="58.如何避免变量提升？"></a>58.如何避免变量提升？</h3><blockquote><p>虽然变量提升是 JavaScript 的一种特性，但是可以通过以下几种方式来避免它带来的潜在问题：</p><ol><li><p>使用 <code>let</code> 或 <code>const</code> 关键字声明变量：<code>let</code> 和 <code>const</code> 声明的变量不会被提升，因此可以避免变量提升带来的问题。同时，使用 <code>let</code> 和 <code>const</code> 还可以避免变量重复声明和污染全局作用域的问题。</p></li><li><p>将变量声明和赋值分开：为了避免变量提升导致的混淆和错误，可以将变量声明和赋值分开，确保变量在使用前已经被正确地初始化。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let a<span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>console.log(a)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>使用模块化编程：使用模块化编程可以将代码分割成多个独立的模块，每个模块都有自己的作用域，变量不会污染全局作用域，也不会被其他模块访问到，从而避免了变量提升带来的问题。</p></li></ol><p>虽然变量提升可以带来一定的方便，但是建议在编写 JavaScript 代码时尽量避免过度依赖变量提升，以提高代码的可读性和可维护性。</p></blockquote><h3 id="59-什么是模板标签函数？"><a href="#59-什么是模板标签函数？" class="headerlink" title="59.什么是模板标签函数？"></a>59.什么是模板标签函数？</h3><blockquote><p>模板标签函数是一种 JavaScript 函数，可以用于自定义模板字符串的解析方式。模板标签函数的作用是将模板字符串解析成一个 JavaScript 对象，可以对模板字符串中的变量进行处理和格式化。</p><p>模板标签函数的定义方式是在模板字符串前面添加一个标识符，例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myTag</span><span class="hljs-params">(strings, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br><span class="hljs-comment">// 处理模板字符串中的字符串和变量</span><br><span class="hljs-comment">// 返回一个处理后的结果</span><br>&#125;<br><br>let str = myTag`Hello, $&#123;name&#125;!`;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>myTag</code> 就是一个模板标签函数，它接收两个参数：<code>strings</code> 和 <code>values</code>。其中，<code>strings</code> 是一个数组，包含了模板字符串中的所有字符串；<code>values</code> 是一个数组，包含了模板字符串中所有的变量。可以根据需要对这些字符串和变量进行处理，最后返回一个处理后的结果。</p><p>使用模板标签函数可以实现一些特定的功能，例如格式化日期、国际化等。例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>let <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(values[<span class="hljs-number">0</span>]);<br>let <span class="hljs-built_in">year</span> = <span class="hljs-built_in">date</span>.getFullYear();<br>let <span class="hljs-built_in">month</span> = <span class="hljs-built_in">date</span>.getMonth() + <span class="hljs-number">1</span>;<br>let <span class="hljs-built_in">day</span> = <span class="hljs-built_in">date</span>.getDate();<br><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">year</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">month</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">day</span>&#125;</span>`</span>;<br>&#125;<br><br>let str = formatTime<span class="hljs-string">`The date is <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>()&#125;</span>`</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str); <span class="hljs-comment">// 输出：The date is 2023-5-10</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>formatTime</code> 是一个模板标签函数，它接收一个时间戳作为参数，将其转换成指定格式的日期字符串。使用模板标签函数可以实现一些常规的字符串处理操作，同时也可以扩展 JavaScript 的语法和功能。</p></blockquote><h3 id="60-如何使用标签模板？"><a href="#60-如何使用标签模板？" class="headerlink" title="60.如何使用标签模板？"></a>60.如何使用标签模板？</h3><h3 id="61-什么是迭代器？"><a href="#61-什么是迭代器？" class="headerlink" title="61.什么是迭代器？"></a>61.什么是迭代器？</h3><h3 id="62-如何使用迭代器？"><a href="#62-如何使用迭代器？" class="headerlink" title="62.如何使用迭代器？"></a>62.如何使用迭代器？</h3><h3 id="63-什么是生成器？"><a href="#63-什么是生成器？" class="headerlink" title="63.什么是生成器？"></a>63.什么是生成器？</h3><h3 id="64-如何使用生成器？"><a href="#64-如何使用生成器？" class="headerlink" title="64.如何使用生成器？"></a>64.如何使用生成器？</h3><h3 id="65-什么是可迭代对象？"><a href="#65-什么是可迭代对象？" class="headerlink" title="65.什么是可迭代对象？"></a>65.什么是可迭代对象？</h3><h3 id="66-如何创建可迭代对象？"><a href="#66-如何创建可迭代对象？" class="headerlink" title="66.如何创建可迭代对象？"></a>66.如何创建可迭代对象？</h3><h3 id="67-如何使用可迭代对象？"><a href="#67-如何使用可迭代对象？" class="headerlink" title="67.如何使用可迭代对象？"></a>67.如何使用可迭代对象？</h3><h3 id="68-什么是Promise-all？"><a href="#68-什么是Promise-all？" class="headerlink" title="68.什么是Promise.all？"></a>68.什么是Promise.all？</h3><h3 id="69-如何使用Promise-all？"><a href="#69-如何使用Promise-all？" class="headerlink" title="69.如何使用Promise.all？"></a>69.如何使用Promise.all？</h3><h3 id="70-什么是Promise-race？"><a href="#70-什么是Promise-race？" class="headerlink" title="70.什么是Promise.race？"></a>70.什么是Promise.race？</h3><h3 id="71-如何使用Promise-race？"><a href="#71-如何使用Promise-race？" class="headerlink" title="71.如何使用Promise.race？"></a>71.如何使用Promise.race？</h3><h3 id="72-什么是Symbol？"><a href="#72-什么是Symbol？" class="headerlink" title="72.什么是Symbol？"></a>72.什么是Symbol？</h3><h3 id="73-如何使用Symbol？"><a href="#73-如何使用Symbol？" class="headerlink" title="73.如何使用Symbol？"></a>73.如何使用Symbol？</h3><h3 id="74-什么是Proxy？"><a href="#74-什么是Proxy？" class="headerlink" title="74.什么是Proxy？"></a>74.什么是Proxy？</h3><h3 id="75-如何使用Proxy？"><a href="#75-如何使用Proxy？" class="headerlink" title="75.如何使用Proxy？"></a>75.如何使用Proxy？</h3><h3 id="76-什么是Reflect？"><a href="#76-什么是Reflect？" class="headerlink" title="76.什么是Reflect？"></a>76.什么是Reflect？</h3><h3 id="77-如何使用Reflect？"><a href="#77-如何使用Reflect？" class="headerlink" title="77.如何使用Reflect？"></a>77.如何使用Reflect？</h3><h3 id="78-什么是尾调用优化？"><a href="#78-什么是尾调用优化？" class="headerlink" title="78.什么是尾调用优化？"></a>78.什么是尾调用优化？</h3><h3 id="79-如何实现尾调用优化？"><a href="#79-如何实现尾调用优化？" class="headerlink" title="79.如何实现尾调用优化？"></a>79.如何实现尾调用优化？</h3><h3 id="80-如何禁用尾调用优化？"><a href="#80-如何禁用尾调用优化？" class="headerlink" title="80.如何禁用尾调用优化？"></a>80.如何禁用尾调用优化？</h3><h3 id="81-什么是柯里化？"><a href="#81-什么是柯里化？" class="headerlink" title="81.什么是柯里化？"></a>81.什么是柯里化？</h3><h3 id="82-如何实现柯里化？"><a href="#82-如何实现柯里化？" class="headerlink" title="82.如何实现柯里化？"></a>82.如何实现柯里化？</h3><h3 id="83-什么是函数组合？"><a href="#83-什么是函数组合？" class="headerlink" title="83.什么是函数组合？"></a>83.什么是函数组合？</h3><h3 id="84-如何实现函数组合？"><a href="#84-如何实现函数组合？" class="headerlink" title="84.如何实现函数组合？"></a>84.如何实现函数组合？</h3><h3 id="85-什么是函数式编程？"><a href="#85-什么是函数式编程？" class="headerlink" title="85.什么是函数式编程？"></a>85.什么是函数式编程？</h3><h3 id="86-如何在JavaScript中使用函数式编程？"><a href="#86-如何在JavaScript中使用函数式编程？" class="headerlink" title="86.如何在JavaScript中使用函数式编程？"></a>86.如何在JavaScript中使用函数式编程？</h3><h3 id="87-什么是纯函数？"><a href="#87-什么是纯函数？" class="headerlink" title="87.什么是纯函数？"></a>87.什么是纯函数？</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo Github 个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-winter</title>
    <link href="/2023/05/25/interview-winter/"/>
    <url>/2023/05/25/interview-winter/</url>
    
    <content type="html"><![CDATA[<h1 id="前端开发面试题"><a href="#前端开发面试题" class="headerlink" title="前端开发面试题"></a>前端开发面试题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a name="preface">前言</a></h2><p><a href="https://markyun.github.io/2015/Front-end-Developer-Questions/" title="Questions">只看问题点这里 </a></p><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" title="Questions-and-Answers">看全部问题和答案点这里</a></p><p>本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！</p><p>前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。</p><p>最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到<a href="http://markyun.github.io/">github博客</a>。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。</p><p><strong>面试有几点需注意：(来源<a href="http://weibo.com/wintercn" title="微博：寒冬winter">寒冬winter</a> 老师，github:@wintercn)</strong></p><p><img src="/2023/05/25/interview-winter/057.jpg"></p><ol><li><p>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</p></li><li><p>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</p></li><li><p>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</p></li><li><p>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )）</p></li><li><p>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</p></li></ol><p><strong>前端开发所需掌握知识点概要：</strong></p><pre><code class="hljs">HTML&amp;CSS：    对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、    Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）；JavaScript：    数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、    内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、其他：    主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、    重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；</code></pre><p>作为一名前端工程师，<strong>无论工作年头长短都应该掌握的知识点</strong>：</p><p>此条由 王子墨 发表在 <a href="http://lab.yuanwai.wang/">攻城师的实验室</a></p><pre><code class="hljs">    1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。    2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。    3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。    4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。    5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。    6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型    7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们    8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。    9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。    10、JSON —— 作用、用途、设计结构。</code></pre><p><strong>备注：</strong></p><pre><code class="hljs">根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。更新记录：2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；2016-10-20： 更新一些已被发现的问题。2016-03-25： 新增ECMAScript6 相关问题</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><a name="html">HTML</a></h2><ul><li><p>Doctype作用？标准模式与兼容模式各有什么区别?</p><pre><code class="hljs">  （1）、&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。    （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</code></pre></li><li><p>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>？</p><pre><code class="hljs">   HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；   而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</code></pre></li><li><p>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</p><pre><code class="hljs">  首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。    （1）行内元素有：a b span img input select strong（强调的语气）  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p    （3）常见的空元素：      &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;      鲜为人知的是：      &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;    不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异  参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</code></pre></li><li><p>页面导入样式时，使用link和@import有什么区别？</p><pre><code class="hljs">  （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;  （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;      (4)link支持使用js控制DOM去改变样式，而@import不支持;</code></pre></li><li><p>介绍一下你对浏览器内核的理解？</p><pre><code class="hljs">  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。    JS引擎则：解析和执行javascript来实现网页的动态效果。    最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</code></pre></li><li><p>常见的浏览器内核有哪些？</p><pre><code class="hljs">  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)</code></pre></li><li><p>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p><pre><code class="hljs">  * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。        绘画 canvas;        用于媒介回放的 video 和 audio 元素;        本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;        sessionStorage 的数据在浏览器关闭后自动删除;        语意化更好的内容元素，比如 article、footer、header、nav、section;        表单控件，calendar、date、time、email、url、search;        新的技术webworker, websocket, Geolocation;    移除的元素：        纯表现的元素：basefont，big，center，font, s，strike，tt，u;        对可用性产生负面影响的元素：frame，frameset，noframes；  * 支持HTML5新标签：       IE8/IE7/IE6支持通过document.createElement方法产生的标签，         可以利用这一特性让这些浏览器支持HTML5新标签，         浏览器支持新标签后，还需要添加标签默认的样式。       当然也可以直接使用成熟的框架、比如html5shim;       &lt;!--[if lt IE 9]&gt;          &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;       &lt;![endif]--&gt;  * 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</code></pre></li><li><p>简述一下你对HTML语义化的理解？</p><pre><code class="hljs">  用正确的标签做正确的事情。  html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;  即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;  搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;  使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre></li><li><p>HTML5的离线储存怎么使用，工作原理能不能解释一下？</p><pre><code class="hljs">  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。  如何使用：  1、页面头部像下面一样加入一个manifest的属性；  2、在cache.manifest文件的编写离线存储的资源；      CACHE MANIFEST      #v0.11      CACHE:      js/app.js      css/style.css      NETWORK:      resourse/logo.png      FALLBACK:      / /offline.html  3、在离线状态时，操作window.applicationCache进行需求实现。</code></pre><p>  详细的使用请参考：</p><p>  <a href="http://yanhaijing.com/html/2014/12/28/html5-manifest/">HTML5 离线缓存-manifest简介</a></p><p>  <a href="http://segmentfault.com/a/1190000000732617">有趣的HTML5：离线存储</a></p></li><li><p>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</p><pre><code class="hljs">  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。  离线的情况下，浏览器就直接使用离线存储的资源。</code></pre><p>  详细请参考：<a href="http://segmentfault.com/a/1190000000732617">有趣的HTML5：离线存储</a></p></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p><pre><code class="hljs">  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。    存储大小：      cookie数据大小不能超过4k。      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。    有期时间：      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；      sessionStorage  数据在当前浏览器窗口关闭后自动删除。      cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</code></pre></li><li><p>iframe有那些缺点？</p><pre><code class="hljs">  *iframe会阻塞主页面的Onload事件；  *搜索引擎的检索程序无法解读这种页面，不利于SEO;    *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。    使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript  动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre></li><li><p>Label的作用是什么？是怎么用的？</p><pre><code class="hljs">  label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;  &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt;    &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt;</code></pre></li><li><p>HTML5的form如何关闭自动完成功能？</p><pre><code class="hljs">  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</code></pre></li><li><p>如何实现浏览器内多个标签页之间的通信? (阿里)</p><pre><code class="hljs">  WebSocket、SharedWorker；  也可以调用localstorge、cookies等本地存储方式；    localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，  我们通过监听事件，控制它的值来进行页面信息通信；  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</code></pre></li><li><p>webSocket如何兼容低浏览器？(阿里)</p><pre><code class="hljs">  Adobe Flash Socket 、  ActiveX HTMLFile (IE) 、  基于 multipart 编码发送 XHR 、  基于长轮询的 XHR</code></pre></li><li><p>页面可见性（Page Visibility API） 可以有哪些用途？</p><pre><code class="hljs">  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</code></pre></li><li><p>如何在页面上实现一个圆形的可点击区域？</p><pre><code class="hljs">  1、map+area或者svg  2、border-radius  3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</code></pre></li><li><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p><pre><code class="hljs">  &lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>网页验证码是干嘛的，是为了解决什么安全问题。</p><pre><code class="hljs">  区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；  有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</code></pre></li><li><p>title与h1的区别、b与strong的区别、i与em的区别？</p><pre><code class="hljs">  title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；    strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。    i内容展示为斜体，em表示强调的文本；    Physical Style Elements -- 自然样式标签  b, i, u, s, pre  Semantic Style Elements -- 语义样式标签  strong, em, ins, del, code  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</code></pre></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><a name="css">CSS</a></h2><ul><li><p>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</p><pre><code class="hljs">  （1）有两种， IE 盒子模型、W3C 盒子模型；  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；  （3）区  别： IE的content部分把 border 和 padding计算了进去;</code></pre></li><li><p>CSS选择符有哪些？哪些属性可以继承？</p><pre><code class="hljs">  *   1.id选择器（ # myid）      2.类选择器（.myclassname）      3.标签选择器（div, h1, p）      4.相邻选择器（h1 + p）      5.子选择器（ul &gt; li）      6.后代选择器（li a）      7.通配符选择器（ * ）      8.属性选择器（a[rel = &quot;external&quot;]）      9.伪类选择器（a:hover, li:nth-child）    *   可继承的样式： font-size font-family color, UL LI DL DD DT;    *   不可继承的样式：border padding margin width height ;</code></pre></li><li><p>CSS优先级算法如何计算？</p><pre><code class="hljs">  *   优先级就近原则，同权重情况下样式定义最近者为准;  *   载入样式以最后载入的定位为准;    优先级为:      同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。      !important &gt;  id &gt; class &gt; tag      important 比 内联优先级高</code></pre></li><li><p>CSS3新增伪类有那些？</p><pre><code class="hljs">      举例：      p:first-of-type选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:last-of-type选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-of-type选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。      p:only-child选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。      p:nth-child(2)选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。        ::after在元素之前添加内容,也可以用来做清除浮动。      ::before在元素之后添加内容      :enabled        :disabled 控制表单控件的禁用状态。      :checked        单选框或复选框被选中。</code></pre></li><li><p>如何居中div？</p><ul><li><p>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</p><pre><code class="hljs"> div&#123;     width:200px;     margin:0 auto;  &#125;</code></pre></li><li><p>让绝对定位的div居中</p><pre><code class="hljs"> div &#123;     position: absolute;     width: 300px;     height: 300px;     margin: auto;     top: 0;     left: 0;     bottom: 0;     right: 0;     background-color: pink;/* 方便看效果 */ &#125;</code></pre></li><li><p>水平垂直居中一</p><pre><code class="hljs"> 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div &#123;     position: relative;/* 相对定位或绝对定位均可 */     width:500px;     height:300px;     top: 50%;     left: 50%;     margin: -150px 0 0 -250px;     /* 外边距为自身宽高的一半 */     background-color: pink; /* 方便看效果 */  &#125;</code></pre></li><li><p>水平垂直居中二</p><pre><code class="hljs"> 未知容器的宽高，利用 `transform` 属性 div &#123;     position: absolute;/* 相对定位或绝对定位均可 */     width:500px;     height:300px;     top: 50%;     left: 50%;     transform: translate(-50%, -50%);     background-color: pink; /* 方便看效果 */ &#125;</code></pre></li><li><p>水平垂直居中三</p><pre><code class="hljs"> 利用 flex 布局 实际使用时应考虑兼容性 .container &#123;     display: flex;     align-items: center; /* 垂直居中 */     justify-content: center;/* 水平居中 */ &#125; .container div &#123;     width: 100px;     height: 100px;     background-color: pink;/* 方便看效果 */ &#125;</code></pre></li></ul></li><li><p>display有哪些值？说明他们的作用。</p><pre><code class="hljs">    block       块类型。默认宽度为父元素宽度，可设置宽高，换行显示。    none        元素不显示，并从文档流中移除。    inline      行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。    inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。    list-item   象块类型元素一样显示，并添加样式列表标记。    table       此元素会作为块级表格来显示。    inherit     规定应该从父元素继承 display 属性的值。</code></pre></li><li><p>position的值relative和absolute定位原点是？</p><pre><code class="hljs">    absolute      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。    fixed （老IE不支持）      生成绝对定位的元素，相对于浏览器窗口进行定位。    relative      生成相对定位的元素，相对于其正常位置进行定位。    static      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。    inherit      规定从父元素继承 position 属性的值。</code></pre></li><li><p>CSS3有哪些新特性？</p><pre><code class="hljs">    新增各种CSS选择器（: not(.input)：所有 class 不是“input”的节点）        圆角    （border-radius:8px）    多列布局    （multi-column layout）    阴影和反射（Shadow\Reflect）    文字特效（text-shadow、）    文字渲染（Text-decoration）    线性渐变（gradient）    旋转 （transform）    缩放,定位,倾斜,动画,多背景    例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></pre></li><li><p>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</p><pre><code class="hljs">   一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。   采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。   在布局上有了比以前更加灵活的空间。   具体：http://www.w3cplus.com/css3/flexbox-basics.html</code></pre></li><li><p>用纯CSS创建一个三角形的原理是什么？</p><pre><code class="hljs">  把上、左、右三条边隐藏掉（颜色设为 transparent）  #demo &#123;    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;  &#125;</code></pre></li><li><p>一个满屏 品 字布局 如何设计?</p><pre><code class="hljs">  简单的方式：      上面的div宽100%，      下面的两个div分别宽50%，      然后用float或者inline使其不换行即可</code></pre></li><li><p>css多列等高如何实现？</p><pre><code class="hljs">  利用padding-bottom|margin-bottom正负值相抵；  设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，  当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，  其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</code></pre></li><li><p>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</p><pre><code class="hljs">  * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.    * 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。    * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。      浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125;      这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)      渐进识别的方式，从总体中逐渐排除局部。      首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。      css        .bb&#123;            background-color:red;/*所有识别*/            background-color:#00deff\9; /*IE6、7、8识别*/            +background-color:#a200ff;/*IE6、7识别*/            _background-color:#1e0bd1;/*IE6识别*/        &#125;  *  IE下,可以使用获取常规属性的方法来获取自定义属性,     也可以使用getAttribute()获取自定义属性;     Firefox下,只能使用getAttribute()获取自定义属性。     解决方法:统一通过getAttribute()获取自定义属性。  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;     Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。  超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:  L-V-H-A :  a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125;</code></pre></li><li><p>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p><pre><code class="hljs">  行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</code></pre></li><li><p>为什么要初始化CSS样式。</p><pre><code class="hljs">  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。    - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。    最简单的初始化方法： * &#123;padding: 0; margin: 0;&#125; （强烈不建议）    淘宝的样式初始化代码：  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;  body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;  h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;  address, cite, dfn, em, var &#123; font-style:normal; &#125;  code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;  small&#123; font-size:12px; &#125;  ul, ol &#123; list-style:none; &#125;  a &#123; text-decoration:none; &#125;  a:hover &#123; text-decoration:underline; &#125;  sup &#123; vertical-align:text-top; &#125;  sub&#123; vertical-align:text-bottom; &#125;  legend &#123; color:#000; &#125;  fieldset, img &#123; border:0; &#125;  button, input, select, textarea &#123; font-size:100%; &#125;  table &#123; border-collapse:collapse; border-spacing:0; &#125;</code></pre></li><li><p>absolute的containing block(容器块)计算方式跟正常流有什么不同？</p><pre><code class="hljs">  无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：  1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；  2、否则,则由这个祖先元素的 padding box 构成。  如果都找不到，则为 initial containing block。    补充：  1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）  2. absolute: 向上找最近的定位为absolute/relative的元素  3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</code></pre></li><li><p>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p><p>  对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.<br>  如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.<br>  仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</p></li><li><p>position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</p><p>  如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠.</p></li><li><p>对BFC规范(块级格式化上下文：block formatting context)的理解？</p><pre><code class="hljs">  （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</code></pre></li><li><p>css定义的权重</p><pre><code class="hljs">  以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：    /*权重为1*/  div&#123;  &#125;  /*权重为10*/  .class1&#123;  &#125;  /*权重为100*/  #id1&#123;  &#125;  /*权重为100+1=101*/  #id1 div&#123;  &#125;  /*权重为10+1=11*/  .class1 div&#123;  &#125;  /*权重为10+10+1=21*/  .class1 .class2 div&#123;  &#125;    如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre></li><li><p>请解释一下为什么需要清除浮动？清除浮动的方式</p><p>  清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><pre><code class="hljs">  1、父级div定义height；  2、父级div 也一起浮动；  3、常规的使用一个class；      .clearfix::before, .clearfix::after &#123;          content: &quot; &quot;;          display: table;      &#125;      .clearfix::after &#123;          clear: both;      &#125;      .clearfix &#123;          *zoom: 1;      &#125;    4、SASS编译的时候，浮动元素的父级div定义伪类:after      &amp;::after,&amp;::before&#123;          content: &quot; &quot;;          visibility: hidden;          display: block;          height: 0;          clear: both;      &#125;    解析原理：  1) display:block 使生成的元素以块级元素显示,占满剩余空间;  2) height:0 避免生成内容破坏原有布局的高度。  3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;  4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙；  5）zoom：1 触发IE hasLayout。    通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。</code></pre></li><li><p>什么是外边距合并？</p><pre><code class="hljs">  外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp</code></pre></li><li><p>zoom:1的清除浮动原理?</p><pre><code class="hljs">  清除浮动，触发hasLayout；  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。    来龙去脉大概如下：  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。    Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。    目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？  可以通过css3里面的动画属性scale进行缩放。</code></pre></li><li><p>移动端的布局用过媒体查询吗？</p><p>  假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，<br>  而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p>  <!-- link元素中的CSS媒体查询 --><p>  当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。<br>  当媒体查询返回假， <link> 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。</p>  <link rel="stylesheet" media="(max-width: 800px)" href="example.css">    <!-- 样式表中的CSS媒体查询 --><p>  包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。<br>  CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p>  <style>      @media (min-width: 700px) and (orientation: landscape){        .sidebar {          display: none;        }      }  </style></li><li><p>使用 CSS 预处理器吗？喜欢那个？</p><pre><code class="hljs">  SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)</code></pre></li><li><p>CSS优化、提高性能的方法有哪些？</p><pre><code class="hljs">  关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；  如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；  提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;  使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；</code></pre></li><li><p>浏览器是怎样解析CSS选择器的？</p><pre><code class="hljs">  样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。  只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</code></pre></li><li><p>在网页中的应该使用奇数还是偶数的字体？为什么呢？</p></li><li><p>margin和padding分别适合什么场景使用？</p><pre><code class="hljs">  margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。  margin用于布局分开元素使元素与元素互不相干；  padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</code></pre></li><li><p>抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</p></li><li><p>元素竖向的百分比设定是相对于容器的高度吗？</p></li><li><p>全屏滚动的原理是什么？用到了CSS的那些属性？</p></li><li><p>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p></li><li><p>视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</p></li><li><p>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</p><pre><code class="hljs">  单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，  比如:first-line、:first-letter、:before、:after等，  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。    想让插入的内容出现在其它内容前，使用::before，否者，使用::after；  在代码顺序上，::after生成的内容也比::before生成的内容靠后。  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</code></pre></li><li><p>如何修改chrome记住密码后自动填充表单的黄色背景 ？</p><pre><code class="hljs">  input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123;    background-color: rgb(250, 255, 189); /* #FAFFBD; */    background-image: none;    color: rgb(0, 0, 0);  &#125;</code></pre></li><li><p>你对line-height是如何理解的？</p></li><li><p>设置元素浮动后，该元素的display值是多少？</p><pre><code class="hljs">  自动变成了 display:block</code></pre></li><li><p>怎么让Chrome支持小于12px 的文字？</p><pre><code class="hljs">  1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。  2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。  3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。  4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</code></pre></li><li><p>让页面里的字体变清晰，变细用CSS怎么做？</p><pre><code class="hljs">  -webkit-font-smoothing: antialiased;</code></pre></li><li><p>font-style属性可以让它赋值为“oblique” oblique是什么意思？</p><pre><code class="hljs">  倾斜的字体样式</code></pre></li><li><p>position:fixed;在android下无效怎么处理？</p><pre><code class="hljs">  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，  原来的网页还好好的在那，fixed的内容也没有变过位置，  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</code></pre></li><li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p><pre><code class="hljs">  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</code></pre></li><li><p>display:inline-block 什么时候会显示间隙？(携程)</p><pre><code class="hljs">  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</code></pre></li><li><p>overflow: scroll时不能平滑滚动的问题怎么处理？</p></li><li><p>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。</p></li><li><p>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p></li><li><p>什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</p><pre><code class="hljs">  如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，  所以不如隔离开。    因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，  这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。    同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，  提高了webserver的http请求的解析速度。</code></pre></li><li><p>style标签写在body后与body前有什么区别？</p></li><li><p>什么是CSS 预处理器 &#x2F; 后处理器？</p><pre><code class="hljs">  - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。    - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</code></pre></li><li><p>rem布局的优缺点</p></li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a name="js">JavaScript</a></h2><ul><li><p>介绍js的基本数据类型。</p><pre><code class="hljs">  Undefined、Null、Boolean、Number、String、  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</code></pre></li><li><p>介绍js有哪些内置对象？</p><pre><code class="hljs"> Object 是 JavaScript 中所有对象的父对象  数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error  参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html</code></pre></li><li><p>说几条写JavaScript的基本规范？</p><pre><code class="hljs"> 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre></li><li><p>JavaScript原型，原型链 ? 有什么特点？</p><pre><code class="hljs"> 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.__proto__  特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。  当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。     function Func()&#123;&#125;     Func.prototype.name = &quot;Sean&quot;;     Func.prototype.getInfo = function() &#123;       return this.name;     &#125;     var person = new Func();//现在可以参考var person = Object.create(oldObject);     console.log(person.getInfo());//它拥有了Func的属性和方法     //&quot;Sean&quot;     console.log(Func.prototype);     // Func &#123; name=&quot;Sean&quot;, getInfo=function()&#125;</code></pre></li><li><p>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</p><pre><code class="hljs"> 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数）  两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</code></pre><p> <img src="http://www.w3school.com.cn/i/ct_js_value.gif" alt="Stated Clearly Image"></p></li><li><p>如何将字符串转化为数字，例如’12.3b’?</p><pre><code class="hljs">  * parseFloat(&#39;12.3b&#39;);  * 正则表达式，&#39;12.3b&#39;.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</code></pre></li><li><p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p><pre><code class="hljs">  function commafy(num)&#123;      return num &amp;&amp; num          .toString()          .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123;              return $2 + &#39;,&#39;;          &#125;);  &#125;</code></pre></li><li><p>如何实现数组的随机排序？</p><pre><code class="hljs">  方法一：      var arr = [1,2,3,4,5,6,7,8,9,10];      function randSort1(arr)&#123;          for(var i = 0,len = arr.length;i &lt; len; i++ )&#123;              var rand = parseInt(Math.random()*len);              var temp = arr[rand];              arr[rand] = arr[i];              arr[i] = temp;          &#125;          return arr;      &#125;      console.log(randSort1(arr));        方法二：      var arr = [1,2,3,4,5,6,7,8,9,10];      function randSort2(arr)&#123;          var mixedArray = [];          while(arr.length &gt; 0)&#123;              var randomIndex = parseInt(Math.random()*arr.length);              mixedArray.push(arr[randomIndex]);              arr.splice(randomIndex, 1);          &#125;          return mixedArray;      &#125;      console.log(randSort2(arr));    方法三：      var arr = [1,2,3,4,5,6,7,8,9,10];      arr.sort(function()&#123;          return Math.random() - 0.5;      &#125;)      console.log(arr);</code></pre></li><li><p>Javascript如何实现继承？</p><pre><code class="hljs"> 1、构造继承 2、原型继承 3、实例继承 4、拷贝继承  原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。      function Parent()&#123;         this.name = &#39;wang&#39;;     &#125;      function Child()&#123;         this.age = 28;     &#125;     Child.prototype = new Parent();//继承了Parent，通过原型      var demo = new Child();     alert(demo.age);     alert(demo.name);//得到被继承的属性</code></pre></li><li><p>JavaScript继承的几种实现方式？</p><ul><li>参考：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">构造函数的继承</a>，<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">非构造函数的继承</a>；</li></ul></li><li><p>javascript创建对象的几种方式？</p><pre><code class="hljs"> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式     person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;; 2、用function来模拟无参的构造函数     function Person()&#123;&#125;     var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class     person.name=&quot;Mark&quot;;     person.age=&quot;25&quot;;     person.work=function()&#123;     alert(person.name+&quot; hello...&quot;);     &#125;     person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）     function Pet(name,age,hobby)&#123;        this.name=name;//this作用域：当前对象        this.age=age;        this.hobby=hobby;        this.eat=function()&#123;           alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);        &#125;     &#125;     var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象     maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象）      var wcDog =new Object();      wcDog.name=&quot;旺财&quot;;      wcDog.age=3;      wcDog.work=function()&#123;        alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);      &#125;      wcDog.work(); 5、用原型方式来创建     function Dog()&#123;      &#125;      Dog.prototype.name=&quot;旺财&quot;;      Dog.prototype.eat=function()&#123;      alert(this.name+&quot;是个吃货&quot;);      &#125;      var wangcai =new Dog();      wangcai.eat(); 5、用混合方式来创建     function Car(name,price)&#123;       this.name=name;       this.price=price;     &#125;      Car.prototype.sell=function()&#123;        alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);       &#125;     var camry =new Car(&quot;凯美瑞&quot;,27);     camry.sell();</code></pre></li><li><p>Javascript作用链域?</p><pre><code class="hljs"> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。</code></pre></li><li><p>谈谈This对象的理解。</p> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">   <span class="hljs-built_in">this</span>总是指向函数的直接调用者（而非间接调用者）；<br>如果有<span class="hljs-keyword">new</span><span class="hljs-type"></span>关键字，<span class="hljs-built_in">this</span>指向<span class="hljs-keyword">new</span><span class="hljs-type"></span>出来的那个对象；<br>在事件中，<span class="hljs-built_in">this</span>指向触发这个事件的对象，特殊的是，IE中的attachEvent中的<span class="hljs-built_in">this</span>总是指向全局对象Window；<br></code></pre></td></tr></table></figure></li><li><p>eval是做什么的？</p><pre><code class="hljs"> 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);</code></pre></li><li><p>什么是window对象? 什么是document对象?</p><pre><code class="hljs"> window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</code></pre></li><li><p>null，undefined 的区别？</p><pre><code class="hljs"> null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)；  undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined     //&quot;undefined&quot;     undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；     例如变量被声明了，但没有赋值时，就等于undefined typeof null     //&quot;object&quot;     null : 是一个对象(空对象, 没有任何属性和方法)；     例如作为函数的参数，表示该函数的参数不是对象； 注意：     在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined     null == undefined // true     null === undefined // false 再来一个例子：     null     Q：有张三这个人么？     A：有！     Q：张三有房子么？     A：没有！     undefined     Q：有张三这个人么？     A：有！     Q: 张三有多少岁？     A: 不知道（没有被告诉）</code></pre><p> 参考阅读：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">undefined与null的区别</a></p></li><li><p>写一个通用的事件侦听器函数。</p><pre><code class="hljs">     // event(事件)工具集，来源：github.com/markyun     markyun.Event = &#123;         // 页面加载完成后         readyEvent : function(fn) &#123;             if (fn==null) &#123;                 fn=document;             &#125;             var oldonload = window.onload;             if (typeof window.onload != &#39;function&#39;) &#123;                 window.onload = fn;             &#125; else &#123;                 window.onload = function() &#123;                     oldonload();                     fn();                 &#125;;             &#125;         &#125;,         // 视能力分别使用dom0||dom2||IE方式 来绑定事件         // 参数： 操作的元素,事件名称 ,事件处理程序         addEvent : function(element, type, handler) &#123;             if (element.addEventListener) &#123;                 //事件类型、需要执行的函数、是否捕捉                 element.addEventListener(type, handler, false);             &#125; else if (element.attachEvent) &#123;                 element.attachEvent(&#39;on&#39; + type, function() &#123;                     handler.call(element);                 &#125;);             &#125; else &#123;                 element[&#39;on&#39; + type] = handler;             &#125;         &#125;,         // 移除事件         removeEvent : function(element, type, handler) &#123;             if (element.removeEventListener) &#123;                 element.removeEventListener(type, handler, false);             &#125; else if (element.datachEvent) &#123;                 element.detachEvent(&#39;on&#39; + type, handler);             &#125; else &#123;                 element[&#39;on&#39; + type] = null;             &#125;         &#125;,         // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)         stopPropagation : function(ev) &#123;             if (ev.stopPropagation) &#123;                 ev.stopPropagation();             &#125; else &#123;                 ev.cancelBubble = true;             &#125;         &#125;,         // 取消事件的默认行为         preventDefault : function(event) &#123;             if (event.preventDefault) &#123;                 event.preventDefault();             &#125; else &#123;                 event.returnValue = false;             &#125;         &#125;,         // 获取事件目标         getTarget : function(event) &#123;             return event.target || event.srcElement;         &#125;,         // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；         getEvent : function(e) &#123;             var ev = e || window.event;             if (!ev) &#123;                 var c = this.getEvent.caller;                 while (c) &#123;                     ev = c.arguments[0];                     if (ev &amp;&amp; Event == ev.constructor) &#123;                         break;                     &#125;                     c = c.caller;                 &#125;             &#125;             return ev;         &#125;     &#125;;</code></pre></li><li><p>[“1”, “2”, “3”].map(parseInt) 答案是多少？</p><pre><code class="hljs"> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)， 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】; 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。  function parseInt(str, radix) &#123;     return str+&#39;-&#39;+radix; &#125;; var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; a.map(parseInt);  // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix  因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN]  详细解析：http://blog.csdn.net/justjavac/article/details/19473199</code></pre></li><li><p>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</p><pre><code class="hljs">  1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。  2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；  3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</code></pre></li><li><p>什么是闭包（closure），为什么要用它？</p><pre><code class="hljs"> 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。  闭包的特性：  1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收  //li节点的onclick事件都能正确的弹出当前被点击的li索引  &lt;ul id=&quot;testUL&quot;&gt;     &lt;li&gt; index = 0&lt;/li&gt;     &lt;li&gt; index = 1&lt;/li&gt;     &lt;li&gt; index = 2&lt;/li&gt;     &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt;       var nodes = document.getElementsByTagName(&quot;li&quot;);     for(i = 0;i&lt;nodes.length;i+= 1)&#123;         nodes[i].onclick = (function(i)&#123;                   return function() &#123;                      console.log(i);                   &#125; //不用闭包的话，值每次都是4                 &#125;)(i);     &#125; &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在 使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源 因为say667()的内部函数的执行需要依赖say667()中的变量 这是对闭包作用的非常直白的描述   function say667() &#123;     // Local variable that ends up within closure     var num = 666;     var sayAlert = function() &#123;         alert(num);     &#125;     num++;     return sayAlert; &#125;  var sayAlert = say667();  sayAlert()//执行结果应该弹出的667</code></pre></li><li><p>javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</p><pre><code class="hljs"> use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,  使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;  提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。</code></pre></li><li><p>如何判断一个对象是否属于某个类？</p><pre><code class="hljs">    使用instanceof （待完善）     if(a instanceof Person)&#123;         alert(&#39;yes&#39;);     &#125;</code></pre></li><li><p>new操作符具体干了什么呢?</p><pre><code class="hljs">      1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。      2、属性和方法被加入到 this 引用的对象中。       3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj  = &#123;&#125;; obj.__proto__ = Base.prototype; Base.call(obj);</code></pre></li><li><p>用原生JavaScript的实现过什么功能吗？</p></li><li><p>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p><pre><code class="hljs"> hasOwnProperty  javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。  如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</code></pre></li><li><p>JSON 的了解？</p><pre><code class="hljs"> JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 如：&#123;&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;&#125;  JSON字符串转换为JSON对象: var obj =eval(&#39;(&#39;+ str +&#39;)&#39;); var obj = str.parseJSON(); var obj = JSON.parse(str);  JSON对象转换为JSON字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj);</code></pre></li><li><p><code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</p></li><li><p>js延迟加载的方式有哪些？</p><pre><code class="hljs"> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</code></pre></li><li><p>Ajax 是什么? 如何创建一个Ajax？</p><pre><code class="hljs"> ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。  (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新</code></pre></li><li><p>Ajax 解决浏览器缓存问题？</p><pre><code class="hljs">  1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。  2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。  3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。    4、在URL后面加上时间戳：&quot;nowtime=&quot; + new Date().getTime();。    5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup(&#123;cache:false&#125;)。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。</code></pre></li><li><p>同步和异步的区别?</p><p> 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.</p><p> 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</p><p> 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p><p> （待完善）</p></li><li><p>如何解决跨域问题?</p><pre><code class="hljs"> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</code></pre></li><li><p>页面编码和被请求的资源编码如果不一致如何处理？</p></li><li><p>服务器代理转发时，该如何处理cookie？</p><pre><code class="hljs"> nginx</code></pre></li><li><p>模块化开发怎么做？</p><p>  <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/"> 立即执行函数</a>,不暴露私有成员</p><pre><code class="hljs">     var module1 = (function()&#123;     　　　　var _count = 0;     　　　　var m1 = function()&#123;     　　　　　　//...     　　　　&#125;;     　　　　var m2 = function()&#123;     　　　　　　//...     　　　　&#125;;     　　　　return &#123;     　　　　　　m1 : m1,     　　　　　　m2 : m2     　　　　&#125;;     　　&#125;)();</code></pre><p> （待完善）</p></li><li><p>AMD（Modules&#x2F;Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</p><blockquote><p>AMD 规范在这里：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">https://github.com/amdjs/amdjs-api/wiki/AMD</a></p></blockquote><blockquote><p>CMD 规范在这里：<a href="https://github.com/seajs/seajs/issues/242">https://github.com/seajs/seajs/issues/242</a></p></blockquote><pre><code class="hljs"> Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。   区别：      1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：  // CMD define(function(require, exports, module) &#123;     var a = require(&#39;./a&#39;)     a.doSomething()     // 此处略去 100 行     var b = require(&#39;./b&#39;) // 依赖可以就近书写     b.doSomething()     // ... &#125;)  // AMD 默认推荐 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) &#123; // 依赖必须一开始就写好     a.doSomething()     // 此处略去 100 行     b.doSomething()     // ... &#125;)</code></pre></li><li><p>requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何<br>缓存的？）</p><pre><code class="hljs"> 参考：http://annn.me/how-to-realize-cmd-loader/</code></pre></li><li><p>JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</p></li><li><p>谈一谈你对ECMAScript6的了解？</p></li><li><p>ECMAScript6 怎么写class么，为什么会出现class这种东西?</p></li><li><p>异步加载JS的方式有哪些？</p><pre><code class="hljs">   (1) defer，只支持IE        (2) async：        (3) 创建script，插入到DOM中，加载完毕后callBack</code></pre></li><li><p>documen.write和 innerHTML的区别</p><pre><code class="hljs">  document.write只能重绘整个页面    innerHTML可以重绘页面的一部分</code></pre></li><li><p>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p><pre><code class="hljs">  （1）创建新节点    createDocumentFragment()    //创建一个DOM片段    createElement()   //创建一个具体的元素    createTextNode()   //创建一个文本节点  （2）添加、移除、替换、插入    appendChild()    removeChild()    replaceChild()    insertBefore() //在已有的子节点前插入一个新的子节点  （3）查找    getElementsByTagName()    //通过标签名称    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)    getElementById()    //通过元素Id，唯一性</code></pre></li><li><p>.call() 和 .apply() 的区别？</p><pre><code class="hljs">   例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);   注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。     function add(a,b)     &#123;         alert(a+b);     &#125;     function sub(a,b)     &#123;         alert(a-b);     &#125;     add.call(sub,3,1);</code></pre></li><li><p>数组和对象有哪些原生方法，列举一下？</p></li><li><p>JS 怎么实现一个类。怎么实例化这个类</p></li><li><p>JavaScript中的作用域与变量声明提升？</p></li><li><p>如何编写高性能的Javascript？</p></li><li><p>那些操作会造成内存泄漏？</p></li><li><p>JQuery的源码看过吗？能不能简单概况一下它的实现原理？</p></li><li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p></li><li><p>jquery中如何将数组转化为json字符串，然后再转化回来？</p></li><li><p>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</p></li><li><p>jquery.extend 与 jquery.fn.extend的区别？</p><pre><code class="hljs"> * jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 * jquery.fn.extend:     源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</code></pre></li><li><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p></li><li><p>谈一下Jquery中的bind(),live(),delegate(),on()的区别？</p></li><li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p></li><li><p>是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？</p></li><li><p>jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）</p></li><li><p>针对 jQuery性能的优化方法？</p></li><li><p>Jquery与jQuery UI 有啥区别？</p><pre><code class="hljs"> *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。  提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</code></pre></li><li><p>JQuery的源码看过吗？能不能简单说一下它的实现原理？</p></li><li><p>jquery 中如何将数组转化为json字符串，然后再转化回来？</p></li></ul><p>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</p><pre><code class="hljs">    $.fn.stringifyArray = function(array) &#123;        return JSON.stringify(array)    &#125;    $.fn.parseArray = function(array) &#123;        return JSON.parse(array)    &#125;    然后调用：    $(&quot;&quot;).stringifyArray(array)</code></pre><ul><li><p>jQuery和Zepto的区别？各自的使用场景？</p></li><li><p>针对 jQuery 的优化方法？</p><pre><code class="hljs"> *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。  比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); *for (var i = size; i &lt; arr.length; i++) &#123;&#125;  for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：  for (var i = size, length = arr.length; i &lt; length; i++) &#123;&#125;</code></pre></li><li><p>Zepto的点透问题如何解决？</p></li><li><p>jQueryUI如何自定义组件?</p></li><li><p>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</p></li><li><p>如何判断当前脚本运行在浏览器还是node环境中？（阿里）</p><pre><code class="hljs">  this === window ? &#39;browser&#39; : &#39;node&#39;;    通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</code></pre></li><li><p>移动端最小触控区域是多大？</p></li><li><p>jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</p><pre><code class="hljs"> jquery stop(): 如：$(&quot;#div&quot;).stop().animate(&#123;width:&quot;100px&quot;&#125;,100);</code></pre></li><li><p>把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</p></li><li><p>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）</p></li><li><p>知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?</p></li><li><p>Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？</p></li><li><p>解释JavaScript中的作用域与变量声明提升？</p></li><li><p>那些操作会造成内存泄漏？</p><pre><code class="hljs"> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。  setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</code></pre></li><li><p>JQuery一个对象可以同时绑定多个事件，这是如何实现的？</p><pre><code class="hljs"> * 多个事件同一个函数：     $(&quot;div&quot;).on(&quot;click mouseover&quot;, function()&#123;&#125;); * 多个事件不同函数     $(&quot;div&quot;).on(&#123;         click: function()&#123;&#125;,         mouseover: function()&#123;&#125;     &#125;);</code></pre></li><li><p>Node.js的适用场景？</p></li><li><p>(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?</p></li><li><p>解释一下 Backbone 的 MVC 实现方式？</p></li><li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p></li><li><p>知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?</p><pre><code class="hljs">  Chrome,Safari浏览器内核。</code></pre></li><li><p>如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?</p></li><li><p>前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</p></li><li><p>简述一下 Handlebars 的基本用法？</p></li><li><p>简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？</p></li><li><p>用js实现千位分隔符?(来源：<a href="http://div.io/topic/744">前端农民工</a>，提示：正则+replace)</p><pre><code class="hljs">  参考：http://www.tuicool.com/articles/ArQZfui  function commafy(num) &#123;      return num &amp;&amp; num          .toString()          .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123;              return $1 + &quot;,&quot;;          &#125;);  &#125;  console.log(commafy(1234567.90)); //1,234,567.90</code></pre></li><li><p>检测浏览器版本版本有哪些方式？</p><pre><code class="hljs">  功能检测、userAgent特征检测    比如：navigator.userAgent  //&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36    (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot;</code></pre></li><li><p>What is a Polyfill?</p><pre><code class="hljs">  polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。  例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，  所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，  一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</code></pre></li><li><p>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？</p><pre><code class="hljs">  比如： html5shiv、Geolocation、Placeholder</code></pre></li><li><p>我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？</p></li><li><p>使用JS实现获取文件扩展名？</p><pre><code class="hljs">  function getFileExtension(filename) &#123;    return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);  &#125;    String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。  对于&#39;filename&#39;和&#39;.hiddenfile&#39;，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。  String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</code></pre></li><li><p>Webpack热更新实现原理?</p><pre><code class="hljs">  1. Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)  2. 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端  3. 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash  4. 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端  5. 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档  6. hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</code></pre></li><li><p>请介绍一下JS之事件节流？</p></li><li><p>什么是JS的函数防抖？</p></li></ul><h4 id="ECMAScript6-相关"><a href="#ECMAScript6-相关" class="headerlink" title="ECMAScript6 相关"></a><a name="other">ECMAScript6 相关</a></h4><ul><li><p>Object.is() 与原来的比较操作符“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？</p><pre><code class="hljs">  两等号判等，会在比较时进行类型转换；  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；    Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，  但 Object.is(NaN, NaN) 会返回 true.   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre></li><li><p>ES6是如何实现编译成ES5的？</p></li><li><p>css-loader的原理？</p></li></ul><h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a><a name="other">前端框架</a></h2><ul><li><p>React 使用场景？</p><pre><code class="hljs">      逻辑复杂单页应用，偏中后台管理系统，纯展示性的UI页面不合适、</code></pre></li><li><p>描述一下React 生命周期</p><pre><code class="hljs">      渲染过程调用到的生命周期函数，主要几个要知道；      * constructor       * getInitialState       * getDefaultProps       * componentWillMount       * render       * componentDidMount       更新过程      * componentWillReceiveProps       * shouldComponentUpdate       * componentWillUpdate       * render       * componentDidUpdate       卸载过程      componentWillUnmount</code></pre></li><li><p>实现组件有哪些方式？</p><pre><code class="hljs">  React.createClass 使用API来定义组件  React ES6 class component 用 ES6 的class 来定义组件  Functional stateless component 通过函数定义无状态组件</code></pre></li><li><p>应该在React生命周期的什么阶段发出ajax请求，为什么？</p><pre><code class="hljs">          AJAX请求应在 componentDidMount函数 进行请求。</code></pre></li><li><p>shouldComponentUpdate函数有什么作用？</p><pre><code class="hljs">          shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI，          如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。 让shouldComponentUpdate返回falss, React就会让当前的组件和其子组件保持不变。</code></pre></li><li><p>当组件的setState函数被调用之后，发生了什么？</p><pre><code class="hljs">          React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，          尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，          React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，          并且知道如何只通过必要的更新来最小化重渲染。</code></pre></li><li><p>为什么循环产生的组件中要利用上key这个特殊的prop？</p><pre><code class="hljs">          Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。</code></pre></li><li><p>React-router 路由的实现原理？</p></li><li><p>说说React Native,Weex框架的实现原理？</p></li><li><p>受控组件(Controlled Component)与非受控组件(Uncontrolled Component)的区别</p></li><li><p>refs 是什么?</p><pre><code class="hljs">      Refs是能访问DOM元素或组件实例的一个函数；</code></pre></li><li><p>React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？</p></li><li><p>什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？</p><pre><code class="hljs">      组件用到了state或者用了生命周期函数，那么就该使用Class component。其他情况下，应使用Functional component。</code></pre></li><li><p>什么是HoC（Higher-Order Component）？适用于什么场景？</p><pre><code class="hljs">      高阶组件就是一个 React 组件包裹着另外一个 React 组件</code></pre></li><li><p>并不是父子关系的组件，如何实现相互的数据通信？</p><p>  ​​使用父组件，通过props将变量传入子组件 （如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件 ）</p></li><li><p>用过 React 技术栈中哪些数据流管理库？</p><pre><code class="hljs">      Redux\Dva</code></pre></li><li><p>Redux是如何做到可预测呢？</p></li><li><p>Redux将React组件划分为哪两种？</p></li><li><p>Redux是如何将state注入到React组件上的？</p></li><li><p>请描述一次完整的 Redux 数据流</p></li><li><p>React的批量更新机制 BatchUpdates？</p></li><li><p>React与Vue，各自的组件更新进行对比，它们有哪些区别？</p></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><a name="other">其他问题</a></h2><ul><li><p>原来公司工作流程是怎么样的，如何与其他人协作的？如何跨部门合作的？</p></li><li><p>你遇到过比较难的技术问题是？你是如何解决的？</p></li><li><p>设计模式 知道什么是singleton, factory, strategy, decrator么?</p></li><li><p>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</p></li><li><p>页面重构怎么操作？</p><pre><code class="hljs">  网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。  也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。    对于传统的网站来说重构通常是：    表格(table)布局改为DIV+CSS  使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)  对于移动平台的优化  针对于SEO进行优化  深层次的网站重构应该考虑的方面    减少代码间的耦合  让代码保持弹性  严格按规范编写代码  设计可扩展的API  代替旧有的框架、语言(如VB)  增强用户体验  通常来说对于速度的优化也包含在重构中    压缩JS、CSS、image等前端资源(通常是由服务器来解决)  程序的性能优化(如数据读写)  采用CDN来加速资源加载  对于JS DOM的优化  HTTP服务器的文件缓存</code></pre></li><li><p>列举IE与其他浏览器不一样的特性？</p><pre><code class="hljs">  1、事件不同之处：         触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；      获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；      阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；      停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；</code></pre></li><li><p>99%的网站都需要被重构是那本书上写的？</p><pre><code class="hljs">  网站重构：应用web标准进行设计（第2版）</code></pre></li><li><p>什么叫优雅降级和渐进增强？</p><pre><code class="hljs">  优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。  如：border-shadow    渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。  如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</code></pre></li><li><p>是否了解公钥加密和私钥加密。</p><pre><code class="hljs">  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</code></pre></li><li><p>WEB应用从服务器主动推送Data到客户端有那些方式？</p><pre><code class="hljs">  html5提供的Websocket  不可见的iframe  WebSocket通过Flash  XHR长时间连接  XHR Multipart Streaming  &lt;script&gt;标签的长时间连接(可跨域)</code></pre></li><li><p>对Node的优点和缺点提出了自己的看法？</p><pre><code class="hljs">  *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。  *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</code></pre></li><li><p>你有用过哪些前端性能优化的方法？</p><pre><code class="hljs">    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数      （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。      （4） 当需要设置的样式很多时设置className而不是直接操作style。      （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。      （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。      （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。      （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</code></pre></li><li><p>http状态码有那些？分别代表是什么意思？</p><pre><code class="hljs">      简单版      [          100  Continue继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息          200  OK 正常返回信息          201  Created  请求成功并且服务器创建了新的资源          202  Accepted 服务器已接受请求，但尚未处理          301  Moved Permanently  请求的网页已永久移动到新位置。          302 Found  临时性重定向。          303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。          304  Not Modified 自从上次请求后，请求的网页未修改过。            400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。          401 Unauthorized 请求未授权。          403 Forbidden  禁止访问。          404 Not Found  找不到如何与 URI 相匹配的资源。            500 Internal Server Error  最常见的服务器端错误。          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。      ]      完整版    1**(信息类)：表示接收到请求并且继续处理      100——客户必须继续发出请求      101——客户要求服务器根据请求转换HTTP协议版本      2**(响应成功)：表示动作被成功接收、理解和接受      200——表明该请求被成功地完成，所请求的资源发送回客户端      201——提示知道新文件的URL      202——接受和处理、但处理未完成      203——返回信息不确定或不完整      204——请求收到，但返回信息为空      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件      206——服务器已经完成了部分用户的GET请求      3**(重定向类)：为了完成指定的动作，必须接受进一步处理      300——请求的资源可在多处得到      301——本网页被永久性转移到另一个URL      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。      303——建议客户访问其他URL或访问方式      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用      305——请求的资源必须从服务器指定的地址得到      306——前一版本HTTP中使用的代码，现行版本中不再使用      307——申明请求的资源临时性删除      4**(客户端错误类)：请求包含错误语法或不能正确执行      400——客户端请求有语法错误，不能被服务器所理解      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用      HTTP 401.1 - 未授权：登录失败      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败      　　HTTP 401.3 - ACL 禁止访问资源      　　HTTP 401.4 - 未授权：授权被筛选器拒绝      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败      402——保留有效ChargeTo头响应      403——禁止访问，服务器收到请求，但是拒绝提供服务      HTTP 403.1 禁止访问：禁止可执行访问      　　HTTP 403.2 - 禁止访问：禁止读访问      　　HTTP 403.3 - 禁止访问：禁止写访问      　　HTTP 403.4 - 禁止访问：要求 SSL      　　HTTP 403.5 - 禁止访问：要求 SSL 128      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝      　　HTTP 403.7 - 禁止访问：要求客户证书      　　HTTP 403.8 - 禁止访问：禁止站点访问      　　HTTP 403.9 - 禁止访问：连接的用户过多      　　HTTP 403.10 - 禁止访问：配置无效      　　HTTP 403.11 - 禁止访问：密码更改      　　HTTP 403.12 - 禁止访问：映射器拒绝访问      　　HTTP 403.13 - 禁止访问：客户证书已被吊销      　　HTTP 403.15 - 禁止访问：客户访问许可过多      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL      405——用户在Request-Line字段定义的方法不允许      406——根据用户发送的Accept拖，请求资源不可访问      407——类似401，用户必须首先在代理服务器上得到授权      408——客户端没有在用户指定的饿时间内完成请求      409——对当前资源状态，请求不能完成      410——服务器上不再有此资源且无进一步的参考地址      411——服务器拒绝用户定义的Content-Length属性请求      412——一个或多个请求头字段在当前请求中错误      413——请求的资源大于服务器允许的大小      414——请求的资源URL长于服务器允许的长度      415——请求资源不支持请求项目格式      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。      5**(服务端错误类)：服务器不能正确执行一个正确的请求      HTTP 500 - 服务器遇到错误，无法完成请求      　　HTTP 500.100 - 内部服务器错误 - ASP 错误      　　HTTP 500-11 服务器关闭      　　HTTP 500-12 应用程序重新启动      　　HTTP 500-13 - 服务器太忙      　　HTTP 500-14 - 应用程序无效      　　HTTP 500-15 - 不允许请求 global.asa      　　Error 501 - 未实现    HTTP 502 - 网关错误    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</code></pre></li><li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</p><pre><code class="hljs">    注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，    而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、    到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；    详细版：      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;      4、进行HTTP协议会话，客户端发送报头(请求报头);      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。      简洁版：      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；      载入解析到的资源文件，渲染页面，完成。</code></pre></li><li><p>部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</p></li><li><p>从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?</p></li><li><p>第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？</p><pre><code class="hljs">      localStorage</code></pre></li><li><p>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</p></li><li><p>你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？</p><pre><code class="hljs">  Sublime Text 3 + 插件  Google chrome 查看页面UI、动画效果和交互功能，Firebug 兼容测试和  Node.js + webpack  Git 版本控制和Code Review</code></pre></li><li><p>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</p><pre><code class="hljs">  前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。  1、实现界面交互  2、提升用户体验  3、有了Node.js，前端可以实现服务端的一些事情  前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，  参与项目，快速高质量完成实现效果图，精确到1px；  与团队成员，UI设计，产品经理的沟通；  做好的页面结构，页面重构和用户体验；  处理hack，兼容、写出优美的代码格式；  针对服务器的优化、拥抱最新前端技术。</code></pre></li><li><p>你怎么看待Web App 、hybrid App、Native App？</p></li><li><p>你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</p></li><li><p>产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？</p><pre><code class="hljs">  非覆盖式发布，API新增而不是在原来的上面修改；  提前做好 @Deprecated的版本提示；</code></pre></li><li><p>你对加班的看法？</p><pre><code class="hljs">     加班就像借钱，原则应当是------救急不救穷</code></pre></li><li><p>平时如何管理你的项目？</p><pre><code class="hljs">  先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等；    编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；    标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；    页面进行标注（例如 页面 模块 开始和结束）；    CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；    JS 分文件夹存放 命名以该JS功能为准的英文翻译。    图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</code></pre></li><li><p>如何设计突发大规模并发架构？</p></li><li><p>当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？</p></li><li><p>说说最近最流行的一些东西吧？常去哪些网站？</p><pre><code class="hljs">      ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化</code></pre></li><li><p>知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?</p></li><li><p>移动端（Android IOS）怎么做好用户体验?</p><pre><code class="hljs">  清晰的视觉纵线、  信息的分组、极致的减法、  利用选择代替输入、  标签及文字的排布方式、  依靠明文确认密码、  合理的键盘利用、</code></pre></li><li><p>简单描述一下你做过的移动APP项目研发流程？</p></li><li><p>你在现在的团队处于什么样的角色，起到了什么明显的作用？</p></li><li><p>你认为怎样才是全端工程师（Full Stack developer）？</p></li><li><p>介绍一个你最得意的作品吧？</p></li><li><p>你有自己的技术博客吗，用了哪些技术？</p></li><li><p>对前端安全有什么看法？</p></li><li><p>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p></li><li><p>项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。</p></li><li><p>最近在学什么东西？</p></li><li><p>你的优点是什么？缺点是什么？</p></li><li><p>如何管理前端团队?</p></li><li><p>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</p></li></ul><h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a><a name="web">前端学习网站推荐</a></h2><pre><code class="hljs">1. 极客标签：     http://www.gbtags.com/2. 码农周刊：     http://weekly.manong.io/issues/3. 前端周刊：     http://www.feweekly.com/issues4. 慕课网：       http://www.imooc.com/5. div.io： http://div.io6. Hacker News： https://news.ycombinator.com/news7. InfoQ：       http://www.infoq.com/8. w3cplus：     http://www.w3cplus.com/9. Stack Overflow： http://stackoverflow.com/10.w3school：    http://www.w3school.com.cn/11.mozilla：     https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</code></pre><h2 id="文档推荐"><a href="#文档推荐" class="headerlink" title="文档推荐"></a><a name="web">文档推荐</a></h2><ol><li><p><a href="http://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" title="jQuery 基本原理">jQuery 基本原理</a></p></li><li><p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></p></li><li><p><a href="http://css.doyoe.com/">CSS参考手册</a></p></li><li><p><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程</a></p></li><li><p><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></p></li></ol><p><strong>备注：</strong></p><pre><code class="hljs">根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。在 github 项目的右上角，有三个按钮,分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰。当你选择Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了pull request、被发起了issue等情况你都会收到邮件通知。star相当于是点赞或收藏，方便以后查找。fork表示你想要补充完善这个项目的内容。更新记录：2018-01-14： 公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；2016-10-20： 更新一些已被发现的问题。2016-03-25： 新增ECMAScript6 相关问题</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2023/05/25/interview/"/>
    <url>/2023/05/25/interview/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-面试知识点总结"><a href="#JavaScript-面试知识点总结" class="headerlink" title="JavaScript 面试知识点总结"></a>JavaScript 面试知识点总结</h2><p>本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#1-%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 介绍 js 的基本数据类型。</a></li><li><a href="#2-javascript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</a></li><li><a href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li><li>(#4-内部属性-class-是什么)</li><li><a href="#5-%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">5. 介绍 js 有哪些内置对象？</a></li><li><a href="#6-undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB">6. undefined 与 undeclared 的区别？</a></li><li><a href="#7-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB">7. null 和 undefined 的区别？</a></li><li><a href="#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC">8. 如何获取安全的 undefined 值？</a></li><li><a href="#9-%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-javascript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">9. 说几条写 JavaScript 的基本规范？</a></li><li><a href="#10-javascript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">10. JavaScript 原型，原型链？ 有什么特点？</a></li><li><a href="#11-js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">11. js 获取原型的方法？</a></li><li><a href="#12-%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">12. 在 js 中不同进制数字的表示方式</a></li><li><a href="#13-js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91">13. js 中整数的安全范围是多少？</a></li><li><a href="#14-typeof-nan-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">14. typeof NaN 的结果是什么？</a></li><li><a href="#15-isnan-%E5%92%8C-numberisnan-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">15. isNaN 和 Number.isNaN 函数的区别？</a></li><li><a href="#16-array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0">16. Array 构造函数只有一个参数值时的表现？</a></li><li><a href="#17-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">17. 其他值到字符串的转换规则？</a></li><li><a href="#18-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">18. 其他值到数字值的转换规则？</a></li><li><a href="#19-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">19. 其他值到布尔类型的值的转换规则？</a></li><li><a href="#20--%E5%92%8C--%E7%9A%84-valueof-%E5%92%8C-tostring-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</a></li><li><a href="#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1">21. 什么是假值对象？</a></li><li><a href="#22--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8">22. ~ 操作符的作用？</a></li><li><a href="#23-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</a></li><li><a href="#24--%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5">24. 操作符什么时候用于字符串的拼接？</a></li><li><a href="#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">25. 什么情况下会发生布尔值的隐式强制类型转换？</a></li><li><a href="#26--%E5%92%8C--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">26. || 和 &amp;&amp; 操作符的返回值？</a></li><li><a href="#27-symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">27. Symbol 值的强制类型转换？</a></li><li><a href="#28--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">28. &#x3D;&#x3D; 操作符的强制类型转换规则？</a></li><li><a href="#29-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BE%8B%E5%A6%82-123b">29. 如何将字符串转化为数字，例如 ‘12.3b’?</a></li><li><a href="#30-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%E5%A6%821200000011%E8%BD%AC%E5%8C%96%E4%B8%BA1200000011">30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</a></li><li><a href="#31-%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">31. 常用正则表达式</a></li><li><a href="#32-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95">32. 生成随机数的各种方法？</a></li><li><a href="#33-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">33. 如何实现数组的随机排序？</a></li><li><a href="#34-javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">34. javascript 创建对象的几种方式？</a></li><li><a href="#35-javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">35. JavaScript 继承的几种实现方式？</a></li><li><a href="#36-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0">36. 寄生式组合继承的实现？</a></li><li><a href="#37-javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">37. Javascript 的作用域链？</a></li><li><a href="#38-%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">38. 谈谈 This 对象的理解。</a></li><li><a href="#39-eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">39. eval 是做什么的？</a></li><li><a href="#40-%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">40. 什么是 DOM 和 BOM？</a></li><li><a href="#41-%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0">41. 写一个通用的事件侦听器函数。</a></li><li><a href="#42-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88ie-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li><li><a href="#43-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88">43. 三种事件模型是什么？</a></li><li><a href="#44-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88">44. 事件委托是什么？</a></li><li><a href="#45-1-2-3mapparseint-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91">45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</a></li><li><a href="#46-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83">46. 什么是闭包，为什么要用它？</a></li><li><a href="#47-javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D--%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</a></li><li><a href="#48-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB">48. 如何判断一个对象是否属于某个类？</a></li><li><a href="#49-instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8">49. instanceof 的作用？</a></li><li><a href="#50-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">50. new 操作符具体干了什么呢？如何实现？</a></li><li><a href="#51-javascript%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li><li><a href="#52-%E5%AF%B9%E4%BA%8E-json-%E7%9A%84%E4%BA%86%E8%A7%A3">52. 对于 JSON 的了解？</a></li><li><a href="#53-foreachcallfunctionaastyleoutline1px-solid-mathrandom124tostring16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97">53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</a></li><li><a href="#54-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">54. js 延迟加载的方式有哪些？</a></li><li><a href="#55-ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAajax">55. Ajax 是什么? 如何创建一个 Ajax？</a></li><li><a href="#56-%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">56. 谈一谈浏览器的缓存机制？</a></li><li><a href="#57-ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">57. Ajax 解决浏览器缓存问题？</a></li><li><a href="#58-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">58. 同步和异步的区别？</a></li><li><a href="#59-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96">59. 什么是浏览器的同源政策？</a></li><li><a href="#60-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">60. 如何解决跨域问题？</a></li><li><a href="#61-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie">61. 服务器代理转发时，该如何处理 cookie？</a></li><li><a href="#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-">62. 简单谈一下 cookie ？</a></li><li><a href="#63-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A">63. 模块化开发怎么做？</a></li><li><a href="#64-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">64. js 的几种模块规范？</a></li><li><a href="#65-amd-%E5%92%8C-cmd-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB">65. AMD 和 CMD 规范的区别？</a></li><li><a href="#66-es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</a></li><li><a href="#67-requirejs-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</a></li><li><a href="#68-js-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</a></li><li><a href="#69-ecmascript6-%E6%80%8E%E4%B9%88%E5%86%99-class%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</a></li><li><a href="#70-documenwrite-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">70. documen.write 和 innerHTML 的区别？</a></li><li><a href="#71-dom-%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9">71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="#72-innerhtml-%E4%B8%8E-outerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">72. innerHTML 与 outerHTML 的区别？</a></li><li><a href="#73-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">73. .call() 和 .apply() 的区别？</a></li><li><a href="#74-javascript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">74. JavaScript 类数组对象的定义？</a></li><li><a href="#75-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B">75. 数组和对象有哪些原生方法，列举一下？</a></li><li><a href="#76-%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95">76. 数组的 fill 方法？</a></li><li><a href="#77--%E7%9A%84%E9%95%BF%E5%BA%A6">77. [,,,] 的长度？</a></li><li><a href="#78-javascript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87">78. JavaScript 中的作用域与变量声明提升？</a></li><li><a href="#79-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-javascript-">79. 如何编写高性能的 Javascript ？</a></li><li><a href="#80-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">80. 简单介绍一下 V8 引擎的垃圾回收机制</a></li><li><a href="#81-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">81. 哪些操作会造成内存泄漏？</a></li><li><a href="#82-%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</a></li><li><a href="#83-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%BF%E9%87%8C">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</a></li><li><a href="#84-%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</a></li><li><a href="#85-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li><li><a href="#86-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</a></li><li><a href="#87-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%B9%88-%E7%9F%A5%E9%81%93-bdd-tdd-unit-test-%E4%B9%88-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E4%B9%88mocha-sinon-jasmin-qunit">87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</a></li><li><a href="#88-%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">88. 检测浏览器版本版本有哪些方式？</a></li><li><a href="#89-%E4%BB%80%E4%B9%88%E6%98%AF-polyfill-">89. 什么是 Polyfill ？</a></li><li><a href="#90-%E4%BD%BF%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">90. 使用 JS 实现获取文件扩展名？</a></li><li><a href="#91-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">91. 介绍一下 js 的节流与防抖？</a></li><li><a href="#92-objectis-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6--%E7%9A%84%E5%8C%BA%E5%88%AB">92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</a></li><li><a href="#93-escapeencodeuriencodeuricomponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">93. escape,encodeURI,encodeURIComponent 有什么区别？</a></li><li><a href="#94-unicode-%E5%92%8C-utf-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">94. Unicode 和 UTF-8 之间的关系？</a></li><li><a href="#95-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88">95. js 的事件循环是什么？</a></li><li><a href="#96-js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0">96. js 中的深浅拷贝实现？</a></li><li><a href="#97-%E6%89%8B%E5%86%99-callapply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0">97. 手写 call、apply 及 bind 函数</a></li><li><a href="#98-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">98. 函数柯里化的实现</a></li><li><a href="#99-%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">99. 为什么 0.1 0.2 !&#x3D; 0.3？如何解决这个问题？</a></li><li><a href="#100-%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D">100. 原码、反码和补码的介绍</a></li><li><a href="#101-toprecision-%E5%92%8C-tofixed-%E5%92%8C-mathround-%E7%9A%84%E5%8C%BA%E5%88%AB">101. toPrecision 和 toFixed 和 Math.round 的区别？</a></li><li><a href="#102-%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</a></li><li><a href="#103-%E4%BB%80%E4%B9%88%E6%98%AF-csp">103. 什么是 CSP？</a></li><li><a href="#104-%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-csrf-%E6%94%BB%E5%87%BB">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</a></li><li><a href="#105-%E4%BB%80%E4%B9%88%E6%98%AF-samesite-cookie-%E5%B1%9E%E6%80%A7">105. 什么是 Samesite Cookie 属性？</a></li><li><a href="#106-%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">106. 什么是点击劫持？如何防范点击劫持？</a></li><li><a href="#107-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">107. SQL 注入攻击？</a></li><li><a href="#108-%E4%BB%80%E4%B9%88%E6%98%AF-mvvm%E6%AF%94%E4%B9%8B-mvc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-mvp-">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li><li><a href="#109-vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">109. vue 双向数据绑定原理？</a></li><li><a href="#110-objectdefineproperty-%E4%BB%8B%E7%BB%8D">110. Object.defineProperty 介绍？</a></li><li><a href="#111-%E4%BD%BF%E7%94%A8-objectdefineproperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9">111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li><a href="#112-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom%E4%B8%BA%E4%BB%80%E4%B9%88-virtual-dom-%E6%AF%94%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li><li><a href="#113-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-dom-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82">113. 如何比较两个 DOM 树的差异？</a></li><li><a href="#114-%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe-">114. 什么是 requestAnimationFrame ？</a></li><li><a href="#115-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95">115. 谈谈你对 webpack 的看法</a></li><li><a href="#116-offsetwidthoffsetheightclientwidthclientheight-%E4%B8%8E-scrollwidthscrollheight-%E7%9A%84%E5%8C%BA%E5%88%AB">116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</a></li><li><a href="#117-%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">117. 谈一谈你理解的函数式编程？</a></li><li><a href="#118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">118. 异步编程的实现方式？</a></li><li><a href="#119-js-%E5%8A%A8%E7%94%BB%E4%B8%8E-css-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">119. Js 动画与 CSS 动画区别及相应实现</a></li><li><a href="#120-get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">120. get 请求传参长度的误区</a></li><li><a href="#121-url-%E5%92%8C-uri-%E7%9A%84%E5%8C%BA%E5%88%AB">121. URL 和 URI 的区别？</a></li><li><a href="#122-get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">122. get 和 post 请求在缓存方面的区别</a></li><li><a href="#123-%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">123. 图片的懒加载和预加载</a></li><li><a href="#124-mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB">124. mouseover 和 mouseenter 的区别？</a></li><li><a href="#125-js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">125. js 拖拽功能的实现</a></li><li><a href="#126-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-settimeout-%E5%AE%9E%E7%8E%B0-setinterval%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li><li><a href="#127-let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">127. let 和 const 的注意点？</a></li><li><a href="#128-%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0">128. 什么是 rest 参数？</a></li><li><a href="#129-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">129. 什么是尾调用，使用尾调用有什么好处？</a></li><li><a href="#130-symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">130. Symbol 类型的注意点？</a></li><li><a href="#131-set-%E5%92%8C-weakset-%E7%BB%93%E6%9E%84">131. Set 和 WeakSet 结构？</a></li><li><a href="#132-map-%E5%92%8C-weakmap-%E7%BB%93%E6%9E%84">132. Map 和 WeakMap 结构？</a></li><li><a href="#133-%E4%BB%80%E4%B9%88%E6%98%AF-proxy-">133. 什么是 Proxy ？</a></li><li><a href="#134-reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84">134. Reflect 对象创建目的？</a></li><li><a href="#135-require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">135. require 模块引入的查找方式？</a></li><li><a href="#136-%E4%BB%80%E4%B9%88%E6%98%AF-promise-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%98%AF-promisesa-%E8%A7%84%E8%8C%83">136. 什么是 Promise 对象，什么是 Promises&#x2F;A 规范？</a></li><li><a href="#137-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise">137. 手写一个 Promise</a></li><li><a href="#138-%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">138. 如何检测浏览器所支持的最小字体大小？</a></li><li><a href="#139-%E6%80%8E%E4%B9%88%E5%81%9A-js-%E4%BB%A3%E7%A0%81-error-%E7%BB%9F%E8%AE%A1">139. 怎么做 JS 代码 Error 统计？</a></li><li><a href="#140-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">140. 单例模式模式是什么？</a></li><li><a href="#141-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">141. 策略模式是什么？</a></li><li><a href="#142-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">142. 代理模式是什么？</a></li><li><a href="#143-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">143. 中介者模式是什么？</a></li><li><a href="#144-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">144. 适配器模式是什么？</a></li><li><a href="#145-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">145. 观察者模式和发布订阅模式有什么不同？</a></li><li><a href="#146-vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">146. Vue 的生命周期是什么？</a></li><li><a href="#147-vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88">147. Vue 的各个生命阶段是什么？</a></li><li><a href="#148-vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">148. Vue 组件间的参数传递方式？</a></li><li><a href="#149-computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82">149. computed 和 watch 的差异？</a></li><li><a href="#150-vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">150. vue-router 中的导航钩子函数</a></li><li><a href="#151-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">151. $route 和 $router 的区别？</a></li><li><a href="#152-vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">152. vue 常用的修饰符？</a></li><li><a href="#153-vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8">153. vue 中 key 值的作用？</a></li><li><a href="#154-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB">154. computed 和 watch 区别？</a></li><li><a href="#155-keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">155. keep-alive 组件有什么作用？</a></li><li><a href="#156-vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB">156. vue 中 mixin 和 mixins 区别？</a></li><li><a href="#157-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-content-type-">157. 开发中常用的几种 Content-Type ？</a></li><li><a href="#158-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0">158. 如何封装一个 javascript 的类型判断函数？</a></li><li><a href="#159-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1">159. 如何判断一个对象是否为空对象？</a></li><li><a href="#160-%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1234">160. 使用闭包实现每隔一秒打印 1,2,3,4</a></li><li><a href="#161-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp">161. 手写一个 jsonp</a></li><li><a href="#162-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">162. 手写一个观察者模式？</a></li><li><a href="#163-eventemitter-%E5%AE%9E%E7%8E%B0">163. EventEmitter 实现</a></li><li><a href="#164-%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AFjs%E9%9D%A2%E8%AF%95%E9%A2%98">164. 一道常被人轻视的前端 JS 面试题</a></li><li><a href="#165-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%E4%BB%80%E4%B9%88%E6%98%AF-performance-api">165. 如何确定页面的可用性时间，什么是 Performance API？</a></li><li><a href="#166-js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">166. js 中的命名规则</a></li><li><a href="#167-js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">167. js 语句末尾分号是否可以省略？</a></li><li><a href="#168-objectassign">168. Object.assign()</a></li><li><a href="#169-mathceil-%E5%92%8C-mathfloor">169. Math.ceil 和 Math.floor</a></li><li><a href="#170-js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9">170. js for 循环注意点</a></li><li><a href="#171-%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%81%87%E8%AE%BE%E6%9C%89100000%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">171. 一个列表，假设有 100000 个数据，这个该怎么办？</a></li><li><a href="#172-js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0">172. js 中倒计时的纠偏实现？</a></li><li><a href="#173-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">173. 进程间通信的方式？</a></li><li><a href="#174-%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">174. 如何查找一篇英文文章中出现频率最高的单词？</a></li><li><a href="#175-elegetelementsbyclassname%E5%92%8Celequeryselectorall%E7%9A%84%E5%8C%BA%E5%88%AB">175. ele.getElementsByClassName和ele.querySelectorAll的区别？</a></li></ul><h4 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 一共有五种基本数据类型，分别是 Undefined、Null、<span class="hljs-built_in">Boolean</span>、<span class="hljs-built_in">Number</span>、<span class="hljs-built_in">String</span>，还有在 ES6 中新增的 <span class="hljs-built_in">Symbol</span> 和 ES10 中新增的 <span class="hljs-built_in">BigInt</span> 类型。<br><span class="hljs-built_in">Symbol</span> 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br><span class="hljs-built_in">BigInt</span> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 <span class="hljs-built_in">BigInt</span> 可以安全地存储和操作大整数，即使这个数已经超出了 <span class="hljs-built_in">Number</span> 能够表示的安全整数范围。<br></code></pre></td></tr></table></figure><h4 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h4><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。<br><br>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<br>栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实<br>体。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br><br>基本数据类型....（参考<span class="hljs-number">1</span>）<br><br>复杂数据类型指的是 <span class="hljs-built_in">Object</span> 类型，所有其他的如 <span class="hljs-built_in">Array</span>、<span class="hljs-built_in">Date</span> 等数据类型都可以理解为 <span class="hljs-built_in">Object</span> 类型的子类。<br><br>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/lxcao/article/details/52749421">《JavaScript 有几种类型的值？》</a><br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h4 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">堆和栈的概念存在于数据结构中和操作系统内存中。<br><br>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>二叉树是堆的一种实现方式。<br><br>在操作系统中，内存被分为栈区和堆区。<br><br>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br><br>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h4 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 [[Class]] 是什么？"></a>4. 内部属性 [[Class]] 是什么？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">所有 <span class="hljs-keyword">typeof</span> 返回值为 <span class="hljs-string">&quot;object&quot;</span> 的对象（如数组）都包含一个内部属性 [[<span class="hljs-title class_">Class</span>]]（我们可以把它看作一个内部的分类，而非<br>传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(..) 来查看。例如：<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );<br><span class="hljs-comment">// &quot;[object Array]&quot;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-regexp">/regex-literal/i</span> );<br><span class="hljs-comment">// &quot;[object RegExp]&quot;</span><br><br><span class="hljs-comment">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="hljs-comment">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span> &#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class1</span>()); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// 需要定制[[Class]]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class2</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class2&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class2</span>()); <span class="hljs-comment">// &quot;[object Class2]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h4><p>涉及知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">全局的对象（ global objects ）或称标准内置对象，不要和 <span class="hljs-string">&quot;全局对象（global object）&quot;</span> 混淆。这里说的全局的对象是说在<br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。<br><br>标准内置对象的分类<br><br>（<span class="hljs-number">1</span>）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。<br><br>例如 <span class="hljs-literal">Infinity</span>、<span class="hljs-literal">NaN</span>、<span class="hljs-literal">undefined</span>、<span class="hljs-literal">null</span> 字面量<br><br>（<span class="hljs-number">2</span>）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。<br><br>例如 <span class="hljs-built_in">eval</span>()、<span class="hljs-built_in">parseFloat</span>()、<span class="hljs-built_in">parseInt</span>() 等<br><br>（<span class="hljs-number">3</span>）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。<br><br>例如 <span class="hljs-built_in">Object</span>、<span class="hljs-built_in">Function</span>、<span class="hljs-built_in">Boolean</span>、<span class="hljs-built_in">Symbol</span>、<span class="hljs-built_in">Error</span> 等<br><br>（<span class="hljs-number">4</span>）数字和日期对象，用来表示数字、日期和执行数学计算的对象。<br><br>例如 <span class="hljs-built_in">Number</span>、<span class="hljs-built_in">Math</span>、<span class="hljs-built_in">Date</span><br><br>（<span class="hljs-number">5</span>）字符串，用来表示和操作字符串的对象。<br><br>例如 <span class="hljs-built_in">String</span>、<span class="hljs-built_in">RegExp</span><br><br>（<span class="hljs-number">6</span>）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 <span class="hljs-built_in">Array</span><br><br>（<span class="hljs-number">7</span>）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br><br>例如 <span class="hljs-built_in">Map</span>、<span class="hljs-built_in">Set</span>、<span class="hljs-built_in">WeakMap</span>、<span class="hljs-built_in">WeakSet</span><br><br>（<span class="hljs-number">8</span>）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br><br>例如 SIMD 等<br><br>（<span class="hljs-number">9</span>）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 <span class="hljs-built_in">JSON</span> 编码的数据。<br><br>例如 <span class="hljs-built_in">JSON</span> 等<br><br>（<span class="hljs-number">10</span>）控制抽象对象<br><br>例如 <span class="hljs-built_in">Promise</span>、<span class="hljs-built_in">Generator</span> 等<br><br>（<span class="hljs-number">11</span>）反射<br><br>例如 <span class="hljs-built_in">Reflect</span>、<span class="hljs-built_in">Proxy</span><br><br>（<span class="hljs-number">12</span>）国际化，为了支持多语言处理而加入 ECMAScript 的对象。<br><br>例如 <span class="hljs-built_in">Intl</span>、<span class="hljs-built_in">Intl</span>.Collator 等<br><br>（<span class="hljs-number">13</span>）<span class="hljs-built_in">WebAssembly</span><br><br>（<span class="hljs-number">14</span>）其他<br><br>例如 arguments<br><br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函<br>数对象。一般我们经常用到的如全局变量值 <span class="hljs-literal">NaN</span>、<span class="hljs-literal">undefined</span>，全局函数如 <span class="hljs-built_in">parseInt</span>()、<span class="hljs-built_in">parseFloat</span>() 用来实例化对象的构<br>造函数如 <span class="hljs-built_in">Date</span>、<span class="hljs-built_in">Object</span> 等，还有提供数学计算的单体内置对象如 <span class="hljs-built_in">Math</span> 对象。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24">《JS 所有内置对象属性和方法汇总》</a></p><h4 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">已在作用域中声明但还没有赋值的变量，是 <span class="hljs-literal">undefined</span> 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。<br><br>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b <span class="hljs-keyword">is</span> not defined 。但是我们可以使用 typ<br>eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，<span class="hljs-keyword">typeof</span> 会返回 <span class="hljs-string">&quot;undefined&quot;</span>。<br></code></pre></td></tr></table></figure><h4 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">首先 <span class="hljs-literal">Undefined</span> 和 <span class="hljs-literal">Null</span> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <span class="hljs-literal">undefined</span> 和 <span class="hljs-literal">null</span>。<br><br><span class="hljs-literal">undefined</span> 代表的含义是未定义，<span class="hljs-literal">null</span> 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 <span class="hljs-literal">undefined</span>，<span class="hljs-literal">null</span><br>主要用于赋值给一些可能会返回对象的变量，作为初始化。<br><br><span class="hljs-literal">undefined</span> 在 js 中不是一个保留字，这意味着我们可以使用 <span class="hljs-literal">undefined</span> 来作为一个变量名，这样的做法是非常危险的，它<br>会影响我们对 <span class="hljs-literal">undefined</span> 值的判断。但是我们可以通过一些方法获得安全的 <span class="hljs-literal">undefined</span> 值，比如说 <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>。<br><br>当我们对两种类型使用 <span class="hljs-built_in">typeof</span> 进行判断的时候，<span class="hljs-literal">Null</span> 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等<br>号对两种类型的值进行比较时会返回 <span class="hljs-literal">true</span>，使用三个等号时会返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html">《JavaScript 深入理解之 undefined 与 null》</a></p><h4 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">因为 <span class="hljs-literal">undefined</span> 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 <span class="hljs-literal">undefined</span> 的正常判断。<br><br>表达式 <span class="hljs-keyword">void</span> ___ 没有返回值，因此返回结果是 <span class="hljs-literal">undefined</span>。<span class="hljs-keyword">void</span> 并不改变表达式的结果，只是让表达式不返回值。<br><br>按惯例我们用 <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> 来获得 <span class="hljs-literal">undefined</span>。<br></code></pre></td></tr></table></figure><h4 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">在平常项目开发中，我们遵守一些这样的基本规范，比如说：<br><br>（<span class="hljs-number">1</span>）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 <span class="hljs-keyword">var</span> 声明，不允许出现两个连续的 <span class="hljs-keyword">var</span> 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。<br><br>（<span class="hljs-number">2</span>）代码中出现地址、时间等字符串时需要使用常量代替。<br><br>（<span class="hljs-number">3</span>）在进行比较的时候吧，尽量使用<span class="hljs-string">&#x27;===&#x27;</span>, <span class="hljs-string">&#x27;!==&#x27;</span>代替<span class="hljs-string">&#x27;==&#x27;</span>, <span class="hljs-string">&#x27;!=&#x27;</span>。<br><br>（<span class="hljs-number">4</span>）不要在内置对象的原型上添加方法，如 <span class="hljs-title class_">Array</span>, <span class="hljs-title class_">Date</span>。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">switch</span> 语句必须带有 <span class="hljs-keyword">default</span> 分支。<br><br>（<span class="hljs-number">6</span>）<span class="hljs-keyword">for</span> 循环必须使用大括号。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">if</span> 语句必须使用大括号。<br></code></pre></td></tr></table></figure><h4 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 proto<span class="hljs-keyword">type</span> 属性值，这个属性值是一个对<br>象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部<br>将包含一个指针，这个指针指向构造函数的 proto<span class="hljs-keyword">type</span> 属性对应的值，在 <span class="hljs-type">ES5</span> 中这个指针被称为对象的原型。一般来说我们<br>是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这<br>个属性，因为它不是规范中规定的。<span class="hljs-type">ES5</span> 中新增了一个 <span class="hljs-type">Object</span>.getPrototypeOf() 方法，我们可以通过这个方法来获取对<br>象的原型。<br><br>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又<br>会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span> 所以这就<br>是我们新建的对象为什么能够使用 toString() 等方法的原因。<br><br>特点：<br><br><span class="hljs-type">JavaScript</span> 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与<br>之相关的对象也会继承这一改变。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p><h4 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h4><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h4 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h4><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h4 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 <span class="hljs-number">2</span>^<span class="hljs-number">53</span> - <span class="hljs-number">1</span>，<br>即<span class="hljs-number">9007199254740991</span>，在 ES6 中被定义为 <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER。最小整数是<span class="hljs-number">-9007199254740991</span>，在 ES6 中<br>被定义为 <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER。<br><br>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 <span class="hljs-literal">Infinity</span> 值。如果某次<br>计算返回了正或负的 <span class="hljs-literal">Infinity</span> 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 <span class="hljs-built_in">isFinite</span> 函数<br>来判断。<br></code></pre></td></tr></table></figure><h4 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> 意指“不是一个数字”（not a <span class="hljs-built_in">number</span>），<span class="hljs-literal">NaN</span> 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。<br><br><span class="hljs-built_in">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br><br><span class="hljs-literal">NaN</span> 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 <span class="hljs-literal">NaN</span> != <span class="hljs-literal">NaN</span><br>为 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><h4 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">函数 <span class="hljs-built_in">isNaN</span> 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 <span class="hljs-literal">true</span>，因此非数字值传入也会<br>返回 <span class="hljs-literal">true</span> ，会影响 <span class="hljs-literal">NaN</span> 的判断。<br><br>函数 <span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isNaN</span> 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 <span class="hljs-literal">NaN</span> ，这种方法对于 <span class="hljs-literal">NaN</span> 的判断更为<br>准确。<br></code></pre></td></tr></table></figure><h4 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Array</span> 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（<span class="hljs-built_in">length</span>），而非只充当数组中的一个元素。这样<br>创建出来的只是一个空数组，只不过它的 <span class="hljs-built_in">length</span> 属性被设置成了指定的值。<br><br>构造函数 <span class="hljs-built_in">Array</span>(..) 不要求必须带 <span class="hljs-keyword">new</span> 关键字。不带时，它会被自动补上。<br></code></pre></td></tr></table></figure><h4 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">规范的 <span class="hljs-number">9.8</span> 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。<br><br>（<span class="hljs-number">1</span>）<span class="hljs-literal">Null</span> 和 Undefined 类型 ，<span class="hljs-literal">null</span> 转换为 <span class="hljs-string">&quot;null&quot;</span>，undefined 转换为 <span class="hljs-string">&quot;undefined&quot;</span>，<br><br>（<span class="hljs-number">2</span>）Boolean 类型，<span class="hljs-literal">true</span> 转换为 <span class="hljs-string">&quot;true&quot;</span>，<span class="hljs-literal">false</span> 转换为 <span class="hljs-string">&quot;false&quot;</span>。<br><br>（<span class="hljs-number">3</span>）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。<br><br>（<span class="hljs-number">4</span>）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。<br><br>（<span class="hljs-number">5</span>）对普通对象来说，除非自行定义 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>() 方法，否则会调用 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>()（Object.prototype.<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>()）<br>    来返回内部属性 [[<span class="hljs-keyword">Class</span>]] 的值，如<span class="hljs-string">&quot;[object Object]&quot;</span>。如果对象有自己的 <span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>() 方法，字符串化时就会<br>    调用该方法并使用其返回值。<br></code></pre></td></tr></table></figure><h4 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss">有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 <span class="hljs-number">9.3</span> 节定义了抽象操作 ToNumber。<br><br>（<span class="hljs-number">1</span>）Undefined 类型的值转换为 NaN。<br><br>（<span class="hljs-number">2</span>）Null 类型的值转换为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">3</span>）Boolean 类型的值，true 转换为 <span class="hljs-number">1</span>，false 转换为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">4</span>）String 类型的值转换如同使用 <span class="hljs-built_in">Number</span>() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 <span class="hljs-number">0</span>。<br><br>（<span class="hljs-number">5</span>）Symbol 类型的值不能转换为数字，会报错。<br><br>（<span class="hljs-number">6</span>）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<br><br>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有<span class="hljs-built_in">valueOf</span>() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 <span class="hljs-built_in">toString</span>() 的返回值（如果存在）来进行强制类型转换。<br><br>如果 <span class="hljs-built_in">valueOf</span>() 和 <span class="hljs-built_in">toString</span>() 均不返回基本类型值，会产生 TypeError 错误。<br></code></pre></td></tr></table></figure><h4 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ES5 规范 <span class="hljs-number">9.2</span> 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。<br><br>以下这些是假值：<br>• <span class="hljs-literal">undefined</span><br>• <span class="hljs-literal">null</span><br>• <span class="hljs-literal">false</span><br>• +<span class="hljs-number">0</span>、<span class="hljs-number">-0</span> 和 <span class="hljs-literal">NaN</span><br>• <span class="hljs-string">&quot;&quot;</span><br><br>假值的布尔强制类型转换结果为 <span class="hljs-literal">false</span>。从逻辑上说，假值列表以外的都应该是真值。<br></code></pre></td></tr></table></figure><h4 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，<span class="hljs-built_in">toString</span> 的结果为 <span class="hljs-string">&quot;[object Object]&quot;</span><br><br>[] 的 valueOf 结果为 [] ，<span class="hljs-built_in">toString</span> 的结果为 <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">浏览器在某些特定情况下，在常规 <span class="hljs-keyword">JavaScript </span>语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和<br>普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它<br>是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 <span class="hljs-keyword">JavaScript </span>引擎）提供给 <span class="hljs-keyword">JavaScript </span>程序使用。<br></code></pre></td></tr></table></figure><h4 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。<br><br>~x 大致等同于 -(x+1)。<br></code></pre></td></tr></table></figure><h4 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">解析允许字符串（如 <span class="hljs-built_in">parseInt</span>() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu<br>mber ()）不允许出现非数字字符，否则会失败并返回 NaN。<br></code></pre></td></tr></table></figure><h4 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">根据 ES5 规范 <span class="hljs-number">11.6</span><span class="hljs-number">.1</span> 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 <span class="hljs-string">[[DefaultValue]]</span>，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br><br>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字<br>加法。<br><br>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。<br></code></pre></td></tr></table></figure><h4 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">（<span class="hljs-number">1</span>） <span class="hljs-keyword">if</span> <span class="hljs-comment">(..)</span> 语句中的条件判断表达式。<br>（<span class="hljs-number">2</span>） for <span class="hljs-comment">( .. ; .. ; .. )</span> 语句中的条件判断表达式（第二个）。<br>（<span class="hljs-number">3</span>） <span class="hljs-keyword">while</span> <span class="hljs-comment">(..)</span> 和 do..while<span class="hljs-comment">(..)</span> 循环中的条件判断表达式。<br>（<span class="hljs-number">4</span>） ? : 中的条件判断表达式。<br>（<span class="hljs-number">5</span>） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。<br></code></pre></td></tr></table></figure><h4 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件</span><br>判断。<br><br>对于 <span class="hljs-string">|| 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</span><br><br><span class="hljs-meta">&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</span><br><br><span class="hljs-string">|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</span><br></code></pre></td></tr></table></figure><h4 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。<br><br><span class="hljs-built_in">Symbol</span> 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果<br>都是 <span class="hljs-literal">true</span> ）。<br></code></pre></td></tr></table></figure><h4 id="28-x3D-x3D-操作符的强制类型转换规则？"><a href="#28-x3D-x3D-操作符的强制类型转换规则？" class="headerlink" title="28. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>28. &#x3D;&#x3D; 操作符的强制类型转换规则？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-number">1</span>）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。<br><br>（<span class="hljs-number">2</span>）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-literal">null</span> 和 <span class="hljs-literal">undefined</span> 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。<br><br>（<span class="hljs-number">4</span>）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。<br><br>（<span class="hljs-number">5</span>）如果一个操作值为 <span class="hljs-literal">NaN</span> ，则相等比较返回 <span class="hljs-literal">false</span>（ <span class="hljs-literal">NaN</span> 本身也不等于 <span class="hljs-literal">NaN</span> ）。<br><br>（<span class="hljs-number">6</span>）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <span class="hljs-literal">true</span>，否则，返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/">《JavaScript 字符串间的比较》</a></p><h4 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">（<span class="hljs-number">1</span>）使用 <span class="hljs-built_in">Number</span>() 方法，前提是所包含的字符串不包含不合法字符。<br><br>（<span class="hljs-number">2</span>）使用 <span class="hljs-built_in">parseInt</span>() 方法，<span class="hljs-built_in">parseInt</span>() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 <span class="hljs-number">0</span>，或没有设置该参数时，<span class="hljs-built_in">parseInt</span>() 会根据 string 来判断数字的基数。<br><br>（<span class="hljs-number">3</span>）使用 <span class="hljs-built_in">parseFloat</span>() 方法，该函数解析一个字符串参数并返回一个浮点数。<br><br>（<span class="hljs-number">4</span>）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h4 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number &amp;&amp; number.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">NumberFormat</span>().<span class="hljs-title function_">format</span>(number)<br>&#125;<br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format2</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7">《JS 常用正则汇总》</a></p><h4 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h4><p><a href="http://www.hangge.com/blog/cache/detail_1872.html">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h4 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span><br><br><span class="hljs-comment">// （2）随机从原数组抽取一个元素，加入到新数组</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br><br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * arr.<span class="hljs-property">length</span>);<br>    result.<span class="hljs-title function_">push</span>(arr[randomIndex]);<br>    arr.<span class="hljs-title function_">splice</span>(randomIndex, <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// （3）随机交换数组内的元素（洗牌算法类似）</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> index,<br>    randomIndex,<br>    temp,<br>    len = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; len; index++) &#123;<br>    randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (len - index)) + index;<br><br>    temp = arr[index];<br>    arr[index] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// es6</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> length = array.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array) || length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; length - <span class="hljs-number">1</span>; index++) &#123;<br>    <span class="hljs-keyword">let</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (length - index)) + index;<br><br>    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p><h4 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：<br><br>（<span class="hljs-number">1</span>）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。<br><br>（<span class="hljs-number">2</span>）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 <span class="hljs-keyword">new</span> <span class="hljs-type"></span>来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 <span class="hljs-built_in">this</span> 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 <span class="hljs-built_in">this</span> 的值指向了新建的对象，因此我们可以使用 <span class="hljs-built_in">this</span> 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<br><br>（<span class="hljs-number">3</span>）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 <span class="hljs-keyword">Array</span> 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<br><br>（<span class="hljs-number">4</span>）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<br><br>（<span class="hljs-number">5</span>）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。<br><br>（<span class="hljs-number">6</span>）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。<br><br>嗯我目前了解到的就是这么几种方式。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p><h4 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">我了解的 js 中实现继承的几种方式有：<br><br>（<span class="hljs-number">1</span>）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。<br><br>（<span class="hljs-number">2</span>）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。<br><br>（<span class="hljs-number">3</span>）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。<br><br>（<span class="hljs-number">4</span>）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>() 方法就是原型式继承的实现。缺点与原型链方式相同。<br><br>（<span class="hljs-number">5</span>）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。<br><br>（<span class="hljs-number">6</span>）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html">《JavaScript 深入理解之继承》</a></p><h4 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, grade</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayMyGrade</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My grade is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。<br><br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br><br>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。<br><br>作用域链的创建过程跟执行上下文的建立有关....<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p><h4 id="38-谈谈-This-对象的理解。"><a href="#38-谈谈-This-对象的理解。" class="headerlink" title="38. 谈谈 This 对象的理解。"></a>38. 谈谈 This 对象的理解。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，<span class="hljs-keyword">this</span> 的指向可以通过四种调用模<br>式来判断。<br></code></pre></td></tr></table></figure><ul><li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p></li><li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p></li><li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p></li><li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p></li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 <span class="hljs-keyword">call</span> 和 <span class="hljs-keyword">bind</span> 调用模式，然后是方法调用模式，然后<br>是函数调用模式。<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 this 详解》</a></p><h4 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">它的功能是把对应的字符串解析成 <span class="hljs-keyword">JS </span>代码并运行。<br><br>应该避免使用 eval，不安全，非常耗性能（<span class="hljs-number">2</span>次，一次解析成 <span class="hljs-keyword">js </span>语句，一次执行）。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p><h4 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。<br><br>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM<br>的核心是 <span class="hljs-built_in">window</span>，而 <span class="hljs-built_in">window</span> 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）<br>对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<span class="hljs-built_in">window</span> 对象含有 locati<br><span class="hljs-keyword">on</span> 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 <span class="hljs-built_in">document</span> 对象也是 BOM 的 <span class="hljs-built_in">window</span> 对<br>象的子对象。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h4 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventUtils</span> = &#123;<br>  <span class="hljs-comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br>  <span class="hljs-comment">// 添加事件</span><br>  <span class="hljs-attr">addEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">addEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = handler;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 移除事件</span><br>  <span class="hljs-attr">removeEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">removeEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">removeEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">detachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取事件目标</span><br>  <span class="hljs-attr">getTarget</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br>  <span class="hljs-attr">getEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br>  <span class="hljs-attr">stopPropagation</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">stopPropagation</span>) &#123;<br>      event.<span class="hljs-title function_">stopPropagation</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 取消事件的默认行为</span><br>  <span class="hljs-attr">preventDefault</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;<br>      event.<span class="hljs-title function_">preventDefault</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p><h4 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p></li><li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble &#x3D; true;</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h4 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。<br><br>第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。<br><br>第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 <span class="hljs-built_in">document</span>，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。<br><br>第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 <span class="hljs-built_in">document</span> 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h4 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到<br>目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。<br><br>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p><h4 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 <span class="hljs-number">2</span> ~ <span class="hljs-number">36</span> 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。<br><br><br>此处 <span class="hljs-built_in">map</span> 传了 <span class="hljs-number">3</span> 个参数 (element, index, <span class="hljs-built_in">array</span>)，默认第三个参数被忽略掉，因此三次传入的参数分别为 <span class="hljs-string">&quot;1-0&quot;</span>, <span class="hljs-string">&quot;2-1&quot;</span>, <span class="hljs-string">&quot;3-2&quot;</span><br><br>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 <span class="hljs-literal">NaN</span> ，第一次基数为 <span class="hljs-number">0</span> ，按十进制解析返回 <span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h4 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以<br>访问到当前函数的局部变量。<br><br>闭包有两个常用的用途。<br><br>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外<br>部访问到函数内部的变量，可以使用这种方法来创建私有变量。<br><br>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以<br>这个变量对象不会被回收。<br><br>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p><h4 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h4><p>相关知识点：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。<br><br>设立<span class="hljs-string">&quot;严格模式&quot;</span>的目的，主要有以下几个：<br></code></pre></td></tr></table></figure><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">use <span class="hljs-built_in">strict</span> 指的是严格运行模式，在这种模式对 <span class="hljs-keyword">js</span> 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使<br>用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 <span class="hljs-keyword">js</span> 语法本身的一<br>些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 <span class="hljs-keyword">js</span> 一种更合理、更安全、更严谨的发展方向。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p><h4 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。<br><br>第二种方式可以通过对象的 <span class="hljs-function"><span class="hljs-keyword">constructor</span> 属性来判断，对象的 <span class="hljs-title">constructor</span> 属性指向该对象的构造函数，但是这种方式不是很安全，因为 <span class="hljs-title">constructor</span> 属性可以被改写。</span><br><span class="hljs-function"></span><br><span class="hljs-function">第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 <span class="hljs-title">Object</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span> 方法来打印对象的</span><br><span class="hljs-function">[[<span class="hljs-title">Class</span>]] 属性来进行判断。</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p><h4 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="hljs-comment">// 实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left), <span class="hljs-comment">// 获取对象的原型</span><br>    prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br><br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p><h4 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a>50. new 操作符具体干了什么呢？如何实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）首先创建了一个新的空对象</span><br><span class="hljs-comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="hljs-comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="hljs-comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span><br><br><span class="hljs-comment">// 实现:</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>),<br>    result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 参数判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br><br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p><h4 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">hasOwnProperty<br><br>所有继承了 <span class="hljs-built_in">Object</span> 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和<br><span class="hljs-keyword">in</span> 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p><h4 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h4><p>相关知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">JSON</span> 是一种数据交换格式，基于文本，优于轻量，用于交换数据。<br><br><span class="hljs-built_in">JSON</span> 可以表示数字、布尔值、字符串、<span class="hljs-literal">null</span>、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与<br>值的映射）。<br><br><span class="hljs-built_in">JSON</span> 使用 JavaScript 语法，但是 <span class="hljs-built_in">JSON</span> 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JSON </span>是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br><br>在项目开发中，我们使用 <span class="hljs-keyword">JSON </span>作为前后端数据交换的方式。在前端我们通过将一个符合 <span class="hljs-keyword">JSON </span>格式的数据结构序列化为 <span class="hljs-keyword">JSON </span>字符串，然后将它传递到后端，后端通过 <span class="hljs-keyword">JSON </span>格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br><br>因为 <span class="hljs-keyword">JSON </span>的语法是基于 <span class="hljs-keyword">js </span>的，因此很容易将 <span class="hljs-keyword">JSON </span>和 <span class="hljs-keyword">js </span>中的对象弄混，但是我们应该注意的是 <span class="hljs-keyword">JSON </span>和 <span class="hljs-keyword">js </span>中的对象不是一回事，<span class="hljs-keyword">JSON </span>中对象格式更加严格，比如说在 <span class="hljs-keyword">JSON </span>中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 <span class="hljs-keyword">js </span>对象是不符合 <span class="hljs-keyword">JSON </span>对象的格式的。<br><br>在 <span class="hljs-keyword">js </span>中提供了两个函数来实现 <span class="hljs-keyword">js </span>数据结构和 <span class="hljs-keyword">JSON </span>格式的转换处理，一个是 <span class="hljs-keyword">JSON.stringify </span>函数，通过传入一个符合 <span class="hljs-keyword">JSON </span>格式的数据结构，将其转换为一个 <span class="hljs-keyword">JSON </span>字符串。如果传入的数据结构不符合 <span class="hljs-keyword">JSON </span>格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 <span class="hljs-keyword">JSON </span>格式的字符串。<br><br>另一个函数 <span class="hljs-keyword">JSON.parse() </span>函数，这个函数用来将 <span class="hljs-keyword">JSON </span>格式的字符串转换为一个 <span class="hljs-keyword">js </span>数据结构，如果传入的字符串不是标准的 <span class="hljs-keyword">JSON </span>格式的字符串的话，将会抛出错误。当我们从后端接收到 <span class="hljs-keyword">JSON </span>格式的字符串时，我们可以通过这个方法来将其解析为一个 <span class="hljs-keyword">js </span>数据结构，以此来进行数据的访问。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p><h4 id="53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. <code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">（<span class="hljs-number">1</span>）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document<span class="hljs-selector-class">.querySelectorAll</span> 方法。<br><br>（<span class="hljs-number">2</span>）循环遍历 DOM 元素<br><br>（<span class="hljs-number">3</span>）给元素添加 <span class="hljs-attribute">outline</span> 。由于渲染的 <span class="hljs-attribute">outline</span> 是不在 CSS 盒模型中的，所以为元素添加 <span class="hljs-attribute">outline</span> 并不会影响元素的大小和页面的布局。<br><br>（<span class="hljs-number">4</span>）生成随机颜色函数。Math<span class="hljs-selector-class">.random</span>()*(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">24</span>) 可以得到 <span class="hljs-number">0</span>~<span class="hljs-number">2</span>^<span class="hljs-number">24</span> - <span class="hljs-number">1</span> 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 <span class="hljs-built_in">toString</span>(<span class="hljs-number">16</span>) 的方式，转换为一个十六进制的字符串。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p><h4 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h4><p>相关知识点：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">js </span>延迟加载，也就是等页面加载完成之后再加载 <span class="hljs-keyword">JavaScript </span>文件。 <span class="hljs-keyword">js </span>延迟加载有助于提高页面加载速度。<br></code></pre></td></tr></table></figure><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">js </span>的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 <span class="hljs-keyword">js </span>脚本能够尽可能的延迟加载，提高页面的渲染速度。<br><br>我了解到的几种方式是：<br><br>第一种方式是我们一般采用的是将 <span class="hljs-keyword">js </span>脚本放在文档的底部，来使 <span class="hljs-keyword">js </span>脚本尽可能的在最后来加载执行。<br><br>第二种方式是给 <span class="hljs-keyword">js </span>脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。<br><br>第三种方式是给 <span class="hljs-keyword">js </span>脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 <span class="hljs-keyword">js </span>脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。<br><br>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 <span class="hljs-keyword">script </span>标签来引入 <span class="hljs-keyword">js </span>脚本。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h4 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h4><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p>一般实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// promise 封装实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br><br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 <span class="hljs-keyword">http</span> 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br><br>创建一个 ajax 有这样几个步骤<br><br>首先是创建一个 XMLHttpRequest 对象。<br><br>然后在这个对象上使用 <span class="hljs-built_in">open</span> 方法创建一个 <span class="hljs-keyword">http</span> 请求，<span class="hljs-built_in">open</span> 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。<br><br>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 <span class="hljs-number">5</span> 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 <span class="hljs-number">4</span> 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 <span class="hljs-number">2</span>xx 或者 <span class="hljs-number">304</span> 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。<br><br>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p><h4 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">浏览器的缓存机制指的是通过在一段时间内保留已接收到的 <span class="hljs-variable">web</span> 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 <span class="hljs-variable">web</span> 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。<br><br><span class="hljs-variable">web</span> 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。<br><br>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 <span class="hljs-variable">http</span> 头信息中的 <span class="hljs-variable">Expires</span> 属性和 <span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 属性。<br><br>服务器通过在响应头中添加 <span class="hljs-variable">Expires</span> 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。<br><br><span class="hljs-variable">Expires</span> 是 <span class="hljs-variable">http1</span><span class="hljs-number">.0</span> 中的方式，因为它的一些缺点，在 <span class="hljs-variable">http</span> <span class="hljs-number">1.1</span> 中提出了一个新的头部属性就是 <span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 属性，<br>它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 <span class="hljs-variable">max</span><span class="hljs-operator">-</span><span class="hljs-variable">age</span> 来指定资源能够被缓存的时间<br>的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 <span class="hljs-variable">Expires</span><br>来说，这种方式更加有效一些。常用的还有比如 <span class="hljs-variable">private</span> ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 <span class="hljs-variable">n</span><br><span class="hljs-variable">o</span><span class="hljs-operator">-</span><span class="hljs-variable">store</span> ，用来指定资源不能够被缓存，<span class="hljs-variable">no</span><span class="hljs-operator">-</span><span class="hljs-variable">cache</span> 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。<br><br>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span> 的优先级要高于 <span class="hljs-variable">Expires</span> 。<br><br>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 <span class="hljs-number">304</span> 状态，让浏览器使用本地的缓存副本。<br>如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 <span class="hljs-variable">http</span> 头信息中的 <span class="hljs-variable">Etag</span> 和 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 属性。<br><br>服务器通过在响应头中添加 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 的属性，属性值为上一次资源返回时的 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 <span class="hljs-number">304</span> 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 标注的最后修改时间只能精确到秒级，如果某些文件在<span class="hljs-number">1</span>秒钟以内，被修改多次的话，那么文件已将改变了但是 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 却没有改变，<br>这样会造成缓存命中的不准确。<br><br>因为 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的这种可能发生的不准确性，<span class="hljs-variable">http</span> 中提供了另外一种方式，那就是 <span class="hljs-variable">Etag</span> 属性。服务器在返回资源的时候，在头信息中添加了 <span class="hljs-variable">Etag</span> 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 属性，这个属性的值就是上次返回的资源的 <span class="hljs-variable">Etag</span> 的值。服务接收到请求后会根据这个值来和资源当前的 <span class="hljs-variable">Etag</span> 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 的方式更加精确。<br><br>当 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 和 <span class="hljs-variable">Etag</span> 属性同时出现的时候，<span class="hljs-variable">Etag</span> 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 应该保持一致，因为每个服务器上 <span class="hljs-variable">Etag</span> 的值都不一样，因此在考虑负载平衡时，最好不要设置 <span class="hljs-variable">Etag</span> 属性。<br><br>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p><h4 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h4><ul><li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p></li><li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p></li><li><p>3.在 URL 后面加上一个随机数： “fresh&#x3D;” + Math.random();。</p></li><li><p>4.在 URL 后面加上时间戳：”nowtime&#x3D;” + new Date().getTime();。</p></li><li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p><h4 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h4><p>相关知识点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  <br><br>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 <br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返<br>回为止再继续向下执行。<br><br>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等<br>待消息的返回，当消息返回时系统再通知进程进行处理。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p><h4 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我对浏览器的同源政策的理解是，一个域下的 <span class="hljs-keyword">js </span>脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。<br><br>同源政策主要限制了三个方面<br><br>第一个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。<br><br>第二个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够操作访问操作其他域下的 DOM。<br><br>第三个是当前域下 ajax 无法发送跨域请求。<br><br>同源政策的目的主要是为了保证用户的信息安全，它只是对 <span class="hljs-keyword">js </span>脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br><span class="hljs-keyword">script </span>脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br></code></pre></td></tr></table></figure><h4 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h4><p>相关知识点：</p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享（CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p>回答：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">解决跨域的方法我们可以根据我们想要实现的目的来划分。<br><br>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document<span class="hljs-selector-class">.domain</span> 来解决。<br><br>（<span class="hljs-number">1</span>）将 document<span class="hljs-selector-class">.domain</span> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 <span class="hljs-selector-tag">iframe</span> 的话，我们也可以对这个 <span class="hljs-selector-tag">iframe</span> 进行操作。<br><br>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 <span class="hljs-selector-tag">iframe</span> 进行通信的问题，我们可以使用 location<span class="hljs-selector-class">.hash</span> 或者 window<span class="hljs-selector-class">.name</span> 或者 postMessage 来解决。<br><br>（<span class="hljs-number">2</span>）使用 location<span class="hljs-selector-class">.hash</span> 的方法，我们可以在主页面动态的修改 <span class="hljs-selector-tag">iframe</span> 窗口的 hash 值，然后在 <span class="hljs-selector-tag">iframe</span> 窗口里实现监听函数来实现这样一个单向的通信。因为在 <span class="hljs-selector-tag">iframe</span> 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 <span class="hljs-selector-tag">iframe</span> 中再加入一个 <span class="hljs-selector-tag">iframe</span> ，这个 <span class="hljs-selector-tag">iframe</span> 的内容是和父级页面同源的，所以我们可以 window<span class="hljs-selector-class">.parent</span><span class="hljs-selector-class">.parent</span> 来修改最顶级页面的 <span class="hljs-attribute">src</span>，以此来实现双向通信。<br><br>（<span class="hljs-number">3</span>）使用 window<span class="hljs-selector-class">.name</span> 的方法，主要是基于同一个窗口中设置了 window<span class="hljs-selector-class">.name</span> 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window<span class="hljs-selector-class">.name</span> 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window<span class="hljs-selector-class">.name</span> 中的数据了，这种方式的好处是可以传输的数据量大。<br><br>（<span class="hljs-number">4</span>）使用 postMessage 来解决的方法，这是一个 <span class="hljs-selector-tag">h5</span> 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。<br><br>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。<br><br>（<span class="hljs-number">5</span>）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。<br><br>（<span class="hljs-number">6</span>）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是<span class="hljs-string">&quot;跨域资源共享&quot;</span>。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。<br><br>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。<br><br>（<span class="hljs-number">7</span>）使用 websocket 协议，这个协议没有同源限制。<br><br>（<span class="hljs-number">8</span>）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h4 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h4><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p><h4 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 <span class="hljs-number">4</span>k 大小的数据，并且只能够被同源的网页所共享访问。<br><br>服务器端可以使用 <span class="hljs-keyword">Set</span>-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了<span class="hljs-number">9</span>个属性值 <span class="hljs-type">name</span>、<span class="hljs-keyword">value</span>、expires、<span class="hljs-keyword">domain</span>、<span class="hljs-type">path</span>、secure、HttpOnly、SameSite、Priority。其中 <span class="hljs-type">name</span> 和 <span class="hljs-keyword">value</span> 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，<span class="hljs-keyword">domain</span> 是域名、<span class="hljs-type">path</span>是路径，<span class="hljs-keyword">domain</span> 和 <span class="hljs-type">path</span> 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。<br><br>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》 </a><br><a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》 </a></p><h4 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，<span class="hljs-keyword">js </span>只实现一些简单的功能，所以并没有模块的概念<br>，但随着程序越来越复杂，代码的模块化开发变得越来越重要。<br><br>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污<br>染，并且模块间没有联系。<br><br>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所<br>有的所有的模块成员，外部代码可以修改内部属性的值。<br><br>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p><h4 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中现在比较成熟的有四种模块加载方案。<br><br>第一种是 CommonJS 方案，它通过 <span class="hljs-built_in">require</span> 来引入模块，通过 module.<span class="hljs-built_in">exports</span> 定义模块的输出接口。这种模块加载方案是<br>服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式<br>加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。<br><br>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定<br>义在一个回调函数里，等到加载完成后再执行回调函数。<span class="hljs-built_in">require</span>.js 实现了 AMD 规范。<br><br>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 <span class="hljs-built_in">require</span>.js<br>的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考<span class="hljs-number">60</span><br><br>第四种方案是 ES6 提出的方案，使用 <span class="hljs-keyword">import</span> 和 <span class="hljs-keyword">export</span> 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 <span class="hljs-number">61</span>。<br></code></pre></td></tr></table></figure><h4 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h4><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// CMD</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);<br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>); <span class="hljs-comment">// 依赖可以就近书写</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-comment">// AMD 默认推荐</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-comment">// 依赖必须一开始就写好</span><br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p><h4 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><ul><li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p></li><li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><h4 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">require</span>.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 <span class="hljs-built_in">load</span> 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h4 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p><h4 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">在我看来 ES6 新添加的 <span class="hljs-keyword">class</span> 只是为了补充 <span class="hljs-symbol">js</span> 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 <span class="hljs-symbol">class</span> 可以有利于我们更好的组织代码。<br><br>在 <span class="hljs-symbol">class</span> 中添加的方法，其实是添加在类的原型上的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p><h4 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">document.<span class="hljs-built_in">write</span> 的内容会代替整个文档内容，会重写整个页面。<br><br>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p><h4 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createDocumentFragment</span>(node);<br><span class="hljs-title function_">createElement</span>(node);<br><span class="hljs-title function_">createTextNode</span>(text);<br></code></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">appendChild</span>(node)<br><span class="hljs-title function_">removeChild</span>(node)<br><span class="hljs-title function_">replaceChild</span>(<span class="hljs-keyword">new</span>,old)<br><span class="hljs-title function_">insertBefore</span>(<span class="hljs-keyword">new</span>,old)<br></code></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getElementById</span>();<br><span class="hljs-title function_">getElementsByName</span>();<br><span class="hljs-title function_">getElementsByTagName</span>();<br><span class="hljs-title function_">getElementsByClassName</span>();<br><span class="hljs-title function_">querySelector</span>();<br><span class="hljs-title function_">querySelectorAll</span>();<br></code></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getAttribute</span>(key);<br><span class="hljs-title function_">setAttribute</span>(key, value);<br><span class="hljs-title function_">hasAttribute</span>(key);<br><span class="hljs-title function_">removeAttribute</span>(key);<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h4 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">对于这样一个 <span class="hljs-selector-tag">HTML</span> 元素：&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;。<br><br>innerHTML：内部 <span class="hljs-selector-tag">HTML</span>，<span class="hljs-attribute">content</span>&lt;br/&gt;；<br>outerHTML：外部 <span class="hljs-selector-tag">HTML</span>，&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;；<br>innerText：内部文本，<span class="hljs-attribute">content</span> ；<br>outerText：内部文本，<span class="hljs-attribute">content</span> ；<br></code></pre></td></tr></table></figure><h4 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">它们的作用一模一样，区别仅在于传入参数的形式的不同。<br><br>apply 接受两个参数，第一个参数指定了函数体内 <span class="hljs-keyword">this</span> 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。<br><br>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 <span class="hljs-keyword">this</span> 指向，从第二个参数开始往后，每个参数被依次传入函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p><h4 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">一个拥有 <span class="hljs-built_in">length</span> 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。<br><br>常见的类数组对象有 <span class="hljs-keyword">arguments</span> 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 <span class="hljs-built_in">length</span><br>属性值，代表可接收的参数个数。<br></code></pre></td></tr></table></figure><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p><h4 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">数组和字符串的转换方法：<span class="hljs-built_in">toString</span>()、<span class="hljs-built_in">toLocalString</span>()、<span class="hljs-built_in">join</span>() 其中 <span class="hljs-built_in">join</span>() 方法可以指定转换为字符串时的分隔符。<br><br>数组尾部操作的方法 <span class="hljs-built_in">pop</span>() 和 <span class="hljs-built_in">push</span>()，push 方法可以传入多个参数。<br><br>数组首部操作的方法 <span class="hljs-built_in">shift</span>() 和 <span class="hljs-built_in">unshift</span>() 重排序的方法 <span class="hljs-built_in">reverse</span>() 和 <span class="hljs-built_in">sort</span>()，<span class="hljs-built_in">sort</span>() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。<br><br>数组连接的方法 <span class="hljs-built_in">concat</span>() ，返回的是拼接好的数组，不影响原数组。<br><br>数组截取办法 <span class="hljs-built_in">slice</span>()，用于截取数组中的一部分返回，不影响原数组。<br><br>数组插入方法 <span class="hljs-built_in">splice</span>()，影响原数组查找特定项的索引的方法，<span class="hljs-built_in">indexOf</span>() 和 <span class="hljs-built_in">lastIndexOf</span>() 迭代方法 <span class="hljs-built_in">every</span>()、<span class="hljs-built_in">some</span>()、<span class="hljs-attribute">filter</span>()、<span class="hljs-built_in">map</span>() 和 <span class="hljs-built_in">forEach</span>() 方法<br><br>数组归并方法 <span class="hljs-built_in">reduce</span>() 和 <span class="hljs-built_in">reduceRight</span>() 方法<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p><h4 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<span class="hljs-built_in"></span><br><span class="hljs-built_in">fill </span>方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p><h4 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">尾后逗号 （有时叫做“终止逗号”）在向 <span class="hljs-keyword">JavaScript </span>代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。<br><br><span class="hljs-keyword">JavaScript </span>一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript <span class="hljs-number">5</span>）中添加了尾后逗号。最近（ECMAS<br>cript <span class="hljs-number">2017</span>），又将其添加到函数参数中。但是 <span class="hljs-keyword">JSON </span>不支持尾后逗号。<br><br>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数<br>量。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p><h4 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。<br><br>造成变量声明提升的本质原因是 <span class="hljs-keyword">js </span>引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p><h4 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h4><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p><h4 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。<br><br>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。<br><br>新生代被分为 <span class="hljs-selector-tag">From</span> 和 <span class="hljs-selector-tag">To</span> 两个空间，<span class="hljs-selector-tag">To</span> 一般是闲置的。当 <span class="hljs-selector-tag">From</span> 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：<br><br>（<span class="hljs-number">1</span>）首先检查 <span class="hljs-selector-tag">From</span> 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 <span class="hljs-selector-tag">To</span> 空间。<br><br>（<span class="hljs-number">2</span>）如果对象不存活，则释放对象的空间。<br><br>（<span class="hljs-number">3</span>）最后将 <span class="hljs-selector-tag">From</span> 空间和 <span class="hljs-selector-tag">To</span> 空间角色进行交换。<br><br>新生代对象晋升到老生代有两个条件：<br><br>（<span class="hljs-number">1</span>）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 <span class="hljs-selector-tag">From</span> 空间复制到老生代中；若没有经历，则复制到 <span class="hljs-selector-tag">To</span> 空间。<br><br>（<span class="hljs-number">2</span>）第二个是 <span class="hljs-selector-tag">To</span> 空间的内存使用占比是否超过限制。当对象从 <span class="hljs-selector-tag">From</span> 空间复制到 <span class="hljs-selector-tag">To</span> 空间时，若 <span class="hljs-selector-tag">To</span> 空间使用超过 <span class="hljs-number">25%</span>，则对象直接晋升到老生代中。设置 <span class="hljs-number">25%</span> 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 <span class="hljs-selector-tag">To</span> 空间的内存太小，会影响后续的内存分配。<br><br>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。<br><br>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p><h4 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h4><p>相关知识点：</p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。<br><br>第二种情况是我们设置了 <span class="hljs-built_in">setInterval</span> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。<br><br>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回<br>收。<br><br>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h4 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 <span class="hljs-keyword">state</span> 记录加入到 history<br>对象中。一条 <span class="hljs-keyword">state</span> 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 <span class="hljs-keyword">state</span> 对象，我们可<br>以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。<br><br>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问<br>题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p><h4 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-string">&#x27;node&#x27;</span> : <span class="hljs-string">&#x27;browser&#x27;</span>;<br><br>通过判断当前环境的 <span class="hljs-variable language_">window</span> 对象类型是否为 <span class="hljs-literal">undefined</span>，如果是<span class="hljs-literal">undefined</span>，则说明当前脚本运行在node环境，否则说明运行在<span class="hljs-variable language_">window</span>环境。<br></code></pre></td></tr></table></figure><h4 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p><h4 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">移动端点击有 <span class="hljs-number">300</span>ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 <span class="hljs-number">300</span>ms，看用户有没有下一次点击，来判断这次操作是不是双击。<br></code></pre></td></tr></table></figure><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p><h4 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-number">1</span>）什么是前端路由？<br><br>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。<br><br>（<span class="hljs-number">2</span>）什么时候使用前端路由？<br><br>在单页面应用，大部分页面结构不变，只改变部分内容的使用<br><br>（<span class="hljs-number">3</span>）前端路由有什么优点和缺点？<br><br>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户<br><br>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置<br><br>前端路由一共有两种实现方式，一种是通过 <span class="hljs-built_in">hash</span> 的方式，一种是通过使用 pushState 的方式。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p><h4 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p><h4 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">检测浏览器版本一共有两种方式：<br><br>一种是检测 window.navigator.<span class="hljs-keyword">user</span>Agent 的值，但这种方式很不可靠，因为 <span class="hljs-keyword">user</span>Agent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 <span class="hljs-keyword">user</span>Agent 的值为 Mozilla 来躲过服务器的检测。<br><br>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p><h4 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。<br><br>比如说 <span class="hljs-built_in">querySelectorAll</span> 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。<br><br>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p><h4 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><br><span class="hljs-comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><br><span class="hljs-comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileExtension</span>(<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">return</span> filename.<span class="hljs-title function_">slice</span>(((filename.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>) - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p><h4 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span><br><br><span class="hljs-comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span><br><br><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>,<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">函数防抖是指在事件被触发 <span class="hljs-built_in">n</span> 秒后再执行回调，如果在这 <span class="hljs-built_in">n</span> 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。<br><br>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h4 id="92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h4><p>相关知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回<span class="hljs-literal">false</span>）。<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 在三等号判等的基础上特别处理了 <span class="hljs-literal">NaN</span> 、<span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> ，保证 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相同，但 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>) 会返回 <span class="hljs-literal">true</span>.<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。<br><br>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 <span class="hljs-literal">false</span>。<br><br>使用 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相等，两个 <span class="hljs-literal">NaN</span> 认定为是相等的。<br></code></pre></td></tr></table></figure><h4 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h4><p>相关知识点：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。<br>它们的根本区别在于，escape 在处理 <span class="hljs-number">0xff</span> 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF<span class="hljs-number">-8</span>，再在 UTF<span class="hljs-number">-8</span> 的每个字节码前加上一个「%」；在处理 <span class="hljs-number">0xff</span> 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 <span class="hljs-number">16</span> 进制 unicode，同时也是字符的 UTF<span class="hljs-number">-8</span>），只是范围（即哪些字符编码哪些字符不编码）不一样。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">encodeURI</span> 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。<br><br><span class="hljs-built_in">encodeURIComponent</span> 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。<br><br><span class="hljs-built_in">escape</span> 和 <span class="hljs-built_in">encodeURI</span> 的作用相同，不过它们对于 unicode 编码为 <span class="hljs-number">0xff</span> 之外字符的时候会有区别，<span class="hljs-built_in">escape</span> 是直接在字符的 unicode 编码前加上 %u，而 <span class="hljs-built_in">encodeURI</span> 首先会将字符转换为 UTF<span class="hljs-number">-8</span> 的格式，再在每个字节前加上 %。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h4 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Unicode</span> 是一种字符集合，现在可容纳 <span class="hljs-number">100</span> 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。<br><br><span class="hljs-attribute">UTF</span>-<span class="hljs-number">8</span> 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 <span class="hljs-number">1</span>~<span class="hljs-number">4</span> 个字节来表示一个字符。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h4 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h4><p>相关知识点：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，<span class="hljs-keyword">JS </span>引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。<br><br>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。<br><br>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲<br>染等。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h4 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = <span class="hljs-title function_">deepCopy</span>(object[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  <span class="hljs-built_in">Object</span>.assign 和展开运算符来实现。<br><br>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 <span class="hljs-built_in">JSON</span> 的两个函数来实现，但是由于 <span class="hljs-built_in">JSON</span> 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 <span class="hljs-built_in">Symbol</span> 类型的值时，会转换失败。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h4 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// apply 函数实现</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h4 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, args</span>) &#123;<br>  <span class="hljs-comment">// 获取函数需要的参数长度</span><br>  <span class="hljs-keyword">let</span> length = fn.<span class="hljs-property">length</span>;<br><br>  args = args || [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> subArgs = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 拼接得到现有的所有参数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      subArgs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span><br>    <span class="hljs-keyword">if</span> (subArgs.<span class="hljs-property">length</span> &gt;= length) &#123;<br>      <span class="hljs-comment">// 如果满足，执行函数</span><br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, subArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span><br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, subArgs);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// es6 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-property">length</span> &lt;= args.<span class="hljs-property">length</span> ? <span class="hljs-title function_">fn</span>(...args) : curry.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, fn, ...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h4 id="99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以<span class="hljs-number"> 64 </span>位双精度格式来存储数字的，只有<span class="hljs-number"> 53 </span>位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以<span class="hljs-number"> 64 </span>位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过<span class="hljs-number"> 53 </span>位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。<br><br>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。<br><br>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !&#x3D;&#x3D; 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h4 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。<br><br>正数的反码和其原码一样；负数的反码，符号位为<span class="hljs-number">1</span>，数值部分按原码取反。<br>如 [+<span class="hljs-number">7</span>]原 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]反 = <span class="hljs-number">00000111</span>； [-<span class="hljs-number">7</span>]原 = <span class="hljs-number">10000111</span>，[-<span class="hljs-number">7</span>]反 = <span class="hljs-number">11111000</span>。<br><br>正数的补码和其原码一样；负数的补码为其反码加<span class="hljs-number">1</span>。<br><br>例如 [+<span class="hljs-number">7</span>]原 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]反 = <span class="hljs-number">00000111</span>，[+<span class="hljs-number">7</span>]补 = <span class="hljs-number">00000111</span>；<br>[-<span class="hljs-number">7</span>]原 = <span class="hljs-number">10000111</span>，[-<span class="hljs-number">7</span>]反 = <span class="hljs-number">11111000</span>，[-<span class="hljs-number">7</span>]补 = <span class="hljs-number">11111001</span><br><br>之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p><h4 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">to</span>Precision 用于处理精度，精度是从左至右第一个不为 <span class="hljs-number">0</span> 的数开始数起。<br><span class="hljs-keyword">to</span>Fixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。<br></code></pre></td></tr></table></figure><h4 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。<br><br>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。<br><br>XSS 一般分为存储型、反射型和 DOM 型。<br><br>存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。<br><br>反射型指的是攻击者构建了特殊的 <span class="hljs-built_in">URL</span>，当服务器接收到请求后，从 <span class="hljs-built_in">URL</span> 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。<br><br>DOM 型指的是攻击者构建了特殊的 <span class="hljs-built_in">URL</span>，用户打开网站后，js 脚本从 <span class="hljs-built_in">URL</span> 中获取数据，从而导致了恶意代码的执行。<br><br>XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。<br><br>对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。<br><br>因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。<br><br>还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。<br><br>还可以对一些敏感信息进行保护，比如 cookie 使用 <span class="hljs-keyword">http</span>-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h4 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。<br><br>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta<br><span class="hljs-attribute">http-equiv</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Content-Security-Policy&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p><h4 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。<br><br>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。<br><br>一般的 CSRF 攻击类型有三种：<br><br>第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提<br>交。<br><br>第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。<br><br>第三种是链接类型的 CSRF 攻击，比如说在 <span class="hljs-keyword">a</span> 标签的 href 属性里构建一个请求，然后诱导用户去点击。<br><br>CSRF 可以用下面几种方法来防护：<br><br>第一种是同源检测的方法，服务器根据 <span class="hljs-keyword">http</span> 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。<br><br>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 <span class="hljs-keyword">token</span> ，然后服务器对这个 <span class="hljs-keyword">token</span> 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 <span class="hljs-keyword">token</span>，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 <span class="hljs-keyword">token</span> 的话，就没有办法验证了。这种情况我们可以通过改变 <span class="hljs-keyword">token</span> 的构建方式来解决。<br><br>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 <span class="hljs-built_in">URL</span> 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。<br><br>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h4 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。<br><br>将 Samesite 设为 <span class="hljs-keyword">strict</span> ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。<br><br>将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 <span class="hljs-keyword">GET</span> 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。<br><br>使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。<br></code></pre></td></tr></table></figure><h4 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 <span class="hljs-selector-tag">iframe</span> 嵌套的方式嵌入自己的网页中，并将 <span class="hljs-selector-tag">iframe</span> 设置为透明，在页面中透出一个按钮诱导用户点击。<br><br>我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 <span class="hljs-selector-tag">iframe</span> 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特<br>定的一些情况才能作为 <span class="hljs-selector-tag">iframe</span> 来使用。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p><h4 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span> 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 <span class="hljs-keyword">SQL</span> 代码，服务器使用参数构建数据库 <span class="hljs-keyword">SQL</span> 命令时，恶意 <span class="hljs-keyword">SQL</span> 被一起构<br>造，破坏原有 <span class="hljs-keyword">SQL</span> 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p><h4 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cos">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。<br><br>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。<br><br>MVC 通过分离 Model、<span class="hljs-keyword">View</span> 和 Controller 的方式来组织代码结构。其中 <span class="hljs-keyword">View</span> 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 <span class="hljs-keyword">View</span> 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 <span class="hljs-keyword">View</span> 层更新页面。Controller 层是 <span class="hljs-keyword">View</span> 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co<br>ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 <span class="hljs-keyword">View</span> 层更新。<br><br>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 <span class="hljs-keyword">View</span> 层的更新。这样 <span class="hljs-keyword">View</span> 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 <span class="hljs-keyword">View</span> 层和 Model 层的解耦。MVC 中的<br>Controller 只知道 Model 的接口，因此它没有办法控制 <span class="hljs-keyword">View</span> 层的更新，MVP 模式中，<span class="hljs-keyword">View</span> 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 <span class="hljs-keyword">View</span> 的变化绑定在一起，以此来实现 <span class="hljs-keyword">View</span> 和 Model 的同步更新。这样就实现了对 <span class="hljs-keyword">View</span> 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。<br><br>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 <span class="hljs-keyword">View</span> 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，<span class="hljs-keyword">View</span> 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功<br>能。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC&#x2F;MVP&#x2F;MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC&#x2F;MVP&#x2F;MVVM》</a></p><h4 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">vue 通过使用双向数据绑定，来实现了 View 和 <span class="hljs-keyword">Model</span> 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。<br><br>首先我们通过 Object.defineProperty() 方法来对 <span class="hljs-keyword">Model</span> 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 <span class="hljs-keyword">Model</span> 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。<br><br>数据在 html 模板中一共有两种绑定情况，一种是使用 v-<span class="hljs-keyword">model</span> 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。<br><br>如果遇到元素节点，并且属性值包含 v-<span class="hljs-keyword">model</span> 的话，我们就从 <span class="hljs-keyword">Model</span> 中去获取 v-<span class="hljs-keyword">model</span> 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 <span class="hljs-keyword">Model</span> 中的对应的属性的值进行更新。<br><br>如果遇到了绑定的文本节点，我们使用 <span class="hljs-keyword">Model</span> 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 <span class="hljs-keyword">Model</span> 层数据发生改变的时候，<span class="hljs-keyword">Model</span> 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数<br>据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p><h4 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Object</span>.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。<br><br>一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p><h4 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3<span class="hljs-number">.0</span> 中已经不使用这种方式了，而是通过使用 <span class="hljs-built_in">Proxy</span> 对对象进行代理，从而实现数据劫持。使用 <span class="hljs-built_in">Proxy</span> 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。<br></code></pre></td></tr></table></figure><h4 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi">我对 <span class="hljs-keyword">Virtual</span> DOM 的理解是，<br><br>首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。<br><br>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。<br><br>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。<br><br>我认为 <span class="hljs-keyword">Virtual</span> DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 <span class="hljs-keyword">Virtual</span> DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h4 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">两个树的完全 diff 算法的时间复杂度为 <span class="hljs-constructor">O(<span class="hljs-params">n</span>^3)</span> ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 <span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>。<br><br>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。<br><br>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。<br></code></pre></td></tr></table></figure><h4 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h4><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h4 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源<br>数。<br><br>我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。<br><br>Webpack 具有四个核心的概念，分别是 <span class="hljs-keyword">Entry</span>（入口）、Output（输出）、loader 和 Plugins（插件）。<br><br><span class="hljs-keyword">Entry</span> 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。<br><br>Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。<br><br>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。<span class="hljs-keyword">use</span> 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。<br><br>插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。<br><br>使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.<span class="hljs-number">0</span> 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h4 id="116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？"><a href="#116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？"></a>116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span>，如果有滚动条，不包含滚动条。<br>clientTop 返回的是上边框的宽度。<br>clientLeft 返回的左边框的宽度。<br><br>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + <span class="hljs-attribute">border</span> 包含了滚动条。<br>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。<br>offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。<br><br>scrollWidth/scrollHeight 返回值包含 <span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + 溢出内容的尺寸。<br>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。<br>scrollLeft 属性返回的是元素滚动条到元素左边的距离。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h4 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">简单说，<span class="hljs-string">&quot;函数式编程&quot;</span>是一种<span class="hljs-string">&quot;编程范式&quot;</span>（programming paradigm），也就是如何编写程序的方法论。<br><br>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是<span class="hljs-string">&quot;第一等公民&quot;</span>、只用<span class="hljs-string">&quot;表达式&quot;</span>。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h4 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h4><p>相关资料：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">回调函数<br>优点：简单、容易理解<br>缺点：不利于维护，代码耦合高<br><br>事件监听（采用时间驱动模式，取决于某个事件是否发生）：<br>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：事件驱动型，流程不够清晰<br><br>发布/订阅（观察者模式）<br>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者<br><br><span class="hljs-built_in">Promise</span> 对象<br>优点：可以利用 <span class="hljs-keyword">then</span> 方法，进行链式写法；可以书写错误时的回调函数；<br>缺点：编写和理解，相对比较难<br><br><span class="hljs-built_in">Generator</span> 函数<br>优点：函数体内外的数据交换、错误处理机制<br>缺点：流程管理不方便<br><br><span class="hljs-keyword">async</span> 函数<br>优点：内置执行器、更好的语义、更广的适用性、返回的是 <span class="hljs-built_in">Promise</span>、结构清晰。<br>缺点：错误处理机制<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中的异步机制可以分为以下几种：<br><br>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br><br>第二种是 <span class="hljs-built_in">Promise</span> 的方式，使用 <span class="hljs-built_in">Promise</span> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 <span class="hljs-keyword">then</span> 的链式调用，可能会造成代码的语义不够明确。<br><br>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。<br><br>第四种是使用 <span class="hljs-keyword">async</span> 函数的形式，<span class="hljs-keyword">async</span> 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <span class="hljs-keyword">await</span> 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br></code></pre></td></tr></table></figure><h4 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">CSS3 的动画的优点<br><br>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化<br>代码相对简单<br><br>缺点<br><br>在动画控制上不够灵活<br>兼容性不好<br><br><span class="hljs-keyword">JavaScript </span>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 <span class="hljs-keyword">javascript </span>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧<br></code></pre></td></tr></table></figure><h4 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">误区：我们经常说 <span class="hljs-built_in">get</span> 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。<br><br>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 <span class="hljs-built_in">get</span> 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:<br></code></pre></td></tr></table></figure><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h4 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">URI: Uniform Resource Identifier      指的是统一资源标识符<br><span class="hljs-built_in">URL</span>: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称<br><br>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。<br><br><span class="hljs-built_in">URL</span> 指的是统一资源定位符，URN 指的是统一资源名称。<span class="hljs-built_in">URL</span> 和 URN 是 URI 的子集，<span class="hljs-built_in">URL</span> 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p><h4 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h4><p>相关知识点：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">get</span> 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br><br><span class="hljs-built_in">post</span> 不同，<span class="hljs-built_in">post</span> 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 <span class="hljs-built_in">get</span> 请求适合于请求缓存。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">缓存一般只适用于那些不会更新服务端数据的请求。一般 <span class="hljs-built_in">get</span> 请求都是查找请求，不会对服务器资源数据造成修改，而 <span class="hljs-built_in">post</span> 请求一般都会对服务器数据造成修改，所以，一般会对 <span class="hljs-built_in">get</span> 请求进行缓存，很少会对 <span class="hljs-built_in">post</span> 请求进行缓存。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h4 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h4><p>相关知识点：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br><br>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br><br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。<br><br>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。<br><br>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/">《基于用户行为的图片等资源预加载》</a></p><h4 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。<br><br>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h4 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h4><p>相关知识点：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">首先是三个事件，分别是 <span class="hljs-built_in">mousedown</span>，<span class="hljs-built_in">mousemove</span>，<span class="hljs-built_in">mouseup</span><br>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 <span class="hljs-built_in">mousemove</span> 里面的具体方法。<br>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示<br>元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠<br>标抬起，拖拽过程结束。<br><br>这三步分别对应了三个事件，<span class="hljs-built_in">mousedown</span> 事件，<span class="hljs-built_in">mousemove</span> 事件和 <span class="hljs-built_in">mouseup</span> 事件。只有在鼠标按下的状态移动鼠标我们才会<br>执行拖拽事件，因此我们需要在 <span class="hljs-built_in">mousedown</span> 事件中设置一个状态来标识鼠标已经按下，然后在 <span class="hljs-built_in">mouseup</span> 事件中再取消这个状<br>态。在 <span class="hljs-built_in">mousedown</span> 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠<br>标的位置。然后在 <span class="hljs-built_in">mousemove</span> 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。<br>最后 <span class="hljs-built_in">mouseup</span> 事件触发后，清除状态，结束拖拽事件。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465">《原生 js 实现拖拽功能基本思路》</a></p><h4 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h4><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  <span class="hljs-keyword">var</span> timer = &#123;<br>    <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">interval</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">flag</span>) &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 启动定时器</span><br>  <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br><br>  <span class="hljs-comment">// 返回控制器</span><br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setInterval</span> 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。<br><br>针对 <span class="hljs-built_in">setInterval</span> 的这个缺点，我们可以使用 <span class="hljs-built_in">setTimeout</span> 递归调用来模拟 <span class="hljs-built_in">setInterval</span>，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 <span class="hljs-built_in">setInterval</span> 的问题。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737">《setInterval 有什么缺点？》</a></p><h4 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h4><ul><li>1.声明的变量只在声明时的代码块内有效</li><li>2.不存在声明提升</li><li>3.存在暂时性死区，如果在变量声明前使用，会报错</li><li>4.不允许重复声明，重复声明会报错</li></ul><h4 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">rest</span> 参数（形式为...变量名），用于获取函数的多余参数。<br></code></pre></td></tr></table></figure><h4 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br></code></pre></td></tr></table></figure><h4 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h4><ul><li>1.Symbol 函数前不能使用 new 命令，否则会报错。</li><li>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>3.Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><h4 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h4><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li></ul><h4 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h4><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h4 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Proxy</span> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。<br><br><span class="hljs-built_in">Proxy</span> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<span class="hljs-built_in">Proxy</span> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br></code></pre></td></tr></table></figure><h4 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h4><ul><li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li><li>3.让 Object 操作都变成函数行为。</li><li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h4 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当 Node 遇到 <span class="hljs-built_in">require</span>(X) 时，按下面的顺序处理。<br><br>（<span class="hljs-number">1</span>）如果 X 是内置模块（比如 <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)）<br>　　<span class="hljs-selector-tag">a</span>. 返回该模块。<br>　　<span class="hljs-selector-tag">b</span>. 不再继续执行。<br><br>（<span class="hljs-number">2</span>）如果 X 以 <span class="hljs-string">&quot;./&quot;</span> 或者 <span class="hljs-string">&quot;/&quot;</span> 或者 <span class="hljs-string">&quot;../&quot;</span> 开头<br>　　<span class="hljs-selector-tag">a</span>. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　<span class="hljs-selector-tag">b</span>. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X<br>    X<span class="hljs-selector-class">.js</span><br>    X<span class="hljs-selector-class">.json</span><br>    X<span class="hljs-selector-class">.node</span><br><br>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X/package.json（main字段）<br>    X/index<span class="hljs-selector-class">.js</span><br>    X/index<span class="hljs-selector-class">.json</span><br>    X/index<span class="hljs-selector-class">.node</span><br><br>（<span class="hljs-number">3</span>）如果 X 不带路径<br>　　<span class="hljs-selector-tag">a</span>. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　<span class="hljs-selector-tag">b</span>. 依次在每个目录中，将 X 当成文件名或目录名加载。<br><br>（<span class="hljs-number">4</span>）抛出 <span class="hljs-string">&quot;not found&quot;</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p><h4 id="136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span> 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript <span class="hljs-built_in">Promise</span> 的标准，规定了一个 <span class="hljs-built_in">Promise</span> 所必须具有的特性。<br><br><span class="hljs-built_in">Promise</span> 是一个构造函数，接收一个函数作为参数，返回一个 <span class="hljs-built_in">Promise</span> 实例。一个 <span class="hljs-built_in">Promise</span> 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们<br>可以在异步操作结束后调用这两个函数改变 <span class="hljs-built_in">Promise</span> 实例的状态，它的原型上定义了一个 <span class="hljs-keyword">then</span> 方法，使用这个 <span class="hljs-keyword">then</span> 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566">《Promises&#x2F;A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p><h4 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED</span> = <span class="hljs-string">&quot;resolved&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 保存初始化状态</span><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">PENDING</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 用于保存 reject 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 状态转变为 resolved 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">RESOLVED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 状态转变为 rejected 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将两个方法传入函数执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span><br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br>  onResolved =<br>    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span><br>      ? onResolved<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>          <span class="hljs-keyword">return</span> value;<br>        &#125;;<br><br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>          <span class="hljs-keyword">throw</span> error;<br>        &#125;;<br><br>  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onResolved);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">RESOLVED</span>) &#123;<br>    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">用 <span class="hljs-keyword">JS </span>设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。<br></code></pre></td></tr></table></figure><h4 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>统计使用浏览器的 window.error 事件。<br></code></pre></td></tr></table></figure><h4 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。<br></code></pre></td></tr></table></figure><h4 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。<br></code></pre></td></tr></table></figure><h4 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。<br></code></pre></td></tr></table></figure><h4 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。<br></code></pre></td></tr></table></figure><h4 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 <span class="hljs-keyword">js </span>时间格式化的接口进行修改，这个时候就可以使用适配器模式。<br></code></pre></td></tr></table></figure><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p><h4 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">发布订阅模式其实属于广义上的观察者模式<br><br>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。<br><br>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p><h4 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Vue</span> 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。<br></code></pre></td></tr></table></figure><h4 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Vue 一共有<span class="hljs-number">8</span>个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<br><br>（<span class="hljs-number">1</span>）<span class="hljs-keyword">beforeCreate </span>钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。<br><br>（<span class="hljs-number">2</span>）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-keyword">beforeMount </span>钩子函数，在组件被挂载到页面之前触发。在 <span class="hljs-keyword">beforeMount </span>之前，会找到对应的 template，并编译成 render 函数。<br><br>（<span class="hljs-number">4</span>）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">beforeUpdate </span>钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。<br><br>（<span class="hljs-number">6</span>）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">beforeDestroy </span>钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。<br><br>（<span class="hljs-number">8</span>）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><br>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p><h4 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）父子组件间通信<br><br>第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事<br>件来向父组件发送数据。<br><br>第二种是通过 ref 属性给子组件设置一个名字。父组件通过 <span class="hljs-variable">$refs</span> 组件名来获得子组件，子组件通过 <span class="hljs-variable">$parent</span> 获得父组<br>件，这样也可以实现通信。<br><br>第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件<br>中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。<br><br>（2）兄弟组件间通信<br><br>第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实<br>例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。<br><br>第二种是通过 <span class="hljs-variable">$parent</span>.<span class="hljs-variable">$refs</span> 来获取到兄弟组件，也可以进行通信。<br><br>（3）任意组件之间<br><br>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。<br><br><br>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候<br>可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个<br>公共数据进行读写操作，这样达到了解耦的目的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p><h4 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。<br><br>（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。<br><br>（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h4 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">（1）全局的钩子函数 beforeEach 和 afterEach<br><br>beforeEach 有三个参数，<span class="hljs-keyword">to</span> 代表要进入的路由对象，<span class="hljs-keyword">from</span> 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 <span class="hljs-literal">false</span>，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 <span class="hljs-built_in">error</span> ，则导航终止，<span class="hljs-built_in">error</span> 传入错误的监听函数。<br><br>（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。<br><br>（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组<br>件内部直接进行定义的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h4 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-variable">$route</span> 是“路由信息对象”，包括<span class="hljs-built_in"> path</span>，params，hash，query，fullPath，matched<span class="hljs-built_in">，name</span> 等路由信息参数。而 <span class="hljs-variable">$router</span> 是“路由实例”对象包括了路由的跳转方法，钩子函数等。<br></code></pre></td></tr></table></figure><h4 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.prevent</span>: 提交事件不再重载页面；<span class="hljs-string">.stop</span>: 阻止单击事件冒泡；<span class="hljs-string">.self</span>: 当事件发生在该元素本身而不是子元素的时候会触发；<br></code></pre></td></tr></table></figure><h4 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lsl">vue 中 <span class="hljs-type">key</span> 值的作用可以分为两种情况来考虑。<br><br>第一种情况是 v-if 中使用 <span class="hljs-type">key</span>。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 <span class="hljs-type">key</span> 来唯一的标识一个元素，这个情况下，使用 <span class="hljs-type">key</span> 的元素不会被复用。这个时候 <span class="hljs-type">key</span> 的作用是用来标识一个独立的元素。<br><br>第二种情况是 v-for 中使用 <span class="hljs-type">key</span>。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 <span class="hljs-type">key</span> 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 <span class="hljs-type">key</span> 的作用是为了高效的更新渲染虚拟 DOM。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h4 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">computed</span> 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。<br><br>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br></code></pre></td></tr></table></figure><h4 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <span class="hljs-meta">keep</span>-alive 组件包裹需要保存的组件。<br></code></pre></td></tr></table></figure><h4 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">mixin</span> 用于全局混入，会影响到每个组件实例。<br><br>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h4 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）application/x-www-form-urlencoded<br><br>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL<br>转码。<br><br>（2）multipart/form-data<br><br>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。<br><br>（3）application/json<br><br>告诉服务器消息主体是序列化后的 JSON 字符串。<br><br>（4）text/xml<br><br>该种方式主要用来提交 XML 格式的数据。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p><h4 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value),<br>      type = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    type.<span class="hljs-title function_">pop</span>();<br><br>    <span class="hljs-keyword">return</span> type.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p><h4 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkNullObj</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p><h4 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><br><span class="hljs-comment">// 使用 let 块级作用域</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url, params, callback</span>) &#123;<br>  <span class="hljs-comment">// 判断是否含有参数</span><br>  <span class="hljs-keyword">let</span> queryString = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) === -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>  <span class="hljs-comment">// 添加参数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> params) &#123;<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>      queryString += k + <span class="hljs-string">&quot;=&quot;</span> + params[k] + <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理回调函数名</span><br>  <span class="hljs-keyword">let</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>      .<span class="hljs-title function_">toString</span>()<br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>),<br>    callbackName = <span class="hljs-string">&quot;myJsonp&quot;</span> + random;<br><br>  <span class="hljs-comment">// 添加回调函数</span><br>  queryString += <span class="hljs-string">&quot;callback=&quot;</span> + callbackName;<br><br>  <span class="hljs-comment">// 构建请求</span><br>  <span class="hljs-keyword">let</span> scriptNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>  scriptNode.<span class="hljs-property">src</span> = url + queryString;<br><br>  <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用回调函数</span><br>    <span class="hljs-title function_">callback</span>(...<span class="hljs-variable language_">arguments</span>);<br><br>    <span class="hljs-comment">// 删除这个引入的脚本</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">removeChild</span>(scriptNode);<br>  &#125;;<br><br>  <span class="hljs-comment">// 发起请求</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(scriptNode);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p><h4 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> topics = &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 注册监听函数</span><br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>      topics[topic].<span class="hljs-title function_">push</span>(handler);<br>    &#125;,<br><br>    <span class="hljs-comment">// 发布事件，触发观察者回调事件</span><br>    <span class="hljs-attr">publish</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, info</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) &#123;<br>          <span class="hljs-title function_">handler</span>(info);<br>        &#125;);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的一个观察者的回调事件</span><br>    <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-keyword">var</span> handlerIndex = -<span class="hljs-number">1</span>;<br>      topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (item === handler) &#123;<br>          handlerIndex = index;<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-keyword">if</span> (handlerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        topics[topic].<span class="hljs-title function_">splice</span>(handlerIndex, <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的所有观察者的回调事件</span><br>    <span class="hljs-attr">removeAll</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p><h4 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] || [];<br>    callbacks.<span class="hljs-title function_">push</span>(callback);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn !== callback);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, ...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    callbacks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>(...args);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">wrapFun</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-title function_">callback</span>(...args);<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, wrapFun);<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(event, wrapFun);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>);<br>&#125;;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-comment">//请写出以下输出结果：</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p><h4 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。<br><br>使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 <span class="hljs-built_in">Date</span> 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。<br><br>为了解决这两个不足之处，ECMAScript <span class="hljs-number">5</span>引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到<span class="hljs-number">1</span>毫秒<br>的千分之一（<span class="hljs-number">1</span>秒的百万分之一）。<br><br>navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。<br><br>loadEventEnd：返回当前网页 <span class="hljs-keyword">load</span> 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> t = performance.<span class="hljs-property">timing</span>;<br><span class="hljs-keyword">var</span> pageLoadTime = t.<span class="hljs-property">loadEventEnd</span> - t.<span class="hljs-property">navigationStart</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h4 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal">（<span class="hljs-number">1</span>）第一个字符必须是字母、下划线（_）或美元符号（<span class="hljs-variable">$）</span><br>（<span class="hljs-number">2</span>）余下的字符可以是下划线、美元符号或任何字母或数字字符<br><br>一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p><h4 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有<br>利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。<br></code></pre></td></tr></table></figure><h4 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Object.<span class="hljs-keyword">as</span><span class="hljs-meta">sign</span>() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br></code></pre></td></tr></table></figure><h4 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Math.ceil() <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 向上取整，函数返回一个大于或等于给定数字的最小整数。<br><br>Math.floor() <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 向下取整，函数返回一个小于或等于给定数字的最大整数。<br></code></pre></td></tr></table></figure><h4 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>, j &lt; <span class="hljs-number">9</span>; i++, j++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, j);<br>&#125;<br><br><span class="hljs-comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span><br><span class="hljs-comment">// 当判断语句为空时，循环会一直进行。</span><br></code></pre></td></tr></table></figure><h4 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？<br><br>解决办法：<br><br>（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。<br><br>（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。<br><br>（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。<br></code></pre></td></tr></table></figure><h4 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">在前端实现中我们一般通过 <span class="hljs-built_in">setTimeout</span> 和 <span class="hljs-built_in">setInterval</span> 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，<span class="hljs-built_in">setTimeout</span> 和 <span class="hljs-built_in">setInterval</span> 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。<br><br>一般解决倒计时中的误差的有这样两种办法：<br><br>（<span class="hljs-number">1</span>）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。<br><br>（<span class="hljs-number">2</span>）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 <span class="hljs-built_in">setTimeout</span> 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p><h4 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h4><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p><h4 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostWord</span>(<span class="hljs-params">article</span>) &#123;<br>  <span class="hljs-comment">// 合法性判断</span><br>  <span class="hljs-keyword">if</span> (!article) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 参数处理</span><br>  article = article.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>();<br><br>  <span class="hljs-keyword">let</span> wordList = article.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+/g</span>),<br>    visited = [],<br>    maxNum = <span class="hljs-number">0</span>,<br>    maxWord = <span class="hljs-string">&quot;&quot;</span>;<br><br>  article = <span class="hljs-string">&quot; &quot;</span> + wordList.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;  &quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br><br>  <span class="hljs-comment">// 遍历判断单词出现次数</span><br>  wordList.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">indexOf</span>(item) &lt; <span class="hljs-number">0</span>) &#123;<br><br>      <span class="hljs-comment">// 加入 visited </span><br>      visited.<span class="hljs-title function_">push</span>(item);<br><br>      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot; &quot;</span> + item + <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;g&quot;</span>),<br>        num = article.<span class="hljs-title function_">match</span>(word).<span class="hljs-property">length</span>;<br><br>      <span class="hljs-keyword">if</span> (num &gt; maxNum) &#123;<br>        maxNum = num;<br>        maxWord = item;<br>      &#125;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> maxWord + <span class="hljs-string">&quot;  &quot;</span> + maxNum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="175-ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#175-ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="175. ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>175. ele.getElementsByClassName和ele.querySelectorAll的区别？</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">element</span>.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection<br><span class="hljs-type">element</span>.querySelectorAll 返回一个非即时更新（静态的） NodeList<br>// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> list1 = parent.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> list2 = parent.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list1.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list2.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> newP = docuemnt.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;p&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">newP.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;p&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">parent.<span class="hljs-title function_">appendChild</span>(newP);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list1.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 4 (即时更新)</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list2.<span class="hljs-property">length1</span>); <span class="hljs-comment">// 3（非即时更新）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>// 在说下返回值<br>// HTMLCollection 和 NodeList 都是类数组形式<br>如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection<br>EventTarget - Node - Element - HTMLElement - HTMLDivElement<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml">EventTarget - Node - Element - SVGElement - SVGPathElement</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement">MDN 上元素 div 继承关系</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react-router-dom</title>
    <link href="/2023/05/20/react-router-dom/"/>
    <url>/2023/05/20/react-router-dom/</url>
    
    <content type="html"><![CDATA[<h1 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h1><p>单页面应用（single page web application，SPA），就是只有一张 Web 页面的应用，整个 web 应用只加载一个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。</p><h2 id="单页面应用的优势和缺陷"><a href="#单页面应用的优势和缺陷" class="headerlink" title="单页面应用的优势和缺陷"></a>单页面应用的优势和缺陷</h2><ul><li>优点<ol><li>用户体验好. 切换页面不需要再次请求服务器获取页面,页面加载速度更快</li><li>减轻服务器压力. 因为只有一个 web 页面,视图切换时,不会再次向服务器发起请求</li></ol></li><li>缺点<ol><li>不利于 SEO. 因为所有的页面都在一个 web 页面中动态展示,SEO 效果不如静态页面</li><li>第一次加载耗时长. 整个应用的所有页面都写在一个 web 页面中,包裹 js 和 css 都打包成一个文件.第一次加载时就需要更长的时间</li></ol></li></ul><h2 id="单页面应用原理"><a href="#单页面应用原理" class="headerlink" title="单页面应用原理"></a>单页面应用原理</h2><p> 在单页 Web 应用程序中，当浏览器向服务器发出第一个请求时，服务器会发回 index.html 文件. 用户需要切换页面时,会改变浏览器地址的路径(但不发送请求). 路径发生变化之后,根据之前配置好的前端路由规则,找到与当前路径匹配的视图,让其视图展示.其他视图隐藏. 展示视图需要渲染的数据,通过 ajax 获取.然后在前端渲染</p><h2 id="实现单页面应用要处理的三个问题"><a href="#实现单页面应用要处理的三个问题" class="headerlink" title="实现单页面应用要处理的三个问题"></a>实现单页面应用要处理的三个问题</h2><ol><li>定义路径和视图的一一对应规则(前端路由)</li><li>监听浏览器地址栏路径的变化</li><li>当路径变化,根据前端路由找到对应的视图并展示,其他视图不展示(在 react 中每一个页面视图都是一个组件)</li></ol><h1 id="react-router-使用"><a href="#react-router-使用" class="headerlink" title="react-router 使用"></a>react-router 使用</h1><blockquote><p>react-router 提供了三个包:</p><ul><li><p>react-router 核心包</p></li><li><p>react-router-dom web 单页面应用使用的包,包含 react-router 核心包(我们下载并使用这个包)</p></li><li><p>react-router-native 原生 app 单页面应用使用的包,包含 react-router 核心包</p></li></ul></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>下包</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">npm i react-router-dom<br></code></pre></td></tr></table></figure></li><li><p>在入口文件中使用<code>BrowserRouter</code>包裹整个应用结构</p><blockquote><p><code>&lt;BrowserRouter&gt;</code>包裹整个应用,只需要使用一次。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;3,7-9&#125;">// index.js<br>import * as React from &#x27;react&#x27;<br>import * as ReactDOM from &#x27;react-dom/client&#x27;<br>import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;<br><br>ReactDOM.createRoot(document.getELementById(&#x27;root&#x27;)).render(<br>  &lt;BrowserRouter&gt;<br>    &lt;App /&gt;<br>  &lt;/BrowserRouter&gt;<br>  )<br></code></pre></td></tr></table></figure></li><li><p>在根组件中配置前端路由规则:</p><blockquote><p><code>&lt;Route&gt;</code> 用于配置前端路由规则</p><p><code>&lt;Routes&gt;</code> 每当路径发生变化时,都会查看其所有子 <code>&lt;Route&gt;</code> 元素以找到最佳匹配并呈现 UI</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;/* Route必须被Routes包裹 */&#125;</span><br><span class="language-xml">      &#123;/* Route写在哪里,则Route对应的组件就渲染在哪里(这一点只针对一级路由) */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">        &#123;/* path属性用于定义路径  element属性用于定义当前路径所对应的组件 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Login</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        &#123;/* path也可以忽略 /  */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;home&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">        &#123;/*Route 也可以不写element. 入按照下面的方式定义,则展示Demo组件的路径为: /users/xxx */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Demo</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用 Link 组件定义导航按钮</p><blockquote><p>作用: 修改浏览器的地址栏路径,并且不发送请求(最终渲染的是 a 标签)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Link</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>点击展示home页面<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;4-8,20-22&#125;">// App.js<br>import React from &#x27;react&#x27;<br>import &#123; Routes, Route, Link &#125; from &#x27;react-router-dom&#x27;<br>// 路由组件推荐使用懒加载的方式引入<br>const Home = React.lazy(()=&gt;import(&#x27;./pages/Home&#x27;))<br>const Login = React.lazy(()=&gt;import(&#x27;./pages/Login&#x27;))<br>const Test1 = React.lazy(()=&gt;import(&#x27;./pages/Test1&#x27;))<br>const Test2 = React.lazy(()=&gt;import(&#x27;./pages/Test2&#x27;))<br>import &#x27;./App.css&#x27;<br>export default function App() &#123;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;<br>        &lt;Link to=&quot;/login&quot;&gt;登录页&lt;/Link&gt;<br>        &lt;hr /&gt;<br>      &lt;/div&gt;<br>      &lt;Routes&gt;<br>        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;<br>          &#123;/*Route里面的Route就是嵌套路由,Test1和Test2渲染在Home组件中*/&#125;<br>          &lt;Route path=&quot;/home/test1&quot; element=&#123;&lt;Test1 /&gt;&#125;&gt;&lt;/Route&gt;<br>          &lt;Route path=&quot;/home/test2&quot; element=&#123;&lt;Test2 /&gt;&#125;&gt;&lt;/Route&gt;<br>        &lt;/Route&gt;<br>        &lt;Route path=&quot;/login&quot; element=&#123;&lt;Login /&gt;&#125;&gt;&lt;/Route&gt;<br>      &lt;/Routes&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;12,13&#125;">// Home.js<br>import React from &#x27;react&#x27;<br>import &#123; Link, Outlet &#125; from &#x27;react-router-dom&#x27;<br><br>export default function Home() &#123;<br>  return (<br>    &lt;div style=&#123;&#123; height: &#x27;100vh&#x27;, backgroundColor: &#x27;pink&#x27; &#125;&#125;&gt;<br>      &lt;h1&gt;home&lt;/h1&gt;<br>      &lt;Link to=&quot;/home/test1&quot;&gt;test1&lt;/Link&gt; &lt;br /&gt;<br>      &lt;Link to=&quot;/home/test2&quot;&gt;test2&lt;/Link&gt;<br>      &lt;hr /&gt;<br>      &#123;/*Outlet组件决定了嵌套路由组件渲染的位置*/&#125;<br>      &lt;Outlet&gt;&lt;/Outlet&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><blockquote><p>通过运行代码导致的页面切换被叫做编程式导航</p></blockquote><p>页面切换有两种场景:</p><ol><li><p>用户点击导航按钮</p></li><li><p>程序运行到某个指定阶段自动切换页面(比如: 登录成功之后,页面自动切换到首页)</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>引入<code>useNavigate</code>并调用,返回一个函数.执行返回的函数就可以实现编程式导航</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx&#123;3&#125;">import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;<br>export default function Test2() &#123;<br>  const navigate = useNavigate()<br>  const handle = () =&gt; &#123;<br>    //  navigate(&#x27;目标页面的路径&#x27;, &#123;<br>    //   replace: true, // 是否开启替换历史记录 true为开启,默认值是false<br>    // &#125;)<br>    navigate(&#x27;/login&#x27;, &#123;<br>      replace: true<br>    &#125;)<br><br>    // 或 navigate(-1) //类似于history.go()方法<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>      &lt;h1&gt;test2&lt;/h1&gt;<br>      &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h1><blockquote><p>路由传参是值: 页面切换的时候,给目标页面传递数据</p></blockquote><p>路由传参有三种方式:</p><ol><li><p>路由参数(数据在路径中,只能传递简单数据)</p></li><li><p>state(可以传递任何数据)</p></li><li><p>查询字符串(不推荐)</p></li></ol><h2 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h2><ol><li><p>定义路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span></span><br><span class="language-xml">      &#123;/*:id 为路由参数(必填), 可以配置多个*/&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;about/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      &#123;/*:id 为可选路由参数 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 切换页面的时候传递</span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/about/1&#x27;</span>) <span class="hljs-comment">//这个1就是路由参数</span><br>&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/about/2&quot;</span>&gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span> <span class="hljs-comment">//2 和 3 就是路由参数</span><br></code></pre></td></tr></table></figure></li><li><p>接收路由参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 在目标路由组件中接收</span><br><span class="hljs-keyword">import</span> &#123; useParams &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-comment">// params 是一个对象,里面可以获取到路由参数具体的值</span><br><span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParmas</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params) <span class="hljs-comment">// &#123;id:1&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><ol><li><p>传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/目标路径&quot;</span> state=&#123;要传递数据&#125;&gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/目标路径&quot;</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;要传递数据&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/目标路径&#x27;</span>, &#123;<br> <span class="hljs-attr">state</span>: 要传递的数据<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useLocaiton &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>()<br>location.<span class="hljs-property">state</span> <span class="hljs-comment">//可以获取到数据</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><ol><li><p>传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Link</span> to=<span class="hljs-string">&quot;/目标路径?name=zs&amp;age=18&quot;</span> &gt;&lt;/<span class="hljs-title class_">Link</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/目标路径?name=zs&amp;age=18&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><span class="hljs-title function_">navigate</span>(<span class="hljs-string">&#x27;/目标路径?name=zs&amp;age=18&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>接收</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useSearchParams</span>()<br><span class="hljs-comment">// query是类似formdata对象,获取数据:query.get(&#x27;name&#x27;)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(query.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)) <span class="hljs-comment">// zs</span><br><span class="hljs-comment">// setQuery 可以修改地址栏查询字符串 setQuery(&quot;x=1&amp;y=2&quot;)</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="通过路由表定义路由规则"><a href="#通过路由表定义路由规则" class="headerlink" title="通过路由表定义路由规则"></a>通过路由表定义路由规则</h1><p>实际开发中一般会使用<code>路由表</code>动态创建<code>Routes</code>和<code>Route</code>.</p><p>路由表其实就是一个数组,如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-comment">//path 对应 Route的path</span><br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Home</span>&gt;</span></span>, <span class="hljs-comment">//element 对应Route的element</span><br>    <span class="hljs-comment">// children 对应 嵌套路由</span><br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test1</span>&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;test2&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Test2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test2</span>&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;:id&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">About</span>&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">About</span>&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><h2 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h2><p>调用 <code>useRoutes</code>,传入<code>路由表</code>,返回动态创建的 <code>Routes</code> 和 <code>Route</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span> <span class="hljs-comment">//引入路由表</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;useRoutes(routes)&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 上面的useRoutes返回的结果:</span><br>;&lt;Routes&gt;<br>  &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;<br>    &lt;Route path=&quot;test1&quot; element=&#123;&lt;Test1 /&gt;&#125;&gt;&lt;/Route&gt;<br>    &lt;Route path=&quot;test2&quot; element=&#123;&lt;Test2 /&gt;&#125;&gt;&lt;/Route&gt;<br>  &lt;/Route&gt;<br>  &lt;Route path=&quot;about&quot; &gt;<br>    &lt;Route path=&quot;:id&quot; element=&#123;&lt;About /&gt;&#125;&gt;<br>    &lt;Route path=&quot;&quot; element=&#123;&lt;About /&gt;&#125;&gt;<br>  &lt;/Route&gt;<br>&lt;/Routes&gt;<br></code></pre></td></tr></table></figure><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><h2 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h2><blockquote><p>作用: 与 Link 组件一样,但是可以快速实现导航高亮</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 注意: 默认类名是active, 下面是自定义的style和类名</span><br>&lt;<span class="hljs-title class_">NavLink</span><br>    to=<span class="hljs-string">&quot;login&quot;</span><br>    style=&#123;<span class="hljs-function">(<span class="hljs-params">&#123; isActive &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;login&#x27;</span>, isActive)<br>        <span class="hljs-keyword">return</span> isActive ? activeStyle : <span class="hljs-literal">undefined</span><br>    &#125;&#125;&gt;<br>        login<br>&lt;/<span class="hljs-title class_">NavLink</span>&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;(&#123;</span> <span class="hljs-attr">isActive</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        console.log(&#x27;home&#x27;, isActive)</span><br><span class="language-xml">        return isActive ? &#x27;base one&#x27; : &#x27;base&#x27;</span><br><span class="language-xml">    &#125;&#125;&gt;</span><br><span class="language-xml">        home</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br><br><span class="hljs-comment">// 注意:  默认,当Home的子组件匹配成功,Home的导航也会高亮.当NavLink上添加了end属性,则Home的子组件匹配成功的时候,Home的导航没有高亮效果</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">end</span></span></span><br><span class="hljs-tag"><span class="language-xml">&gt;</span></span><br><span class="language-xml">        home</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="Navigate"><a href="#Navigate" class="headerlink" title="Navigate"></a>Navigate</h2><blockquote><p>只要 Navigate 组件被解析,就会修改路径,切换视图</p><p>一般用来展示 404 页面</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useRoutes</span>([<br>  &#123;<br>    ...忽略,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/404&quot;</span> /&gt;</span></span>,<br>  &#125;,<br>])<br></code></pre></td></tr></table></figure><h2 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h2><blockquote><p>作用与 BrowserRouter 一样,但是修改的是地址栏的 hash 值.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
